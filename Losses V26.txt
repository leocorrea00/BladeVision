// ========================== CONFIG & CONSTANTS ==========================
const MAX_DEPTH = 5000; // m
const BOP_DEPTH = 2000; // m
const SHOE_DEPTH = 4000; // m
const TD_DEPTH = 5000; // m
const PSI_COEF = 0.1704; // psi per (ppg·m)
const PPG_TO_KGM3 = 119.826427; // kg/m³ per ppg
const LBF100FT2_to_Pa = 0.4788025892; // Pa per (lbf/100ft^2)
// Flow limits for UI
const MW_MIN = 7.0, MW_MAX = 18.0, MW_STEP = 0.1;
const Q_MIN = 0, Q_MAX = 2000, Q_STEP = 10;
// Discretization (for fluid tracking)
const CELL_M = 25;
const N_DS = Math.ceil(TD_DEPTH / CELL_M);
const N_ABV = Math.ceil(BOP_DEPTH / CELL_M);
const N_BELOW = Math.ceil((TD_DEPTH - BOP_DEPTH) / CELL_M);
// Advection tuning (simple, frame-based)
const Q_REF = 500;
const BASE_M_PER_FRAME = CELL_M * 0.5;
// --- Rotation coupling tunables ---
const ROT_COUPLE = 3.0; // scales how strongly rotation adds to effective shear
const TAYLOR_BOOST = { Ta_c: 1200, C0: 0.18, Cn: 0.6 }; // stronger Taylor boost
// === Flow unit conversions (m³/s ↔ gpm) ===
const GPM_PER_M3S = 15850.323;   // 1 m³/s = 15850.323 gpm
const M3_PER_GPM  = 1 / GPM_PER_M3S;  // 1 gpm = 6.309e-5 m³/s


// ===== Auto-CML (anchored on ECD/pressure) tunables =====
const CML_DB_PSI = 20;            // pressure deadband around setpoint (psi)
const CML_PSI_SOFT = 50;         // psi range where gains taper toward zero
const CML_KP_GPM_PER_PSI = 1;   // proportional gain (gpm per psi)  <-- start conservative
const CML_KI_GPM_PER_PSI_S = 3;// integral gain (gpm per psi per s)
const CML_SLEW_GPM_PER_S = 80;   // max |ΔQ_CML| per second (slew limiter)
const CML_LPF_TAU_S = 60.0;        // low-pass filter on measured pressure (s)
// --- units: must be defined once, before any friction/pressure code ---
const PSI_PER_PASCAL = 1 / 6894.757;      // psi per Pa


// ============================================================================
// STABILIZATION PATCH - Add near top of file with other constants
// ============================================================================

// === Loss Zone Stabilization Constants ===
const LOSS_ACTIVATION_HYST_PSI = 10;    // Pressure must exceed Pfrac by this to START (reduced from 50)
const LOSS_DEACTIVATION_HYST_PSI = 5;   // Pressure must fall below Pfrac by this to STOP (reduced from 25)
const LOSS_MAX_ACCEL_GPM_S2 = 200;      // Max acceleration (gpm/s²) - prevents spikes
const LOSS_GLOBAL_RATE_LIMIT = 400;     // Max TOTAL loss change (gpm/s)

// === Level Change Rate Limits ===
const LEVEL_MAX_RISE_RATE_M_S = 5.0;    // Max level rise (m/s)
const LEVEL_MAX_DROP_RATE_M_S = 8.0;    // Max level drop (m/s)

// === Flow Out Stabilization ===
const FLOWOUT_DEADBAND_GPM = 10;        // Ignore tiny changes
const FLOWOUT_LPF_TAU = 1.5;            // Smooth over 1.5 seconds
const FLOWOUT_MAX_ACCEL = 300;          // Max dQ/dt change (gpm/s²)

// Add these state variables near other globals:
let FLOWOUT_VELOCITY_gpm_s = 0;  // dFO/dt
let cmlCtrl = { I_gpm: 0, P_lpf_psi: 0 };

// ========================================================================
// DIAGNOSTIC LOGGING SYSTEM
// ========================================================================
let diagnosticLog = {
  recording: false,
  data: [],
  startTime: 0,
  lastLogFrame: 0,
  LOG_INTERVAL: 30  // Log every 30 frames (1 second at 30fps, 0.5s at 60fps)
};
let logStartBtn, logStopBtn, logDownloadBtn;

// --- Safe, non-p5 helpers (no name collisions) ---
function clamp(val, min, max){ return Math.max(min, Math.min(max, val)); }
function remap(x, inMin, inMax, outMin, outMax, withinBounds=false){ if (inMax === inMin) return outMin; // avoid /0
  const t = (x - inMin) / (inMax - inMin);
  let y = outMin + t * (outMax - outMin);
  if (withinBounds){ const lo = Math.min(outMin, outMax); const hi = Math.max(outMin, outMax); y = Math.max(lo, Math.min(hi, y)); }
  return y;
}
// Graphics (some defaults; refined in setup)
let W = 2100, H = 980;
let well = { x: 140, y: 130, w: 160, h: 420 };
let dp = { w: 60 };
const GAUGE_SCALE = 0.70, R_BASE = 65;
const R = Math.round(R_BASE * GAUGE_SCALE);
// Reference marks to annotate
const MARKS = [ { d: BOP_DEPTH, name: "BOP" }, { d: SHOE_DEPTH, name: "Casing Shoe" }, { d: TD_DEPTH, name: "TD" } ];

// ========================================================================
// FORMATION FLUIDS (KICKS)
// ========================================================================
const FORMATION_FLUID_TYPES = {
  WATER: { name: 'Water', density_ppg: 8.33, density_kgm3: 997, viscosity_cp: 1.0, color: [200, 80, 60] },
  OIL: { name: 'Oil', density_ppg: 7.0, density_kgm3: 838, viscosity_cp: 5.0, color: [30, 70, 40] },
  GAS: { name: 'Gas', density_ppg: 0.7, density_kgm3: 84, viscosity_cp: 0.02, color: [0, 80, 90] },
  BLACKOIL: { name: 'Black Oil', density_ppg: 7.5, density_kgm3: 898, viscosity_cp: 10.0, bubblePoint_psi: 2000, color: [270, 60, 30] }
};

let formationFluidEnabled = false;
let formationFluidType = 'WATER';
let formationFluidDepth_m = 4500; // Depth where kick enters
let formationFluidRate_gpm = 0; // Influx rate
let formationFluidVolume_bbl = 0; // Total volume entered
let formationFluidFront_m = TD_DEPTH; // Current front position
let formationFluidMigrationModel = 'SHUTIN'; // 'SHUTIN', 'HARMATHY', 'MODIFIED_HARMATHY'

// Track formation fluid in cells (parallel to annulus grids)
let formationFluidCells_below = []; // Formation fluid fraction in each cell below BOP
let formationFluidCells_above = []; // Formation fluid fraction in each cell above BOP
let gasPhaseFrom_below = []; // For black oil dissociation tracking
let gasPhaseFrom_above = [];

// ============================ GLOBAL STATE =============================
let HYDRAULICS_MODEL = "Refined"; // "API" | "Refined"
let FRICTION_MODE = "hydraulics"; // keep hydraulics by default
let ACTIVE_RHEO_MODEL = "HB"; // "HB" | "PowerLaw" | "Bingham"
let fitParams = { mu_p_Pa_s: null, tau_y_Pa: null, K_PL_Pa_s_n: null, n_PL: null, K_HB_Pa_s_n: null, n_HB: null, tau_y_HB_Pa: null };
// Fluids / flows
let MW_DS = 9.5; // ppg, drillstring
let MW_BO = 10.0; // ppg, booster line
let Q_DS = 500; // gpm
let Q_BO = 100; // gpm
// Rotational speed (affects shear)
let RPM = 80;
// Generic friction fallback (when FRICTION_MODE === "generic")
let K_FAC = 0.00005;
// Level deficits (U-tube), meters from surface
let levelDeficit_m = 0; // DS
let levelDeficit_bo_m = 0; // Booster
// Rheology / gel
let gel_Pa = 5.0;
let use_gel = true;
// Geometry (inches → meters in setup)
let riser_ID_in = 21.0;
let casing_ID_in = 9.625;
let openhole_OD_in = 8.5;
let ds_OD_in = 5.0;
let ds_ID_in = 3.75;
let booster_ID_in = 4.5;
let riser_ID_m = 0, casing_ID_m = 0, openhole_ODm = 0, ds_OD_m = 0, ds_ID_m = 0, booster_ID_m = 0;
// Segmented tracking grids
let dsGrid = new Array(N_DS).fill(MW_DS); // downwards
let annBelowGrid = new Array(N_BELOW).fill(MW_DS); // upwards (BOP→TD)
let annAboveGrid = new Array(N_ABV).fill(MW_DS); // upwards (Surf→BOP)
let boosterGrid = new Array(N_ABV).fill(MW_BO); // downwards (Surf→BOP)
// fractional advection accumulators
let accDS = 0, accBelow = 0, accAbove = 0, accBo = 0;
// MPD / SBP
let MPD_ON = false;
let SBP_MODE = "manual"; // "manual" | "anchor"
let SBP_MANUAL = 0;
let CURRENT_SBP = 0;
let ANCHOR_DEPTH = 0;
let ANCHOR_ECD = 0;
// Time series
const TS_MAX = 600, TS_STRIDE = 5;

let GRAVITY_SWAP_ON = false;
const GRAVITY_SWAP_RATE = 0.02; // Cells per second (slow settling)
// UI refs (created in setup)
let apDepthInput, apEcdInput;
let cmlApDepthInput, cmlApEcdInput; // Separate CML anchor inputs
let dsMWSlider, dsMWInput, dsQSlider, dsQInput;
let boMWSlider, boMWInput, boQSlider, boQInput;
let kSlider, kInput;
let rpmSlider, rpmInput;
let sbpSlider, sbpInput;
let mpdBtn, sbpModeBtn, captureBtn, displayBtn, fricBtn, hydBtn;
let rheoPanel = {};
let frameWidth;
// Captured overlays
let capturedP = null;
let capturedECD = null;
let showCaptured = false;
// Advection coupling FIFOs (ensure arrival order)
let bitOutQ = []; // DS → TD (bit exit) → feeds annBelow bottom
let belowOutQ = []; // annBelow top → BOP → feeds annAbove
let boosterOutQ = []; // Booster bottom → BOP → feeds annAbove
// --- bottom frames (for Rheology/Gels/Geometry) ---
let frameY, frameHeight;
let rheoFrameX, rheoFrameW, gelFrameX, gelFrameW, geomFrameX, geomFrameW;
let cmlQSlider, cmlQInput, cmlDepthInput, cmlBtn, cmlAutoBtn;
let tsFrame = 0;
// Booster SPP smoothing (top-level)
let BoosterSPP_smooth = 0;
function updateBoosterSPP(target){
  BoosterSPP_smooth = BoosterSPP_smooth + SPP_ALPHA * (target - BoosterSPP_smooth);
  return BoosterSPP_smooth;
}
// Add this with your other global variable declarations
let tsData = {
  totalFlowIn: [],
  dsFlow: [],
  cmlFlow: [],
  spp: [],
  sbpSetpoint: [],
  sbpApplied: [],
  cmlAnchorSet: [],
  cmlAnchorActual: [],
  sbpAPSet: [],
  sbpAPActual: []
};
//let capturedP = null;
///let capturedECD = null;
//let showCaptured = false;
// Add near other globals (around line 50):
let TOPFILL_ON = false;
let Q_TOPFILL = 0; // gpm
let MW_TOPFILL = 9.5; // ppg


// === Time series for Flow Out & Choke Position ===
let tsFlowOut_gpm = [];      // newest at index 0
let tsChoke_pct   = [];      // newest at index 0


//let bitOutQ = [];
//let belowOutQ = [];
// Defaults for rheology inputs
let rheoDefaults = { fv: 72, T: 49, R600: 69.4, R300: 46.3, R200: 36.3, R100: 27.6, R6: 12.0, R3: 11.9, R1: 9.5, PV: 40, YP: 22, G10s: 18.5, G10m: 26.9, G30m: 27.2 };
let ehFrameX, ehFrameW, ehFrameY, ehFrameH;
// SPP smoothing
const SPP_ALPHA = 0.15; // 0–1 (higher = faster response)
let SPP_smooth = 0;
function updateSPP(targetSPP){
  SPP_smooth = SPP_smooth + SPP_ALPHA*(targetSPP - SPP_smooth);
  return SPP_smooth;
}

// Add near top with other globals (around line 50):
let frictionCache = {};
let frictionCacheFrame = -1;

// Replace frictionPsi_withCML_rheo with cached version:
// NOTE: frictionPsi_withCML_rheo() is defined later at line ~1477
// (removed duplicate definition here)

// --- Auto-CML control tunables (smooth tracking of inflow) ---
//const CML_LPF_TAU_S = 5.0;          // low-pass time constant on inflow (s)
//const CML_SLEW_GPM_PER_S = 150;     // max change rate for Q_CML (gpm/s)
const CML_TRIM_KI = 0.02;           // small I trim (gpm per (gpm·s))
//let cmlCtrl = { qInLP_m3s: 0, trim_gpm: 0 };

// -------- Enhanced Hydraulics (flags + sliders) --------
// in your lossZones init, add:
PI_gpm_per_psiN: 0  // optional direct PI (gpm / psi^n)

let EH_ON = true; // master section is visible
// Each feature has: ON/OFF + slider in [-1, +1] where 0 = nominal
let EH = {
  ECC: { on: false, s: 0.0 }, // Eccentric annulus effect
  ROUGH: { on: false, s: 0.0 }, // Roughness effect (turbulent primarily)
  KLOSS: { on: false, s: 0.0 }, // Local K-losses (bit, tools) into SPP/Booster SPP
  PCOR: { on: false, s: 1.0, fluid: "WBM" }, // P-only corrections (ρ & μ) with strength scalar
  GRAV:  { on: false } 
};
// --- Imbalance globals (small & smoothed) ---
let QIMB_DS2ANN_m3s = 0;   // DS → Annulus (m³/s)
let QIMB_BO2RIS_m3s = 0;   // Booster → Riser (m³/s)
const IMB_ALPHA = 0.25;    // smoothing 0..1
const IMB_DEADBAND_PSI = 0.5; // minimum ΔP to move

// UI refs
let ehPanel = {};
// Optional baselines you can tune
const EH_TUNE = {
  ecc_max_gain: 0.40, // up to ±40% dp change in tight annuli due to eccentricity
  rough_max_gain: 0.60, // up to ±60% on turbulent f (stronger at high Re)
  kloss_spp_base: 250, // psi baseline extra when s=+1 (and -250 psi at s=-1)
};
// --- P-only correction knobs ---
const PSI_TO_PA = 6894.757;
// Compressibility β (1/Pa) at surface pressure (simplified constant value)
function betaCompressibility(fluid) {
  if (fluid === "WBM") return 4.5e-10; // Water-based mud
  if (fluid === "OBM") return 1.0e-9; // Oil-based mud
  if (fluid === "Diesel") return 1.4e-9; // Diesel
  return 8e-10; // Default
}
// Pressure-viscosity coefficient α (1/Pa) (simplified constant)
function alphaPV(fluid) {
  if (fluid === "WBM") return 2e-10; // Negligible for WBM
  if (fluid === "OBM") return 1.0e-8; // Moderate for OBM
  if (fluid === "Diesel") return 1.4e-8; // Higher for Diesel
  return 1e-9; // Default
}
// Hydrostatic + SBP only (NO friction) → safe for P-only rheology scaling
function pressureForPCOR(d){
  const depth = Math.max(0, d);
  const ecd = ecdAtDepth(depth); // uses only the grids, no hydraulics
  const P_hyd = PSI_COEF * ecd * depth; // psi
  const P_sbp = (CURRENT_SBP || 0); // psi
  return P_hyd + P_sbp; // psi
}
// Apply pressure-only correction at a representative depth
function applyPressureOnly(d, rho0, K0, n0, tauY0) {
  if (!EH.PCOR.on) return { rho: rho0, K: K0, n: n0, tauY: tauY0 };
  // IMPORTANT: use friction-free pressure to avoid recursion
  const P_pa = Math.max(pressureForPCOR(d), 0) * PSI_TO_PA;
  const beta = betaCompressibility(EH.PCOR.fluid) * EH.PCOR.s; // density vs P
  const alpha = alphaPV(EH.PCOR.fluid) * EH.PCOR.s; // viscosity vs P
  const deltaP = P_pa - 101325; // vs surface (Pa)
  const rhoP = rho0 * Math.exp(beta * deltaP); // corrected density
  const KP = Math.max(K0,1e-9) * Math.exp(alpha * deltaP); // corrected K
  return { rho: rhoP, K: KP, n: n0, tauY: tauY0 };
}
// ======== CML (Controlled Mud Level) ========
let CML_ON = false; // master toggle
let CML_DEPTH = 0; // m (0..BOP_DEPTH)
let Q_CML = 0; // gpm (manual command)
let AUTO_CML_ON = false; // anchor controller
let CML_AP_DEPTH = 0; // m (anchor depth for AUTO-CML)
let CML_AP_ECD = 0; // ppg (anchor ECD for AUTO-CML)
let CML_Q_MAX = 0; // dynamic: max allowed (DS+Booster)
// riser top exposed to atmosphere due to CML pump (depth from surface)
let CML_TOP_DEPTH = 0; // m (0 = riser full)
// CML pipe (visual-only) fluid tracking (upwards to surface)
let cmlPipeGrid = new Array(N_ABV).fill(MW_DS);
let accCML = 0; // advection accumulator for CML pipe
// ============================== UTILITIES ==============================

// ===== Loss-driven free surface (independent of CML) =====
let LOSS_TOP_DEPTH_m = 0;

// ===== Section tops =====
let levelRiserTop_m   = 0;
let levelBoosterTop_m = 0;
let levelDSTop_m      = 0;
let levelCMLTop_m     = 0;

// ===== Flow-Out (surface returns) =====
let FLOW_OUT_gpm = 0;
let FLOW_OUT_smooth = 0;
const FLOW_OUT_ALPHA = 0.20;

// ===== Loss zones (up to 3) =====
let LOSSES_ON = false;
const MAX_LOSS_ZONES = 3;
let lossZones = Array.from({length: MAX_LOSS_ZONES}, () => ({
  enabled: false,
  depth_m: 0,
  fracPressure_psi: 0,
  Qref_gpm: 0,
  DPref_psi: 0,
  n: 1.0,
  CL: 0,
  Qloss_gpm: 0,
  section: '',
  cellIdx: -1
}));

// ===== Choke (equal-percentage Cv) =====
let CHOKE_POS_pct = 0;
let CHOKE_CV_MAX = 50;
let CHOKE_K = 4.0;

// ===== Compressibility (distributed) =====
let prevPavg_psi = 0;

// ===================== LOSSES UI + DIAGNOSTICS (UI refs) =====================
let uiLosses = {
  root: null, title: null, toggleBtn: null,
  rows: [
    { depth:null, fracP:null, qref:null, dpref:null, n:null },
    { depth:null, fracP:null, qref:null, dpref:null, n:null },
    { depth:null, fracP:null, qref:null, dpref:null, n:null },
  ],
  help: null
};
let uiDiag = { root:null, text:null };



// ---- Global free-surface for the WHOLE annulus (can sink below BOP) ----
// 0 = full to surface; up to TD_DEPTH when totally drained.
let ANN_TOP_DEPTH_m = 0; // master top of wet annulus (riser + below BOP)

// Clamp + expose a single function to get it
function annulusTopDepthGlobal(){
  return Math.max(0, Math.min(ANN_TOP_DEPTH_m, TD_DEPTH));
}

// Section area at a given depth (annulus)
function annulusAreaAtDepth(d){
  if (d < BOP_DEPTH) return area_annulus(riser_ID_m,  ds_OD_m);          // riser annulus
  if (d < SHOE_DEPTH) return area_annulus(casing_ID_m, ds_OD_m);         // casing annulus
  return area_annulus(openhole_ODm, ds_OD_m);                             // open hole annulus
}



// Helper to place Losses UI under Rheology pane (fallback to bottom-left)
function lossesUIPosition() {
  const x = (typeof rheoFrameX!=='undefined') ? rheoFrameX : 40;
  const yBase = (typeof rheoFrameY!=='undefined' && typeof rheoFrameH!=='undefined')
                  ? (rheoFrameY + rheoFrameH + 16) : (height - 200);
  const y = Math.min(height - 180, Math.max(20, yBase));
  return { x, y };
}


function deadband(x, db){ return (Math.abs(x) <= db) ? 0 : (x > 0 ? x - db : x + db); }

// --- global, re-usable helpers (moved out of setup) ---
function smoothDeadbandPsi(dp_psi, db = IMB_DEADBAND_PSI){
  // tanh soft-threshold so small |ΔP| produce ~0 flow
  const s = Math.tanh(Math.abs(dp_psi)/Math.max(db,1e-6));
  return Math.sign(dp_psi) * Math.max(0, Math.abs(dp_psi) - db) * s;
}


function num(v){ if (v==null) return 0; const s=String(v).trim().replace(',','.'); const x=parseFloat(s); return isFinite(x)?x:0; }
function average(arr){ if (!arr.length) return 0; return arr.reduce((a,b)=>a+b,0)/arr.length; }
function sumCells(arr,i0,i1){ if (i1<i0) return 0; i0=Math.max(0,i0); i1=Math.min(arr.length-1,i1); let s=0; for(let i=i0;i<=i1;i++) s+=arr[i]; return s; }
function area_circ(D){ return Math.PI * (D*D) / 4; }
function area_annulus(Do, Di){ return Math.max(Math.PI * (Do*Do - Di*Di) / 4, 1e-12); }
function Dh_annulus(Do, Di){ return Math.max(Do - Di, 1e-6); }
function smooth01(x){ return 1/(1+Math.exp(-8*(x-0.5))); }
function mapDepthToY(d){ return remap(d, 0, MAX_DEPTH, well.y, well.y + well.h); }

// Riser free-surface depth: max(CML-driven top, Loss-driven top), capped at BOP

function riserTopDepth(){
  // Riser visual top is the global top capped at BOP
  levelRiserTop_m = Math.min(annulusTopDepthGlobal(), BOP_DEPTH);
  return levelRiserTop_m;
}


// -------- Wet lengths for compliance (only wet sections contribute) --------
function wetLength_riser_m() {
  const top = Math.min(riserTopDepth(), BOP_DEPTH);
  return Math.max(0, BOP_DEPTH - top);
}
function wetLength_booster_m() {
  return Math.max(0, BOP_DEPTH - Math.min(levelBoosterTop_m, BOP_DEPTH));
}
function wetLength_DS_m() {
  return Math.max(0, TD_DEPTH - Math.min(levelDSTop_m, TD_DEPTH));
}
function wetLength_casing_m(){
  const topBelow = Math.max(BOP_DEPTH, annulusTopDepthGlobal());
  return Math.max(0, SHOE_DEPTH - topBelow);
}
function wetLength_openhole_m(){
  const topOH = Math.max(SHOE_DEPTH, annulusTopDepthGlobal());
  return Math.max(0, TD_DEPTH - topOH);
}


const A_riserAnn = () => area_annulus(riser_ID_m,  ds_OD_m);
const A_casingAnn= () => area_annulus(casing_ID_m, ds_OD_m);
const A_openAnn  = () => area_annulus(openhole_ODm,ds_OD_m);
const A_DS       = () => Math.PI * ds_ID_m * ds_ID_m / 4;
const A_booster  = () => Math.PI * booster_ID_m * booster_ID_m / 4;

function betaFluid(fl) {
  if (fl === 'OBM')   return 3.5e-10;   // 1/Pa
  if (fl === 'Diesel')return 8.0e-10;
  return 5.0e-10; // WBM default
}
const FLUID_TAG = () => (EH && EH.PCOR && EH.PCOR.fluid) ? EH.PCOR.fluid : 'WBM';

function systemWetVolumes_m3() {
  return {
    Vriser:   A_riserAnn() * wetLength_riser_m(),
    Vcasing:  A_casingAnn()* wetLength_casing_m(),
    Vopen:    A_openAnn()  * wetLength_openhole_m(),
    Vds:      A_DS()       * wetLength_DS_m(),
    Vbooster: A_booster()  * wetLength_booster_m(),
  };
}
function systemCompliance_m3_per_Pa() {
  const fl = FLUID_TAG();
  const {Vriser,Vcasing,Vopen,Vds,Vbooster} = systemWetVolumes_m3();
  return betaFluid(fl)*Vriser + betaFluid(fl)*Vcasing + betaFluid(fl)*Vopen
       + betaFluid(fl)*Vds   + betaFluid(fl)*Vbooster;
}
function averageSystemPressure_psi() {
  const P0 = (CURRENT_SBP || 0);
  const P1 = pressureAtDepth(BOP_DEPTH);
  const P2 = pressureAtDepth(SHOE_DEPTH);
  const P3 = pressureAtDepth(TD_DEPTH);
  return (P0+P1+P2+P3)/4;
}
function compressionEquivalentFlow_gpm(dt_s) {
  if (dt_s <= 0) return 0;
  const C_m3_per_Pa = systemCompliance_m3_per_Pa();
  const Pavg_now = averageSystemPressure_psi();
  const dP_psi = Pavg_now - prevPavg_psi; prevPavg_psi = Pavg_now;
  if (Math.abs(dP_psi) < 0.05) return 0;

  const q_m3s = C_m3_per_Pa * ((dP_psi * 6894.757)/dt_s);
  const q_gpm = q_m3s * 15850.323;
  return 0.20 * q_gpm; // gentle under-relaxation
}

// --------------------- Loss zones: mapping & calibration ---------------------
function mapLossZonesToGrid(){
  for (const z of lossZones){
    if (!z.enabled || z.depth_m <= 0){ z.cellIdx=-1; z.section=''; z.CL=0; continue; }
    if (z.depth_m <= BOP_DEPTH){ z.section='riser';    z.cellIdx=Math.floor(z.depth_m / CELL_M); }
    else if (z.depth_m <= SHOE_DEPTH){ z.section='casing'; z.cellIdx=Math.floor((z.depth_m - BOP_DEPTH)/CELL_M); }
    else { z.section='openhole'; z.cellIdx=Math.floor((z.depth_m - SHOE_DEPTH)/CELL_M); }

        const n = (z.n || 1.0);
    // Prefer direct PI if provided (units gpm/psi^n)
    if (z.PI_gpm_per_psiN && z.PI_gpm_per_psiN > 0) {
      z.CL = z.PI_gpm_per_psiN;
    } else if (z.Qref_gpm > 0 && z.DPref_psi > 0) {
      // Backward compatible path: C_L = Qref / (ΔPref)^n
      z.CL = z.Qref_gpm / Math.pow(z.DPref_psi, n);
    } else {
      z.CL = 0;
    }
//Why your Qref/DPref isn't working:
// Your current setup: Qref=2200 gpm, DPref=100 psi means the zone takes 2200 gpm at only 100 psi over fracture

  }
}

/* ===================== LOSS-ZONE MARKERS (helpers) ===================== */
// Depth-aligned markers for the Pressure (psi) panel
function drawLossMarkersOnPressure(px, py, w, h, padL, padR, padT, padB, xMinPsi, xMaxPsi, col) {
  if (!LOSSES_ON || !Array.isArray(lossZones)) return;

  push();
  // Choose your color: white (HSB) => color(0,0,100); yellow (HSB) => color(60,100,100)
  stroke(col || color(0, 0, 100));
  strokeWeight(1.5);
  fill(255, 220);
  textSize(10);
  textAlign(LEFT, CENTER);

  const innerL = px + padL, innerR = px + w - padR;
  const innerT = py + padT, innerB = py + h - padB;
  const yFromDepth = (d) => map(d, 0, TD_DEPTH, innerT, innerB);

  for (const z of lossZones) {
    if (!z || !z.enabled || !(z.depth_m > 0)) continue;
    const y = yFromDepth(z.depth_m);
    // depth line
    line(innerL, y, innerR, y);
    // label
    noStroke();
    fill(255);
    const q = isFinite(z.Qloss_gpm) ? nf(z.Qloss_gpm, 1, 0) : '0';
    text(`Loss @ ${nf(z.depth_m,1,0)} m  (≈${q} gpm)`, innerL + 6, y - 10);
  }
  pop();
}

// Depth-aligned markers for the ECD (ppg) panel (we still draw horizontal depth lines)
function drawLossMarkersOnECD(px, py, w, h, padL, padR, padT, padB, xMinPpg, xMaxPpg, col) {
  if (!LOSSES_ON || !Array.isArray(lossZones)) return;

  push();
  // Choose your color: e.g., yellow in HSB
  stroke(col || color(60, 100, 100));
  strokeWeight(1.5);
  fill(255, 220);
  textSize(10);
  textAlign(LEFT, CENTER);

  const innerL = px + padL, innerR = px + w - padR;
  const innerT = py + padT, innerB = py + h - padB;
  const yFromDepth = (d) => map(d, 0, TD_DEPTH, innerT, innerB);

  for (const z of lossZones) {
    if (!z || !z.enabled || !(z.depth_m > 0)) continue;
    const y = yFromDepth(z.depth_m);
    line(innerL, y, innerR, y);
    noStroke();
    fill(255);
    text(`Loss @ ${nf(z.depth_m,1,0)} m`, innerL + 6, y - 10);
  }
  pop();
}
/* =================== END LOSS-ZONE MARKERS (helpers) =================== */

// =========================== HYDRAULICS CORE ===========================
// Rotation shear rates
function rotShearRateAnnulus(rpm, Di, Do){
  if (rpm <= 0) return 0;
  const omega = TWO_PI * rpm / 60;
  const Ri = Math.max(Di,1e-6) / 2;
  const gap = Math.max(Do - Di, 1e-6);
  return (omega * Ri) / gap; // s^-1
}
function rotShearRatePipe(rpm, ID){
  if (rpm <= 0) return 0;
  // near-wall added shear ~ O(ω)
  return TWO_PI * rpm / 60;
}
// Taylor-number helpers (physics-based rotation boost)
function taylorNumber(rpm, Di, Do, nu){
  const omega = TWO_PI * Math.max(rpm,0) / 60;
  const Ri = Math.max(Di,1e-6) / 2;
  const gap = Math.max(Do - Di, 1e-6);
  return (omega * Ri * gap) / Math.max(nu, 1e-12);
}
function applyTaylorBoost(base, rpm, Di, Do, mu_app, rho, n){
  const nu = Math.max(mu_app,1e-9)/Math.max(rho,1e-9);
  const omega = TWO_PI * Math.max(rpm,0) / 60;
  const Ri = Math.max(Di,1e-6) / 2;
  const gap = Math.max(Do - Di, 1e-6);
  const Ta = (omega * Ri * gap) / Math.max(nu, 1e-12);
  const { Ta_c, C0, Cn } = TAYLOR_BOOST;
  if (Ta <= Ta_c) return base;
  // stronger boost; increased sensitivity for shear-thinning (n<1)
  const C = C0 * (1 + Cn * Math.max(0, 1 - (n ?? 1)));
  return base * (1 + C * Math.sqrt(Ta/Ta_c));
}
// HB laminar formulas (slot annulus + pipe)
function mu_app_HB(gdot, K, n, tauY){
  gdot = Math.max(gdot, 1e-6);
  return tauY/gdot + K*Math.pow(gdot, n-1);
}
// Annulus laminar as slot (captures yield offset)
function dpPerM_annulusLaminar_HB(Q, rho, Do, Di, K, n, tauY, rpm){
  const A = area_annulus(Do, Di);
  const b = Math.max((Do - Di)/2, 1e-6); // half-gap
  const V = Q / Math.max(A,1e-12);
  // axial + rotational shear blended in quadrature (stronger coupling)
  const g_ax = 6 * Math.abs(V) / b;
  const g_rot = rotShearRateAnnulus(rpm, Di, Do);
  const g_eff = Math.sqrt(g_ax*g_ax + (ROT_COUPLE*g_rot)*(ROT_COUPLE*g_rot));
  const g_w = ((2*n+1)/(3*n)) * Math.max(g_eff,1e-6);
  const tau_w = tauY + K*Math.pow(g_w,n);
  let dpdl = 2*tau_w / b; // Pa/m
  const muApp = mu_app_HB(g_w, K, n, tauY);
  dpdl = applyTaylorBoost(dpdl, rpm, Di, Do, muApp, rho, n);
  dpdl *= eccMultiplier(Do, Di);
  return dpdl;
}
// Pipe laminar HB (Rabinowitsch)
function dpPerM_pipeLaminar_HB(Q, rho, ID, K, n, tauY, rpm){
  const A = Math.PI*Math.max(ID*ID,1e-12)/4;
  const V = Q / A;
  const Dh = Math.max(ID,1e-6);
  const g_ax = 8 * Math.abs(V) / Dh;
  const g_rot = rotShearRatePipe(rpm, ID);
  const g_eff = Math.sqrt(g_ax*g_ax + (ROT_COUPLE*g_rot)*(ROT_COUPLE*g_rot));
  const g_w = ((3*n+1)/(4*n)) * Math.max(g_eff,1e-6);
  const tau_w = tauY + K*Math.pow(g_w,n);
  return (4*tau_w) / Dh; // Pa/m
}
// Baseline friction models
function dpPerM_API_withRot(rho, V, Dh, K, n, tauY, gdotExtra){
  const gdot = Math.max(8*V/Math.max(Dh,1e-6) + (gdotExtra||0), 1e-6);
  const muApp = tauY/gdot + K*Math.pow(gdot, n-1);
  const Re = (rho * V * Dh) / Math.max(muApp, 1e-9);
  const f = (Re < 2100) ? 16/Math.max(Re,1e-6) : 0.079/Math.pow(Math.max(Re,1e-6),0.25);
  let dp = f * (rho*V*V/2) / Math.max(Dh,1e-6);

  // ✅ FIX: Add yield stress contribution for turbulent flow
  // For Herschel-Bulkley fluids, yield stress contributes to wall shear even in turbulent regime
  // Add direct yield stress term: dp_yield = 2*tau_y / (Dh/2) for annulus geometry
  if (Re >= 2100 && tauY > 0) {
    const dp_yield = (4 * tauY) / Math.max(Dh, 1e-6);  // Yield stress pressure drop
    dp += dp_yield;  // Add to turbulent friction
  }

  return dp;
}
function dpPerM_Refined_withRot(rho, V, Dh, K, n, tauY, gdotExtra){
  // Blended laminar/turbulent with mild non-Newtonian adjustments
  const gdot = Math.max(8*V/Math.max(Dh,1e-6) + (gdotExtra||0), 1e-6);
  const muApp = tauY/gdot + K*Math.pow(gdot, n-1);
  const Re = (rho * V * Dh) / Math.max(muApp, 1e-9);
  const fLam = (16/Math.max(Re,1e-6))*(1 + Math.min(0.25, tauY/(K*1e-3 + 1e-6)));
  const alpha = 0.0665 + 0.0175*n, beta = 0.365 - 0.0620*n;
  const fTur = alpha/Math.pow(Math.max(Re,1e-6), beta);
  const blend = 1/(1+Math.exp(-(Re-2500)/400));
  let f = (1-blend)*fLam + blend*fTur;
  f *= (1 - 0.05*Math.max(0,1-n)); // slight shear-thinning easing
  let dp = f * (rho*V*V/2) / Math.max(Dh,1e-6);

  // ✅ FIX: Add yield stress contribution for turbulent flow
  // For Herschel-Bulkley fluids, yield stress contributes to wall shear even in turbulent regime
  // Blend this contribution based on how turbulent we are (same blend as friction factor)
  const dp_before = dp;  // Store before adding yield boost
  let dp_yield = 0;
  if (tauY > 0) {
    dp_yield = (4 * tauY) / Math.max(Dh, 1e-6);  // Yield stress pressure drop
    dp += blend * dp_yield;  // Add proportionally to turbulent fraction
  }
  const dp_after = dp;  // Store after adding yield boost

  // Debug: Store yield stress boost for logging (attach to window for access)
  if (typeof window !== 'undefined') {
    window.__lastYieldBoost = {
      tauY, dp_yield, blend, boost: blend * dp_yield, Dh, Re,
      dp_before, dp_after, actual_boost: dp_after - dp_before
    };
  }

  return dp;
}
// Yield thresholds to avoid crazy low-flow spikes
function dpMin_pipe_per_m(tauY, Dh){ return 4*Math.max(tauY, use_gel ? gel_Pa : 0)/Math.max(Dh,1e-6); }
function dpMin_ann_per_m(tauY, Do, Di){ return 2*Math.max(tauY, use_gel ? gel_Pa : 0)/Math.max(Do-Di,1e-6); }
// Unified section pressure gradient
function dP_per_m_annulus_withRPM(Q, rho, Do, Di, K, n, tauY, rpm){
  if (Q <= 0) return 0;
  const A = area_annulus(Do, Di);
  const Dh = Math.max(Do - Di, 1e-6);
  const V = Q / Math.max(A,1e-12);
  const b = Dh/2;
  const g_ax = 6 * Math.abs(V) / Math.max(b,1e-6);
  const g_rot = rotShearRateAnnulus(rpm, Di, Do);
  const g_eff = Math.sqrt(g_ax*g_ax + (ROT_COUPLE*g_rot)*(ROT_COUPLE*g_rot));
  const g_w = ((2*n+1)/(3*n)) * Math.max(g_eff,1e-6);
  const muAw = mu_app_HB(g_w, K, n, tauY);
  const Re_g = (rho * Math.max(Math.abs(V),1e-12) * Dh) / Math.max(muAw,1e-9);

  // ✅ SMOOTH TRANSITION: Blend laminar and turbulent between Re=2000-4000
  // Wider zone for non-Newtonian fluids + monotonicity enforcement
  const RE_LAM = 2000;   // Fully laminar below this
  const RE_TURB = 4000;  // Fully turbulent above this (widened from 2300)

  // No-op function for production (debug removed)
  const logFlowRegime = (regime, Re_g, dp_lam, dp_turb, dp_result, blend_pct, rough, ecc, dp_base) => {};

  if (Re_g < RE_LAM){
    // Fully laminar
    const dp_lam = dpPerM_annulusLaminar_HB(Q, rho, Do, Di, K, n, tauY, rpm);
    logFlowRegime('LAMINAR', Re_g, dp_lam, null, dp_lam, null, null, null, null);
    return dp_lam;
  } else if (Re_g > RE_TURB){
    // Fully turbulent
    const dp_base = (HYDRAULICS_MODEL==="API")
      ? dpPerM_API_withRot(rho, V, Dh, K, n, tauY, g_rot)
      : dpPerM_Refined_withRot(rho, V, Dh, K, n, tauY, g_rot);
    let dp_turb = applyTaylorBoost(dp_base, rpm, Di, Do, muAw, rho, n);
    const rough = roughMultiplier(true);
    const ecc = eccMultiplier(Do, Di);
    dp_turb *= rough;
    dp_turb *= ecc;
    logFlowRegime('TURBULENT', Re_g, null, dp_turb, dp_turb, 100, rough, ecc, dp_base);
    return dp_turb;
  } else {
    // TRANSITION ZONE: Blend between laminar and turbulent
    const dp_lam = dpPerM_annulusLaminar_HB(Q, rho, Do, Di, K, n, tauY, rpm);
    const dp_base = (HYDRAULICS_MODEL==="API")
      ? dpPerM_API_withRot(rho, V, Dh, K, n, tauY, g_rot)
      : dpPerM_Refined_withRot(rho, V, Dh, K, n, tauY, g_rot);
    let dp_turb = applyTaylorBoost(dp_base, rpm, Di, Do, muAw, rho, n);
    const rough = roughMultiplier(true);
    const ecc = eccMultiplier(Do, Di);
    dp_turb *= rough;
    dp_turb *= ecc;

    // ✅ MONOTONICITY FIX: Turbulent must never be less than laminar
    // This ensures friction increases monotonically with flow rate
    const dp_turb_corrected = Math.max(dp_turb, dp_lam);

    // Smooth cubic blend: f(Re) = 3t² - 2t³ where t = (Re - RE_LAM)/(RE_TURB - RE_LAM)
    const t = (Re_g - RE_LAM) / (RE_TURB - RE_LAM);
    const blend = t * t * (3 - 2 * t);  // Smoothstep function
    let result = dp_lam * (1 - blend) + dp_turb_corrected * blend;

    // ✅ FINAL SAFETY: Result must NEVER be less than laminar
    // This GUARANTEES monotonicity because laminar dp increases with Q
    result = Math.max(result, dp_lam);

    logFlowRegime('TRANSITION', Re_g, dp_lam, dp_turb_corrected, result, blend*100, rough, ecc, dp_base);

    return result;
  }
}
function dP_per_m_pipe_withRPM(Q, rho, ID, K, n, tauY, rpm){
  if (Q <= 0) return 0;
  const A = Math.PI*Math.max(ID*ID,1e-12)/4;
  const V = Q / A;
  const Dh = Math.max(ID,1e-6);
  const g_ax = 8 * Math.abs(V) / Dh;
  const g_rot = rotShearRatePipe(rpm, ID);
  const g_eff = Math.sqrt(g_ax*g_ax + (ROT_COUPLE*g_rot)*(ROT_COUPLE*g_rot));
  const g_w = ((3*n+1)/(4*n)) * Math.max(g_eff,1e-6);
  const muAw = mu_app_HB(g_w, K, n, tauY);
  const Re_g = (rho * Math.max(Math.abs(V),1e-12) * Dh) / Math.max(muAw,1e-9);

  // ✅ SMOOTH TRANSITION: Blend laminar and turbulent between Re=2000-4000
  // Wider zone for non-Newtonian fluids + monotonicity enforcement
  const RE_LAM = 2000;
  const RE_TURB = 4000;  // Widened from 2300

  if (Re_g < RE_LAM){
    return dpPerM_pipeLaminar_HB(Q, rho, ID, K, n, tauY, rpm);
  } else if (Re_g > RE_TURB){
    let dp_turb = (HYDRAULICS_MODEL==="API")
      ? dpPerM_API_withRot(rho, V, Dh, K, n, tauY, g_rot)
      : dpPerM_Refined_withRot(rho, V, Dh, K, n, tauY, g_rot);
    dp_turb *= roughMultiplier(true);
    return dp_turb;
  } else {
    // TRANSITION ZONE: Smooth blend
    const dp_lam = dpPerM_pipeLaminar_HB(Q, rho, ID, K, n, tauY, rpm);
    let dp_turb = (HYDRAULICS_MODEL==="API")
      ? dpPerM_API_withRot(rho, V, Dh, K, n, tauY, g_rot)
      : dpPerM_Refined_withRot(rho, V, Dh, K, n, tauY, g_rot);
    dp_turb *= roughMultiplier(true);

    const t = (Re_g - RE_LAM) / (RE_TURB - RE_LAM);
    const blend = t * t * (3 - 2 * t);
    let result = dp_lam * (1 - blend) + dp_turb * blend;

    // ✅ PHYSICS ENFORCEMENT: Ensure monotonicity
    const dp_min = dp_lam * 0.8;
    if (result < dp_min) result = dp_min;

    return result;
  }
}
function eccMultiplier(Do, Di){
  // baseline: no change
  if (!EH.ECC.on) return 1.0;
  // sensitivity: tighter annulus → stronger effect
  const gap = Math.max(Do - Di, 1e-6);
  const tight = clamp((0.25 - gap)/0.25, 0, 1); // strong when gap <~ 0.25 m
  // map slider s∈[-1,1] to gain 1 ± (gain_max * tight)
  const gmax = EH_TUNE.ecc_max_gain * tight;
  return 1 + EH.ECC.s * gmax;
}
function roughMultiplier(isTurb){
  if (!isTurb || !EH.ROUGH.on) return 1.0;
  // slider s∈[-1,1] → 1 ± rough_max_gain
  return 1 + EH.ROUGH.s * EH_TUNE.rough_max_gain;
}
function localKLossPsi(){
  if (!EH.KLOSS.on) return 0;
  // slider s∈[-1,1] maps to ± kloss_spp_base psi
  return EH_TUNE.kloss_spp_base * EH.KLOSS.s;
}
// reference velocity at Q_REF in the riser annulus
function A_riser() { return area_annulus(riser_ID_m, ds_OD_m); }
const V_REF = () => (Q_REF/15850.323) / Math.max(A_riser(), 1e-12);
// Time acceleration for visualization
const TIME_ACCEL = 3.0; // Speed up simulation for better visibility
const CML_TIME_ACCEL = 5.0; // Additional boost for CML level changes
// ========================== SEGMENTED ADVECTION ==========================

// Add this NEW function before stepAdvection():
// Modify computeFlowProfile() - change the reversal condition:
// Replace your entire computeFlowProfile() function with this:
function computeFlowProfile() {
  // Returns flow rates (m³/s) at each section, accounting for losses
  // Positive = upward, Negative = downward
  
  const qDS_in = (Q_DS || 0) / 15850.323;
  const qBO_in = (Q_BO || 0) / 15850.323;
  const qCML = (effective_Q_CML_gpm() || 0) / 15850.323;
  const qTF = (TOPFILL_ON && Q_TOPFILL > 0) ? (Q_TOPFILL / 15850.323) : 0;
  
  // ✅ DEFINE activeLosses here
  const activeLosses = (lossZones || [])
    .filter(z => z && z.enabled && z.depth_m > 0 && z.Qloss_gpm > 0)
    .map(z => ({depth: z.depth_m, q_m3s: z.Qloss_gpm / 15850.323}))
    .sort((a,b) => b.depth - a.depth); // Deepest first
  
  // Build flow profile
  let profile = {
    ds: qDS_in,
    openhole: 0,
    casing: 0,
    riser: 0,
    booster: 0,
    boosterDirection: 'down',
    topfill: qTF,
    topfillDirection: 'down'
  };
  
  // Calculate annulus flow going UP from bit (subtracting losses)
  let qAnn = qDS_in;
  
  for (const loss of activeLosses) {
    qAnn = Math.max(0, qAnn - loss.q_m3s);
    if (loss.depth > SHOE_DEPTH) {
      profile.openhole = qAnn;
    } else if (loss.depth > BOP_DEPTH) {
      profile.casing = qAnn;
    } else {
      profile.riser = qAnn;
    }
  }
  
  // Fill in sections without explicit losses
  if (!activeLosses.some(l => l.depth > SHOE_DEPTH)) {
    profile.openhole = qAnn;
  }
  if (!activeLosses.some(l => l.depth > BOP_DEPTH && l.depth <= SHOE_DEPTH)) {
    profile.casing = profile.openhole;
  }
  
  // Determine booster direction
  const annulusTop = annulusTopDepthGlobal();
  const riserNotFull = annulusTop > 0.5; // Any headspace = booster can't go up
  
  if (riserNotFull) {
    // ✅ Booster has nowhere to go UP → flows DOWN
    profile.booster = qBO_in;
    profile.boosterDirection = 'down';
    profile.riser = -qTF; // Only Top Fill (negative = flowing down)
    
    // ✅ Below BOP gets DS + Booster + TopFill flowing DOWN from fluid level
    const qBelowTotal = qDS_in + qBO_in + qTF;
    
    // Subtract losses below the current fluid level
    let qRemaining = qBelowTotal;
    for (const loss of activeLosses.filter(l => l.depth >= annulusTop)) {
      qRemaining = Math.max(0, qRemaining - loss.q_m3s);
    }
    
    profile.casing = qRemaining;
    profile.openhole = qRemaining;
    
  } else {
    // Normal: Riser full, booster flows UP
    profile.booster = qBO_in;
    profile.boosterDirection = 'up';
    
    profile.riser = profile.casing + qBO_in - qCML - qTF;
    
    // Subtract riser losses
    for (const loss of activeLosses.filter(l => l.depth <= BOP_DEPTH)) {
      profile.riser = Math.max(0, profile.riser - loss.q_m3s);
    }
  }
  
  return profile;
}


// NEW FUNCTION: Calculate flow rate at any depth accounting for losses
function flowRateAtDepth(depth_m, baseFlow_m3s) {
  // Start with base flow and subtract all losses BELOW this depth
  let qRemaining = baseFlow_m3s;
  
  if (LOSSES_ON && lossZones) {
    for (const z of lossZones) {
      if (z && z.enabled && z.depth_m > depth_m && z.Qloss_gpm > 0) {
        const qLoss = z.Qloss_gpm / 15850.323;
        qRemaining = Math.max(0, qRemaining - qLoss);
      }
    }
  }
  
  return qRemaining;
}
// === Loss demand (sum of all zone demands; do NOT cap by flow) ===
function totalLossDemand_m3s(){
  if (!LOSSES_ON || !Array.isArray(lossZones)) return 0;
  let sum_gpm = 0;
  for (const z of lossZones){
    if (!z || !z.enabled) continue;
    sum_gpm += Math.max(0, z.Qdem_filt_gpm || 0);
  }
  // (optional global cap you may have added…)
  return sum_gpm / 15850.323;
}


// === Cross-sectional area at the current free surface (riser/casing/openhole) ===
function annulusAreaAtTop() {
  const top = annulusTopDepthGlobal();
  if (top < BOP_DEPTH)    return area_annulus(riser_ID_m,  ds_OD_m);
  if (top < SHOE_DEPTH)   return area_annulus(casing_ID_m, ds_OD_m);
  return                      area_annulus(openhole_ODm,   ds_OD_m);
}

// NEW HELPER: Find where fluid exits (loss zone or surface)
function findFluidExitPoint(startDepth_m, flowRate_m3s, flowDirection) {
  // Returns: {depth: exit_depth_m, reason: 'loss'|'surface'|'static'}
  
  if (!LOSSES_ON || !lossZones || flowRate_m3s < 1e-6) {
    return flowDirection === 'up' 
      ? {depth: 0, reason: 'surface'}
      : {depth: TD_DEPTH, reason: 'static'};
  }
  
  let qRemaining = Math.abs(flowRate_m3s);
  const sortedLosses = lossZones
    .filter(z => z && z.enabled && z.depth_m > 0 && z.Qloss_gpm > 0)
    .sort((a, b) => flowDirection === 'up' ? (a.depth_m - b.depth_m) : (b.depth_m - a.depth_m));
  
  for (const z of sortedLosses) {
    // Check if this loss is in the flow path
    const inPath = flowDirection === 'up' 
      ? (z.depth_m > startDepth_m)
      : (z.depth_m < startDepth_m);
    
    if (inPath) {
      const qLoss = z.Qloss_gpm / 15850.323;
      qRemaining -= qLoss;
      if (qRemaining <= 1e-6) {
        return {depth: z.depth_m, reason: 'loss'};
      }
    }
  }
  
  // Flow reaches the end
  return flowDirection === 'up'
    ? {depth: 0, reason: 'surface'}
    : {depth: TD_DEPTH, reason: 'static'};
}

// ========================================================================
// FORMATION FLUID PHYSICS
// ========================================================================

function initializeFormationFluidCells() {
  // Initialize arrays to track formation fluid in each cell
  formationFluidCells_below = new Array(N_BELOW).fill(0);
  formationFluidCells_above = new Array(N_ABV).fill(0);
  gasPhaseFrom_below = new Array(N_BELOW).fill(0);
  gasPhaseFrom_above = new Array(N_ABV).fill(0);
}

function calculateMigrationVelocity_m_s(fluidType, pressure_psi, mudWeight_ppg) {
  // Migration velocity calculations based on literature
  const fluidProps = FORMATION_FLUID_TYPES[fluidType];
  if (!fluidProps) return 0;

  const rho_mud_kgm3 = mudWeight_ppg * PPG_TO_KGM3;
  const rho_fluid_kgm3 = fluidProps.density_kgm3;
  const drho = rho_mud_kgm3 - rho_fluid_kgm3; // Density difference

  if (drho <= 0) return 0; // Fluid heavier than mud, doesn't migrate

  const g = 9.81; // m/s²

  switch (formationFluidMigrationModel) {
    case 'SHUTIN':
      // Shut-in formula: v = 0 (no migration when shut in)
      return 0;

    case 'HARMATHY':
      // Harmathy correlation for gas rise in stagnant fluid
      // v = 0.35 * sqrt(g * D * Δρ / ρ_mud)
      // Assuming annulus hydraulic diameter
      const D_h = 0.1; // Approximate annulus Dh in meters
      return 0.35 * Math.sqrt(g * D_h * drho / rho_mud_kgm3);

    case 'MODIFIED_HARMATHY':
      // Modified for wellbore conditions with adjustments for viscosity
      const mu_mud_cp = 30; // Assumed mud viscosity
      const mu_ratio = mu_mud_cp / Math.max(fluidProps.viscosity_cp, 0.1);
      const D_h2 = 0.1;
      const v_base = 0.35 * Math.sqrt(g * D_h2 * drho / rho_mud_kgm3);
      return v_base / Math.sqrt(mu_ratio); // Slower rise in viscous mud

    default:
      return 0;
  }
}

function updateFormationFluidMigration(dt_s) {
  if (!formationFluidEnabled || formationFluidRate_gpm <= 0) return;

  const fluidProps = FORMATION_FLUID_TYPES[formationFluidType];
  if (!fluidProps) return;

  // Add formation fluid influx at specified depth
  const influx_m3s = formationFluidRate_gpm / 15850.323;
  const influx_volume_m3 = influx_m3s * dt_s;

  // Determine which cell the influx enters
  if (formationFluidDepth_m >= BOP_DEPTH) {
    // Below BOP
    const cellIndex = Math.floor((formationFluidDepth_m - BOP_DEPTH) / CELL_M);
    if (cellIndex >= 0 && cellIndex < formationFluidCells_below.length) {
      const cellVolume = areaAtDepthTop_(formationFluidDepth_m) * CELL_M;
      formationFluidCells_below[cellIndex] += influx_volume_m3 / cellVolume;
      formationFluidCells_below[cellIndex] = Math.min(formationFluidCells_below[cellIndex], 1.0);
    }
  } else {
    // Above BOP (riser)
    const cellIndex = Math.floor(formationFluidDepth_m / CELL_M);
    if (cellIndex >= 0 && cellIndex < formationFluidCells_above.length) {
      const cellVolume = areaAtDepthTop_(formationFluidDepth_m) * CELL_M;
      formationFluidCells_above[cellIndex] += influx_volume_m3 / cellVolume;
      formationFluidCells_above[cellIndex] = Math.min(formationFluidCells_above[cellIndex], 1.0);
    }
  }

  // Calculate migration velocity
  const avgMW = (MW_DS + MW_BO) / 2; // Simplified
  const avgPressure = pressureAtDepth(formationFluidDepth_m);
  const migrationVelocity = calculateMigrationVelocity_m_s(formationFluidType, avgPressure, avgMW);

  // Move formation fluid upward through cells (migration)
  if (migrationVelocity > 0 && formationFluidMigrationModel !== 'SHUTIN') {
    const migrationDist_m = migrationVelocity * dt_s;
    const cellsMoved = Math.floor(migrationDist_m / CELL_M);

    // Shift cells upward (simplified - needs proper advection integration)
    if (cellsMoved > 0) {
      for (let i = 0; i < formationFluidCells_below.length - cellsMoved; i++) {
        formationFluidCells_below[i] = formationFluidCells_below[i + cellsMoved];
      }
      // Clear bottom cells
      for (let i = Math.max(0, formationFluidCells_below.length - cellsMoved); i < formationFluidCells_below.length; i++) {
        formationFluidCells_below[i] = 0;
      }
    }
  }

  // Black oil dissociation check
  if (formationFluidType === 'BLACKOIL' && fluidProps.bubblePoint_psi) {
    for (let i = 0; i < formationFluidCells_below.length; i++) {
      if (formationFluidCells_below[i] > 0) {
        const depth = BOP_DEPTH + i * CELL_M;
        const P = pressureAtDepth(depth);

        // If pressure drops below bubble point, oil releases gas
        if (P < fluidProps.bubblePoint_psi) {
          const oilFraction = formationFluidCells_below[i];
          const gasReleased = oilFraction * 0.2; // 20% gas release (simplified)
          gasPhaseFrom_below[i] += gasReleased;
          formationFluidCells_below[i] -= gasReleased;
        }
      }
    }
  }

  // Update total volume
  formationFluidVolume_bbl += (formationFluidRate_gpm * dt_s) / 42; // Convert to barrels

  // Update front position (find highest cell with formation fluid)
  let highestCell = -1;
  for (let i = 0; i < formationFluidCells_below.length; i++) {
    if (formationFluidCells_below[i] > 0.01) {
      highestCell = i;
      break;
    }
  }
  if (highestCell >= 0) {
    formationFluidFront_m = BOP_DEPTH + highestCell * CELL_M;
  }
}

// REPLACE stepAdvection() completely:

// REPLACE stepAdvection() completely:
function stepAdvection(){
  // --- accumulator guards (persist across frames) ---
  if (typeof window.accDS    !== 'number') window.accDS    = 0;
  if (typeof window.accBo    !== 'number') window.accBo    = 0;
  if (typeof window.accBelow !== 'number') window.accBelow = 0;
  if (typeof window.accDSup  !== 'number') window.accDSup  = 0; // <-- was undefined before
  if (typeof window.accAbove !== 'number') window.accAbove = 0;
  if (typeof window.accTF    !== 'number') window.accTF    = 0;

  const dt   = frameSeconds();
  const vref = V_REF();
  const FLOW_THRESHOLD = 1e-8;

  // Routed internal section flows (magnitudes, in m^3/s) from the router:
  const qUp_m3s   = (typeof __qAnnUp_m3s   === 'number') ? __qAnnUp_m3s   : 0;  // upward above loss zone
  const qDown_m3s = (typeof __qAnnDown_m3s === 'number') ? __qAnnDown_m3s : 0;  // downward toward loss zone

  // Grids & geometry helpers you already have:
  const A_riser = area_annulus(riser_ID_m,   ds_OD_m);
  const A_csg   = area_annulus(casing_ID_m,  ds_OD_m);
  const A_oh    = area_annulus(openhole_ODm, ds_OD_m);

  // Derived "below-BOP" average area (used for below-zone advection speed)
  const L_csg = Math.max(SHOE_DEPTH - BOP_DEPTH, 0);
  const L_oh  = Math.max(TD_DEPTH   - SHOE_DEPTH, 0);
  const A_below = (L_csg + L_oh) > 1e-9
    ? (L_csg * A_csg + L_oh * A_oh) / (L_csg + L_oh)
    : Math.max(A_csg, A_oh, 1e-9);

  // ===============================
  // 1) DRILLSTRING PIPE (down only)
  // ===============================
  {
    const qDS_m3s = Math.max(0, ((Q_DS || 0) / 15850.323));
    if (qDS_m3s > FLOW_THRESHOLD) {
      const A_ds = Math.PI * ds_ID_m * ds_ID_m / 4;
      const v_ds = qDS_m3s / Math.max(A_ds, 1e-12);
      const dsStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_ds / vref);

      accDS += dsStep_m;
      while (accDS >= CELL_M){
        dsGrid.pop();
        dsGrid.unshift(MW_DS);
        accDS -= CELL_M;
      }
    }
  }
  const dsEffluentMW = dsGrid[dsGrid.length - 1] || MW_DS;

  // ===============================
  // 2) BOOSTER PIPE (TOP → DOWN)
  // ===============================
  let boosterEffluentMW = MW_BO;  // Track what exits booster pipe at BOP
  {
    const qBO_m3s = Math.max(0, ((Q_BO || 0) / 15850.323));
    if (qBO_m3s > FLOW_THRESHOLD) {
      const A_bo = Math.PI * booster_ID_m * booster_ID_m / 4;
      const v_bo = qBO_m3s / Math.max(A_bo, 1e-12);
      const boStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_bo / vref);

      accBo += boStep_m;
      while (accBo >= CELL_M){
        // Fluid enters at TOP (surface/inlet), exits at BOTTOM (BOP)
        boosterEffluentMW = boosterGrid.pop(); // Remove from bottom (exits at BOP)
        boosterGrid.unshift(MW_BO);  // Add new fluid at top (surface inlet)
        accBo -= CELL_M;
      }
    }
    // Always use bottom of grid as current effluent
    boosterEffluentMW = boosterGrid[boosterGrid.length - 1] || MW_BO;
  }
  const boosterMW = boosterEffluentMW;  // Compatibility

  // ===============================
  // 3) EXTRACT LOSSES FROM GRIDS
  // ===============================
  if (LOSSES_ON){
    for (const z of lossZones){ 
      extractLossFluidFromGrid(z, dt); 
    }
  }

  // ===============================================
  // 4) ANNULUS BELOW THE BOP: DOWN + UP PROCESSING
  // ===============================================
  // (A) DOWNWARD advection (booster/topfill routed toward zone)
  if (qDown_m3s > FLOW_THRESHOLD) {
    const v_down = qDown_m3s / Math.max(A_below, 1e-12);
    const step_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_down / vref);

    accBelow += step_m;
    while (accBelow >= CELL_M){
      // Shift DOWN from BOP to deeper cells
      for (let i = annBelowGrid.length - 1; i > 0; i--) {
        annBelowGrid[i] = annBelowGrid[i - 1];
      }
      // New fluid from booster exits at BOP and flows DOWN to losses
      // Note: qDown_m3s = takeBO (only booster goes down from BOP)
      // Topfill is injected at surface level, not at BOP
      annBelowGrid[0] = boosterEffluentMW;

      accBelow -= CELL_M;
    }
  }

  // (B) UPWARD advection (leftover DS above zone)
  if (qUp_m3s > FLOW_THRESHOLD) {
    const v_up = qUp_m3s / Math.max(A_below, 1e-12);
    const upStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_up / vref);

    // We shift UP the portion *from the zone upwards*
    accDSup += upStep_m;
    const cellsFlowing = annBelowGrid.length; // upward through whole below section toward BOP
    while (accDSup >= CELL_M && cellsFlowing > 0){
      // Shift UP from bottom to top
      for (let i = 0; i < annBelowGrid.length - 1; i++) {
        annBelowGrid[i] = annBelowGrid[i + 1];
      }
      // New fluid from bit enters at bottom
      annBelowGrid[annBelowGrid.length - 1] = dsEffluentMW;
      accDSup -= CELL_M;
    }
  }
  // If qUp_m3s ~ 0, leave annBelowGrid as-is: column below remains static except where DOWN flow was applied.

  // =========================================================
  // 5) RISER (ABOVE BOP): ONLY ADVECT WHEN THERE IS UPFLOW
  // =========================================================
  if (qUp_m3s > FLOW_THRESHOLD) {
    const v_above = qUp_m3s / Math.max(A_riser, 1e-12);
    const aboveStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_above / vref);

    // Calculate booster contribution going UP (not routed down to losses)
    const qBO_m3s = Math.max(0, ((Q_BO || 0) / 15850.323));
    const qBO_up = Math.max(0, qBO_m3s - qDown_m3s);  // Booster NOT going down = going UP
    const qFromAnnBelow = Math.max(0, qUp_m3s - qBO_up);  // Flow from annulus below (DS + TF)

    accAbove += aboveStep_m;
    while (accAbove >= CELL_M){
      // Remove from surface, add mixture at BOP (from annulus below + booster going up)
      annAboveGrid.shift();

      const fromBelowMW = annBelowGrid[0] || dsEffluentMW; // incoming upward fluid from annulus
      const qTotal = Math.max(qFromAnnBelow + qBO_up, 1e-12);
      const mixMW = (qFromAnnBelow * fromBelowMW + qBO_up * boosterEffluentMW) / qTotal;

      annAboveGrid.push(mixMW);
      accAbove -= CELL_M;
    }

    if (annAboveGrid.length){
      const k = annAboveGrid.length - 1;
      const fromBelowMW = annBelowGrid[0] || dsEffluentMW;
      const qTotal = Math.max(qFromAnnBelow + qBO_up, 1e-12);
      const mixMW = (qFromAnnBelow * fromBelowMW + qBO_up * boosterEffluentMW) / qTotal;
      annAboveGrid[k] = (1 - accAbove/CELL_M) * annAboveGrid[k] + (accAbove/CELL_M) * mixMW;
    }
  }
  // If qUp_m3s ~ 0, leave annAboveGrid unchanged: riser column stays static.

  // =========================================================
  // 6) TOP FILL at actual fluid surface (keep your logic)
  // =========================================================
  (function topFillBlock(){
    const flowProfile = computeFlowProfile(); // reuse your FO/topfill inputs if needed elsewhere
    if ((flowProfile.topfill || 0) > FLOW_THRESHOLD) {
      const actualTop = annulusTopDepthGlobal(); // Actual wet/dry interface

      if (actualTop > 0.5) { // Only if there's headspace
        if (actualTop <= BOP_DEPTH) {
          // Fill riser (annAboveGrid)
          const v_tf = flowProfile.topfill / Math.max(A_riser, 1e-12);
          const tfStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_tf / vref);
          accTF += tfStep_m;
          while (accTF >= CELL_M){
            const surfaceCell = Math.floor(actualTop / CELL_M);
            if (surfaceCell < annAboveGrid.length) {
              for (let i = annAboveGrid.length - 1; i > surfaceCell; i--) {
                annAboveGrid[i] = annAboveGrid[i - 1];
              }
              annAboveGrid[surfaceCell] = MW_TOPFILL;
            }
            accTF -= CELL_M;
          }
        } else {
          // Fill below BOP (annBelowGrid)
          const v_tf = flowProfile.topfill / Math.max(A_below, 1e-12);
          const tfStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_tf / vref);
          accTF += tfStep_m;
          while (accTF >= CELL_M){
            const surfaceCell = Math.floor((actualTop - BOP_DEPTH) / CELL_M);
            if (surfaceCell >= 0 && surfaceCell < annBelowGrid.length) {
              for (let i = annBelowGrid.length - 1; i > surfaceCell; i--) {
                annBelowGrid[i] = annBelowGrid[i - 1];
              }
              annBelowGrid[surfaceCell] = MW_TOPFILL;
            }
            accTF -= CELL_M;
          }
        }
      }
    }
  })();

  // ===============================
  // 7) CML PIPE (unchanged)
  // ===============================
  if (CML_ON && Q_CML > 0){
    const qCML = Q_CML / 15850.323;
    const cmlStep_m = BASE_M_PER_FRAME * (qCML / (Q_REF/15850.323));
    accCML = (accCML || 0) + cmlStep_m;
    const iPump = clamp(Math.floor(CML_DEPTH / CELL_M), 0, N_ABV-1);
    const srcMW = annAboveGrid[iPump] || MW_DS;
    while (accCML >= CELL_M){
      cmlPipeGrid.shift();
      cmlPipeGrid.push(srcMW);
      accCML -= CELL_M;
    }
  }
}



function gravityDensitySwap() {
  if (!EH.GRAV || !EH.GRAV.on) return;
  
  const dt = frameSeconds();
  const swapProb = GRAVITY_SWAP_RATE * dt; // Probability per frame
  
  if (Math.random() > swapProb) return; // Only swap occasionally
  
  // Function to swap adjacent cells if unstable
  const swapIfUnstable = (grid, i) => {
    if (i >= grid.length - 1) return false;
    
    const rhoTop = grid[i] * PPG_TO_KGM3;
    const rhoBot = grid[i + 1] * PPG_TO_KGM3;
    
    // Unstable if heavier on top (Rayleigh-Taylor instability)
    if (rhoTop > rhoBot + 5) { // 5 kg/m³ threshold
      // Swap with mixing (not instant)
      const mixFactor = 0.3; // Partial swap for realism
      const temp = grid[i];
      grid[i] = (1 - mixFactor) * grid[i] + mixFactor * grid[i + 1];
      grid[i + 1] = (1 - mixFactor) * grid[i + 1] + mixFactor * temp;
      return true;
    }
    return false;
  };
  
  // Check all grids for instability
  let swapped = false;
  
  // Riser
  for (let i = 0; i < annAboveGrid.length - 1; i++) {
    if (swapIfUnstable(annAboveGrid, i)) swapped = true;
  }
  
  // Below BOP
  for (let i = 0; i < annBelowGrid.length - 1; i++) {
    if (swapIfUnstable(annBelowGrid, i)) swapped = true;
  }
  
  // Note: Only swap in static regions (where flow velocity is low)
  // You could add a velocity check here if needed
}

// ========================= DENSITY / FLOWS =============================
function annulusAvgPPG(){ return average(annAboveGrid.concat(annBelowGrid)); }
function rhoDynamic(){ return annulusAvgPPG() * PPG_TO_KGM3; }
function rho_bo(){ return boosterAvgPPG() * PPG_TO_KGM3; }
function dsAvgPPG(){ return average(dsGrid) || MW_DS; }
function boosterAvgPPG(){ return average(boosterGrid) || MW_BO; }
function flows_m3s(){
  const qDS_m3s = (Q_DS || 0) / 15850.323; // gpm → m³/s
  const qBO_m3s = (Q_BO || 0) / 15850.323;
  return { qDS: qDS_m3s, qBO: qBO_m3s, qAnnBelow: qDS_m3s, qAnnAbove: qDS_m3s + qBO_m3s };
}
// ======================= SECTION-SPECIFIC dP/dL ========================
// Add this function near getRheoForCalc (around line 820)
function publishRheoToGlobals(){
  const { K, n, tauY } = getRheoForCalc();

  if (ACTIVE_RHEO_MODEL === "Bingham"){
    window.TAUY_Pa = tauY;
    window.MUP_PaS = K;
    window.K_PaSn = K;
    window.N_dim = 1.0;
  } else if (ACTIVE_RHEO_MODEL === "PowerLaw"){
    window.TAUY_Pa = 0;
    window.MUP_PaS = 0.001; // nominal for PL
    window.K_PaSn = K;
    window.N_dim = n;
  } else { // HB
    window.TAUY_Pa = tauY;
    window.MUP_PaS = K; // approximate
    window.K_PaSn = K;
    window.N_dim = n;
  }
}

function dPperM_riserAnnulus(Q) {
  const base = getRheoForCalc();
  const z0 = 0, z1 = BOP_DEPTH, dz = 200;
  let dP_total = 0;
  for (let z = z0; z < z1; z += dz) {
    const rho0 = rhoDynamic();
    const adj = applyPressureOnly(z, rho0, base.K, base.n, base.tauY);
    const dpdl = dP_per_m_annulus_withRPM(Q, adj.rho, riser_ID_m, ds_OD_m, adj.K, adj.n, adj.tauY, RPM);
    dP_total += dpdl * Math.min(dz, z1 - z);
  }
  return dP_total / (z1 - z0);
}
function dPperM_casingAnnulus(Q) {
  const base = getRheoForCalc();
  const z0 = BOP_DEPTH, z1 = SHOE_DEPTH, dz = 200;
  let dP_total = 0;
  for (let z = z0; z < z1; z += dz) {
    const rho0 = rhoDynamic();
    const adj = applyPressureOnly(z, rho0, base.K, base.n, base.tauY);
    const dpdl = dP_per_m_annulus_withRPM(Q, adj.rho, casing_ID_m, ds_OD_m, adj.K, adj.n, adj.tauY, RPM);
    dP_total += dpdl * Math.min(dz, z1 - z);
  }
  return dP_total / (z1 - z0);
}
function dPperM_openholeAnnulus(Q) {
  const base = getRheoForCalc();
  const z0 = SHOE_DEPTH, z1 = TD_DEPTH, dz = 200;
  let dP_total = 0;
  for (let z = z0; z < z1; z += dz) {
    const rho0 = rhoDynamic();
    const adj = applyPressureOnly(z, rho0, base.K, base.n, base.tauY);
    const dpdl = dP_per_m_annulus_withRPM(Q, adj.rho, openhole_ODm, ds_OD_m, adj.K, adj.n, adj.tauY, RPM);
    dP_total += dpdl * Math.min(dz, z1 - z);
  }
  return dP_total / (z1 - z0);
}
function dPperM_drillstring(Q) {
  const base = getRheoForCalc();
  const z0 = 0, z1 = TD_DEPTH, dz = 200;
  let dP_total = 0;
  for (let z = z0; z < z1; z += dz) {
    const rho0 = dsAvgPPG() * PPG_TO_KGM3;
    const adj = applyPressureOnly(z, rho0, base.K, base.n, base.tauY);
    const dpdl = dP_per_m_pipe_withRPM(Q, adj.rho, ds_ID_m, adj.K, adj.n, adj.tauY, RPM);
    dP_total += dpdl * Math.min(dz, z1 - z);
  }
  return dP_total / (z1 - z0);
}
function dPperM_booster(Q) {
  const base = getRheoForCalc();
  const z0 = 0, z1 = BOP_DEPTH, dz = 200;
  let dP_total = 0;
  for (let z = z0; z < z1; z += dz) {
    const rho0 = rho_bo();
    const adj = applyPressureOnly(z, rho0, base.K, base.n, base.tauY);
    const dpdl = dP_per_m_pipe_withRPM(Q, adj.rho, booster_ID_m, adj.K, adj.n, adj.tauY, 0);
    dP_total += dpdl * Math.min(dz, z1 - z);
  }
  return dP_total / (z1 - z0);
}
// =========================== FRICTION SUMS (RHEOLOGY-AWARE) =============================

// NOTE: frictionPsi_withCML_rheo() is defined later at line ~1437
// (removed duplicate definition here to avoid conflicts)

// Legacy name kept for backward compatibility; prefer rheology-aware when available
function frictionPsi_withCML(depth_m){
  if (typeof frictionPsi_withCML_rheo === 'function') {
    return frictionPsi_withCML_rheo(depth_m);
  }
  // Fallback to original (hydraulics-mode) implementation if you want to keep it:
  // (Paste your original frictionPsi_withCML here if you still need the legacy path.)
  return 0;
}

// Kept as your public entry; now prefers rheology-aware path
function frictionPsiAtDepth(depth_m){
  return frictionPsi_withCML(depth_m);
}

// Compatibility shim for callers using frictionPsi(depth)
function frictionPsi(depth_m){
  if (typeof FRICTION_MODE !== 'undefined' && FRICTION_MODE === "hydraulics") {
    return frictionPsiAtDepth(depth_m);
  }
  // Simple K-factor fallback if someone forces non-hydraulics (kept from your code)
  const qTot = (window.Q_DS || 0) + (window.Q_BO || 0);
  const base = (typeof K_FAC === 'number' ? K_FAC : 0) * qTot * Math.max(depth_m, 0);
  return base; // no RPM boost here
}

// ====================== PRESSURE / ECD PROFILES =======================
// In ecdAtDepth function, add:
function ecdAtDepth(d){
  // ✅ FIXED: Correct averaging from surface to depth
  // ECD = average mud weight from surface down to specified depth

  if (d <= BOP_DEPTH){
    // Above BOP: average cells from surface to depth in riser
    const numCells = Math.floor(d / CELL_M) + 1;
    const result = average(annAboveGrid.slice(0, numCells));
    return result;
  } else {
    // Below BOP: average ALL riser cells + cells from BOP to depth
    const sumAbove = sumCells(annAboveGrid, 0, N_ABV - 1);  // Sum all riser cells
    const nAbove = N_ABV;  // Total cells in riser

    // Cells from BOP to depth in casing/OH
    const depthBelowBOP = d - BOP_DEPTH;
    const numBelowCells = Math.floor(depthBelowBOP / CELL_M) + 1;

    // ✅ FIX: Don't try to sum more cells than exist in the grid!
    const actualBelowCells = Math.min(numBelowCells, annBelowGrid.length);
    const sumBelow = sumCells(annBelowGrid, 0, actualBelowCells - 1);

    const totalCells = nAbove + actualBelowCells;  // Use actual cells, not calculated
    const result = (sumAbove + sumBelow) / Math.max(totalCells, 1);
    return result;
  }
}



// --- ECD (ppg) that includes SBP + friction at depth ---
function ecdWithSBPAtDepth(d){
  const depth = Math.max(1, d);                 // avoid /0 at surface
  const P = pressureAtDepth(depth);             // hydro + friction + SBP
  return P / ((typeof PSI_COEF === 'number' ? PSI_COEF : 0.1704) * depth);
}
function pressureAtDepth_noSBP(d){
  const P_hyd = PSI_COEF * ecdAtDepth(d) * d;
  const P_fric = frictionPsi(d);
  return P_hyd + P_fric;
}


// --- Rheology-aware ΔP/L from volumetric flow in a circular conduit (GNF) ---
// We invert Q(dP) numerically to get dP/L that yields the requested Q.
function __dpPerM_pipe_GNF_fromQ(Q_m3s, D_m, tauToShearRateFn){
  const L = 1.0;                    // 1 meter for gradient
  const Qtarget = Math.max(0, Q_m3s);
  if (Qtarget <= 0 || D_m <= 0) return 0;

  // Bracket ΔP (psi) then bisection
  let lo = 0, hi = 1e6; // psi/m (huge upper bound)
  for (let k=0; k<50; k++){        // expand until Q(hi) >= target
    const Qhi = laminarPipeFlow_GNF(hi, D_m, L, tauToShearRateFn);
    if (Qhi >= Qtarget) break;
    hi *= 2;
  }
  for (let it=0; it<40; it++){
    const mid = 0.5*(lo+hi);
    const Qmid = laminarPipeFlow_GNF(mid, D_m, L, tauToShearRateFn);
    if (Qmid >= Qtarget) hi = mid; else lo = mid;
  }
  return hi; // psi per meter
}

// Return ΔP/L for an *annulus* using hydraulic diameter equivalence.
// --- Rheology-aware annulus ΔP/L helper (uses ACTIVE_RHEO_MODEL) ---
function __dpPerM_annulus_GNF_fromQ(Q_m3s, ID_m, OD_m, modelName){
  const ri = Math.min(ID_m, OD_m) * 0.5;
  const ro = Math.max(ID_m, OD_m) * 0.5;
  const gap = ro - ri;
  if (gap <= 1e-6) return 0;

  const A  = Math.PI * (ro*ro - ri*ri);
  const P  = 2*Math.PI*(ri + ro);
  const Dh = 4 * A / P;

  const m = String(modelName || window.ACTIVE_RHEO_MODEL || 'HB').toUpperCase();

  if (m === 'BINGHAM'){
    const tauY = (window.TAUY_Pa ?? 5);
    const muP  = (window.MUP_PaS ?? 0.1);
    const tauToShear = (tau) => (tau <= tauY) ? 0 : (tau - tauY)/Math.max(muP,1e-12);
    const result = __dpPerM_pipe_GNF_fromQ(Q_m3s, Dh, tauToShear);
    return result;
  } else if (m === 'PL' || m === 'POWERLAW' || m === 'POWER-LAW'){
    const K = (window.K_PaSn ?? 0.2);
    const n = Math.max(1e-6, (window.N_dim ?? 0.7));
    const tauToShear = (tau) => Math.pow(Math.max(tau,0)/Math.max(K,1e-12), 1/n);
    const result = __dpPerM_pipe_GNF_fromQ(Q_m3s, Dh, tauToShear);
    return result;
  } else { // HB default
    const tauY = (window.TAUY_Pa ?? 5);
    const K    = (window.K_PaSn  ?? 0.2);
    const n    = Math.max(1e-6, (window.N_dim ?? 0.6));
    const tauToShear = (tau) => (tau <= tauY) ? 0 : Math.pow((tau - tauY)/Math.max(K,1e-12), 1/n);
    const result = __dpPerM_pipe_GNF_fromQ(Q_m3s, Dh, tauToShear);
    return result;
  }
}


// invert Q(dP) to get ΔP/L for a circular conduit (used with Dh)
function __dpPerM_pipe_GNF_fromQ(Q_m3s, D_m, tauToShearRateFn){
  const L = 1.0;
  const Qtarget = Math.max(0, Q_m3s);
  if (Qtarget <= 0 || D_m <= 0) return 0;

  let lo = 0, hi = 1e6; // psi per meter
  for (let k=0; k<50; k++){
    const Qhi = laminarPipeFlow_GNF(hi, D_m, L, tauToShearRateFn);
    if (Qhi >= Qtarget) break;
    hi *= 2;
  }
  for (let it=0; it<40; it++){
    const mid = 0.5*(lo+hi);
    const Qmid = laminarPipeFlow_GNF(mid, D_m, L, tauToShearRateFn);
    if (Qmid >= Qtarget) hi = mid; else lo = mid;
  }
  return hi; // psi per meter
}

// --- Friction from surface to depth d (psi), CML/wet-top aware & rheology-aware ---
function frictionPsi_withCML_rheo(d){
  const depth = Math.max(0, d);

  // Read section flows published by routeAnnulusFlowsWithLosses()
  // DO NOT call recomputeAnnulusSectionFlowsForLosses() - it uses old routing logic!
  const qAbove = Math.max(0, window.__qAnnAbove_m3s || window.__qAnnUp_m3s || 0);
  const qBelow = Math.max(0, window.__qAnnBelow_m3s || window.__qAnnDown_m3s || 0);

  // Wet spans
  const topGlobal = (typeof annulusTopDepthGlobal==='function') ? annulusTopDepthGlobal()
                   : (typeof riserTopDepth==='function' ? riserTopDepth() : 0);
  const topRiser  = Math.min(topGlobal, BOP_DEPTH);
  const topBelow  = Math.max(BOP_DEPTH, topGlobal);

  const L_riser = Math.max(0, Math.min(BOP_DEPTH, depth) - topRiser);
  const L_csg   = (depth <= BOP_DEPTH) ? 0 : Math.max(0, Math.min(depth, SHOE_DEPTH) - topBelow);
  const L_oh    = (depth <= SHOE_DEPTH) ? 0 : Math.max(0, depth - Math.max(topBelow, SHOE_DEPTH));

  // Geometries (outer = section ID, inner = DS OD)
  const ID_ris = (typeof riser_ID_m   !== 'undefined') ? riser_ID_m   : 0.482;
  const ID_csg = (typeof casing_ID_m  !== 'undefined') ? casing_ID_m  : 0.216;
  const ID_oh  = (typeof openhole_ODm !== 'undefined') ? openhole_ODm : 0.216;
  const OD_ds  = (typeof ds_OD_m      !== 'undefined') ? ds_OD_m      : 0.127;

  // ΔP/L (psi/m) - use turbulent-capable friction function
  const mName = ACTIVE_RHEO_MODEL;
  const { K, n, tauY } = getRheoForCalc();

  // Convert MW to density (ppg to kg/m³)
  const rho = ecdAtDepth(depth) * 119.826; // kg/m³

  // Use turbulent-capable friction (auto-switches laminar/turbulent based on Re)
  // Returns Pa/m, convert to psi/m
  const PA_TO_PSI = 1.0 / 6894.757;
  const dpdm_riser = (L_riser>0) ? dP_per_m_annulus_withRPM(qAbove, rho, ID_ris, OD_ds, K, n, tauY, RPM) * PA_TO_PSI : 0;
  const dpdm_csg   = (L_csg  >0) ? dP_per_m_annulus_withRPM(qBelow, rho, ID_csg, OD_ds, K, n, tauY, RPM) * PA_TO_PSI : 0;
  const dpdm_oh    = (L_oh   >0) ? dP_per_m_annulus_withRPM(qBelow, rho, ID_oh,  OD_ds, K, n, tauY, RPM) * PA_TO_PSI : 0;

  const totalFriction = dpdm_riser*L_riser + dpdm_csg*L_csg + dpdm_oh*L_oh;
  return totalFriction;
}

// Back-compat entry point
function frictionPsi_withCML(depth_m){
  return frictionPsi_withCML_rheo(depth_m);
}
function frictionPsiAtDepth(depth_m){ return frictionPsi_withCML(depth_m); }

// --- Pressure without SBP: hydro (wet-top aware) + rheology-aware friction ---
function pressureAtDepth_noSBP_withCML(d){
  // clamp depth
  const depth = Math.max(0, Math.min(d, (typeof TD_DEPTH==='number' ? TD_DEPTH : d)));

  // wet top can sink below BOP when riser is dry
  const topGlobal = (typeof annulusTopDepthGlobal==='function')
    ? annulusTopDepthGlobal()
    : (typeof riserTopDepth==='function' ? riserTopDepth() : 0);

  const effDepth = Math.max(0, depth - topGlobal);
  const ecd_ppg  = (typeof ecdAtDepth==='function') ? ecdAtDepth(depth) : (window.MW_DS ?? 9.5);

  const P_hyd  = (typeof PSI_COEF==='number' ? PSI_COEF : 0.1704) * ecd_ppg * effDepth;
  const P_fric = (typeof frictionPsi_withCML_rheo==='function') ? frictionPsi_withCML_rheo(depth) : 0;

  return P_hyd + P_fric;
}

// --- Total annulus pressure (psi): hydro + friction + SBP ---
// Find pressureAtDepth (around line 1340) - ensure it looks like this:

function pressureAtDepth(d){
  if (d < 0) return 0;
  if (d > TD_DEPTH) d = TD_DEPTH;

  const fluidTop = annulusTopDepthGlobal();

  // Above fluid level = atmospheric only
  if (d < fluidTop) {
    return 14.7;
  }

  // Refresh section flows
  if (typeof window.__qAnnAbove_m3s !== 'number' || typeof window.__qAnnBelow_m3s !== 'number'){
    if (typeof recomputeAnnulusSectionFlowsForLosses === 'function') {
      recomputeAnnulusSectionFlowsForLosses();
    }
  }

  // Hydrostatic (only below fluid level)
  const depth_wet = d - fluidTop;
  const ecd_ppg = ecdAtDepth(d);
  const P_hydro = PSI_COEF * ecd_ppg * depth_wet;

  // Friction
  const P_fric = frictionPsi_withCML_rheo(d);

  // SBP (only when riser is FULL)
  const riserFull = (fluidTop <= 0);
  const P_sbp = (MPD_ON && riserFull) ? (CURRENT_SBP || 0) : 0;

  const total = P_hydro + P_fric + P_sbp;
  return total;
}

// --- ECD (ppg) from full pressure (includes SBP + friction) ---
function ecdWithSBPAtDepth(d){
  const depth = Math.max(1, d); // avoid /0
  const P     = pressureAtDepth(depth);
  return P / ((typeof PSI_COEF==='number' ? PSI_COEF : 0.1704) * depth);
}


// ================== SPP + LEVEL (smooth low-flow ramp) =================
function dsFrictionPsiLength(len_m){
  const { qDS } = flows_m3s();
  const pa_per_m = dPperM_drillstring(qDS);
  return (pa_per_m * Math.max(len_m, 0)) * PSI_PER_PASCAL;
}
function boosterFrictionPsiLength(len_m){
  const { qBO } = flows_m3s();
  const pa_per_m = dPperM_booster(qBO);
  return (pa_per_m * Math.max(len_m, 0)) * PSI_PER_PASCAL;
}
// --- Pump SPP helpers should also use the rheology-aware friction ---
function sppAtLevel(lvl_m){
  const lvl = Math.max(0, Math.min(lvl_m, TD_DEPTH));
  const filledLen = TD_DEPTH - lvl;
  const dsFricPsi = dsFrictionPsiLength(filledLen);
  const annFricPsi = frictionPsi_withCML_rheo(TD_DEPTH);   // <— rheology-aware
  const sbpPsi = (window.CURRENT_SBP || 0);
  const MWann = annulusAvgPPG();
  const MWds = dsAvgPPG();
  const hydroPsi = PSI_COEF * (MWann * TD_DEPTH - MWds * filledLen);
  return dsFricPsi + annFricPsi + sbpPsi + hydroPsi;
}

function boSppAtLevel(lvl_m){
  const lvl = Math.max(0, Math.min(lvl_m, BOP_DEPTH));
  const filledLen = BOP_DEPTH - lvl;
  const boFricPsi = boosterFrictionPsiLength(filledLen);
  const annFricAbovePsi = frictionPsi_withCML_rheo(BOP_DEPTH); // <— rheology-aware
  const sbpPsi = (window.CURRENT_SBP || 0);
  const MWannAbv = average(annAboveGrid);
  const MWbo = boosterAvgPPG();
  const hydroPsi = PSI_COEF * (MWannAbv * BOP_DEPTH - MWbo * filledLen);
  return boFricPsi + annFricAbovePsi + sbpPsi + hydroPsi;
}
function surfacePumpPressure(){
  // updates levelDeficit_m as side-effect
  let f0 = sppAtLevel(levelDeficit_m);
  // Not enough head → level drops (gauge stays ≈0 while dropping)
  if (f0 < 0){
    const f1 = sppAtLevel(Math.min(levelDeficit_m + 1, TD_DEPTH));
    const slope = Math.max(f1 - f0, 1e-6);
    const delta = Math.min((-f0)/slope, TD_DEPTH - levelDeficit_m);
    levelDeficit_m += delta;
    return 0;
  }
  // Have positive head; refill first
  if (levelDeficit_m > 0){
    const MWds = Math.max(dsAvgPPG(), 0.1);
    const psiPerM = PSI_COEF * MWds;
    const rise_m = Math.min(f0 / psiPerM, levelDeficit_m);
    levelDeficit_m = Math.max(levelDeficit_m - rise_m, 0);
    return f0 - rise_m * psiPerM;
  }
  return f0 + localKLossPsi();
}
function boosterPumpPressure(){
  // updates levelDeficit_bo_m
  let f0 = boSppAtLevel(levelDeficit_bo_m);
  if (f0 < 0){
    const f1 = boSppAtLevel(Math.min(levelDeficit_bo_m + 1, BOP_DEPTH));
    const slope = Math.max(f1 - f0, 1e-6);
    const delta = Math.min((-f0)/slope, BOP_DEPTH - levelDeficit_bo_m);
    levelDeficit_bo_m += delta;
    return 0;
  }
  if (levelDeficit_bo_m > 0){
    const MWbo = Math.max(boosterAvgPPG(), 0.1);
    const psiPerM = PSI_COEF * MWbo;
    const rise_m = Math.min(f0 / psiPerM, levelDeficit_bo_m);
    levelDeficit_bo_m = Math.max(levelDeficit_bo_m - rise_m, 0);
    return f0 - rise_m * psiPerM;
  }
  return f0 + localKLossPsi();
}

// --- TOTAL WELLBORE PRESSURE at depth (hydrostatic + annulus friction + SBP) ---
// --- TOTAL WELLBORE PRESSURE at depth (hydrostatic + annulus friction + SBP) ---
function pressureAtDepthTotal(d){
  // pressureAtDepth(d) already includes: hydrostatic (with wetted top), annulus friction, and SBP.
  // This is the annulus pressure seen by the formation at depth d.
  return pressureAtDepth(d);
}

/* ===================== ATTENUATION CONSTANTS (tune as needed) ===================== */
const LOSS_DEADBAND_PSI      = 30;   // ignore small ΔP wiggles (psi) - increased for stability
const LOSS_P_TAU_S           = 0.80; // low-pass on zone ΔP (s)
const LOSS_Q_TAU_S           = 1.8;  // low-pass on zone Qloss (s) - increased for smoother stabilization
const LOSS_DQDT_MAX_GPM_S    = 200;  // max zone loss change rate (gpm/s) - reduced for smoother response
const LOSS_RELAX_PER_ITER    = 0.50; // solver relaxation per iteration
const LOSS_SOLVER_MAX_IT     = 8;    // max iterations
const LOSS_SOLVER_TOL_GPM    = 0.05; // convergence tolerance (gpm)

/* ===================== SAFE HELPERS (reuse existing if present) ===================== */
const __lp = (typeof lowpass === 'function')
  ? lowpass
  : function(prev, x, dt, tau_s){ const a = tau_s > 0 ? dt / (tau_s + dt) : 1; return prev + a * (x - prev); };

const __slew = (typeof slew === 'function')
  ? slew
  : function(prev, target, maxRate_per_s, dt){
      const maxStep = Math.max(0, maxRate_per_s) * dt;
      if (target > prev + maxStep) return prev + maxStep;
      if (target < prev - maxStep) return prev - maxStep;
      return target;
    };
// --- Helpers used by the transition logic ---
function areaAtDepthTop_(d){
  if (d <= BOP_DEPTH)  return A_riserAnn();
  if (d <= SHOE_DEPTH) return A_casingAnn();
  return A_openAnn();
}
function nextBoundaryAfter_(d, goingUp){ // goingUp = true if depth is decreasing
  if (goingUp){
    // moving toward surface: boundaries are {BOP, surface}
    if (d > SHOE_DEPTH) return SHOE_DEPTH;
    if (d > BOP_DEPTH)  return BOP_DEPTH;
    return 0; // surface
  } else {
    // moving deeper: boundaries are {BOP, shoe, TD}
    if (d < BOP_DEPTH)  return BOP_DEPTH;
    if (d < SHOE_DEPTH) return SHOE_DEPTH;
    return TD_DEPTH;
  }
}

// ---------------------------------------------------------------------------
// Flow router: splits DS / Booster / TopFill toward losses first,
// then leftover (if any) becomes upward annulus flow.
// Publishes: __qToLoss_m3s, __qAnnUp_m3s, __qAnnDown_m3s (signless magnitudes)
//            and a stable FLOW_OUT_gpm via hysteresis+smoothing.
// Call once per substep BEFORE friction and level solver.
// ---------------------------------------------------------------------------
function routeAnnulusFlowsWithLosses(dt_s){
  const M3_PER_GPM = 1/15850.323;

  // Inputs
  const qDS  = (Q_DS || 0) * M3_PER_GPM;
  const qBO  = (Q_BO || 0) * M3_PER_GPM;
  const qTF  = (TOPFILL_ON ? (Q_TOPFILL||0) : 0) * M3_PER_GPM;
  const qCML = (typeof effective_Q_CML_gpm==='function' ? (effective_Q_CML_gpm()||0) : 0) * M3_PER_GPM;

  // Filtered demand wanted by the loss zone (use demand, not actual)
  const qDem = (typeof totalLossDemand_m3s==='function')
    ? totalLossDemand_m3s()
    : ((typeof totalLossRate_gpm==='function' ? totalLossRate_gpm() : 0) * M3_PER_GPM);

  // Supply that can feed losses from downhole side (no surface returns here)
  // We allow DS + Booster + TopFill to feed the zone; subtract CML intake
  let qSupply = Math.max(0, qDS + qBO + qTF - qCML);

  // Amount that actually goes to the loss zone this step
  const qToLoss = Math.min(qDem, qSupply);

  // How to source qToLoss: prefer Booster (downward) while level below surface,
  // then DS, then TopFill; this ensures booster goes DOWN to the zone when not full.
  const riserFull = ((typeof annulusTopDepthGlobal==='function' ? annulusTopDepthGlobal() : (LOSS_TOP_DEPTH_m||0)) <= 0.5);

  let takeBO = 0, takeDS = 0, takeTF = 0;

  if (!riserFull) {
    // prioritize booster → DS → TF to feed the loss zone
    takeBO = Math.min(qBO, qToLoss);                // booster down first
    let rem = qToLoss - takeBO;
    takeDS = Math.min(qDS, rem);                    // then drillstring
    rem    = rem - takeDS;
    takeTF = Math.min(qTF, rem);                    // then topfill
  } else {
    // riser full: let DS/TF supply zone first; booster contributes to returns
    takeDS = Math.min(qDS, qToLoss);
    let rem = qToLoss - takeDS;
    takeTF = Math.min(qTF, rem);
    rem    = rem - takeTF;
    takeBO = Math.min(qBO, rem);
  }

  // Leftovers after feeding losses
  const DS_left = Math.max(0, qDS - takeDS);
  const BO_left = Math.max(0, qBO - takeBO);
  const TF_left = Math.max(0, qTF - takeTF);

  // Upward annulus flow contributor
  // - If riser full: everything goes up to surface
  // - If riser NOT full but NO losses (takeBO=0): booster goes UP to fill riser
  // - If riser NOT full AND losses active (takeBO>0): booster goes DOWN, rest goes UP
  //
  // ✅ AUTOMATIC BOOSTER REVERSAL:
  // If pressure doesn't allow booster to go down (BHP < Pfrac at loss zone),
  // the zone deactivates (dP < 0 triggers hysteresis), qToLoss → 0, takeBO → 0,
  // and BO_left routes upward via this logic. Booster then increases riser
  // hydrostatic until new equilibrium is found. No explicit reversal code needed!
  const qAnnUp = DS_left + TF_left + (riserFull || takeBO === 0 ? BO_left : 0);

  // ✅ CRITICAL FIX: Separate flows for friction calculation
  // BELOW BOP (casing/openhole): ONLY drillstring return flow
  // DS goes down drillstring, returns up annulus below BOP (minus losses consumed)
  const qAnnBelow = qDS - takeDS;  // Only DS return, NOT booster!

  // ABOVE BOP (riser): DS + Booster combined at BOP
  // This is already correctly calculated as qAnnUp
  const qAnnAbove = qAnnUp;  // DS_left + TF_left + BO_left (when riser full or no losses)

  // Downward flow component (for advection direction tracking)
  const qAnnDown = takeBO; // booster flow going DOWN to losses (for advection)

  // Publish clean section "signals" (magnitudes, signless)
  window.__qToLoss_m3s   = qToLoss;
  window.__qAnnUp_m3s    = qAnnUp;
  window.__qAnnDown_m3s  = qAnnDown;

  // ✅ CRITICAL: Publish correct flows for friction calculation
  // These represent actual flow through each annulus section:
  // - Below BOP: Only DS return (through casing/OH geometry)
  // - Above BOP: DS + Booster combined (through riser geometry)
  window.__qAnnAbove_m3s = qAnnAbove;  // DS+BO through riser
  window.__qAnnBelow_m3s = qAnnBelow;  // Only DS through casing/OH

  // ------------------- Stable FLOW_OUT with hysteresis -------------------
  const top = (typeof annulusTopDepthGlobal==='function') ? annulusTopDepthGlobal() : 0;
  const HYST_UP = 0.25, HYST_DN = 0.75;
  if (typeof routeAnnulusFlowsWithLosses._full === 'undefined'){
    routeAnnulusFlowsWithLosses._full = (top <= HYST_UP);
  }
  const wasFull = routeAnnulusFlowsWithLosses._full;
  const nowFull = wasFull ? (top <= HYST_DN) : (top <= HYST_UP);
  routeAnnulusFlowsWithLosses._full = nowFull;

  // If riser full, surface return equals upward annulus flow; otherwise zero
  const targetFO_gpm = nowFull ? Math.max(0, qAnnUp * 15850.323) : 0;

  // Debug FO calculation disabled (too verbose)
  // if (frameCount % 150 === 0) {
  //   console.log(`[FO_DEBUG] top=${top.toFixed(2)}m, wasFull=${wasFull}, nowFull=${nowFull}, qAnnUp=${(qAnnUp*15850.323).toFixed(1)} gpm, targetFO=${targetFO_gpm.toFixed(1)} gpm, FLOW_OUT=${(FLOW_OUT_gpm||0).toFixed(1)} gpm`);
  // }

  // Fast response for conventional circulation (no losses)
  // Slow response during losses to avoid oscillations
  const lossesActive = LOSSES_ON && qToLoss > 1e-6;
  const ALPHA = lossesActive ? 0.25 : 0.8;  // Fast filter when no losses
  const DQDT_MAX = lossesActive ? 800 : 5000; // Fast slew when no losses

  const prev = (typeof FLOW_OUT_gpm==='number') ? FLOW_OUT_gpm : 0;
  const lp   = prev + ALPHA*(targetFO_gpm - prev);
  const maxStep = DQDT_MAX * Math.max(dt_s, 1/120);
  const step = Math.max(-maxStep, Math.min(maxStep, lp - prev));
  FLOW_OUT_gpm = prev + step;

  // Additional debug disabled (too verbose)
  // if (frameCount % 150 === 0 && Math.abs(targetFO_gpm - FLOW_OUT_gpm) > 10) {
  //   console.log(`[FO_DEBUG] Slewing: prev=${prev.toFixed(1)}, lp=${lp.toFixed(1)}, step=${step.toFixed(1)}, dt=${dt_s.toFixed(4)}s, maxStep=${maxStep.toFixed(1)}`);
  // }

  // Optional smoother you already have
  if (typeof FLOW_OUT_ALPHA==='number') {
    window.FLOW_OUT_smooth = (window.FLOW_OUT_smooth||0) + FLOW_OUT_ALPHA*(FLOW_OUT_gpm - (window.FLOW_OUT_smooth||0));
  }
}


/* ===================== GENERALIZED-NEWTONIAN LAMINAR PIPE FLOW ===================== */
// === Units ===
// dP_psi (psi), D_m (m), L_m (m)
// tauToShearRateFn: function( tau_Pa ) -> shear_rate [1/s]
// Returns: Q [m^3/s]
function laminarPipeFlow_GNF(dP_psi, D_m, L_m, tauToShearRateFn) {
  const PSI_TO_PA = 6894.757;
  const dP = Math.max(0, dP_psi) * PSI_TO_PA;   // Pa
  const D  = Math.max(1e-6, D_m);               // m
  const L  = Math.max(1e-6, L_m);               // m
  const R  = 0.5 * D;                           // m

  // Wall shear stress τ_w = (ΔP * R) / (2 L) = ΔP * D / (4 L)
  const tau_w = dP * D / (4 * L);               // Pa

  // Radial discretization for velocity integration
  const N = 96;                                 // increase for accuracy if needed
  const dr = R / N;
  const r = new Array(N + 1);
  for (let i = 0; i <= N; i++) r[i] = i * dr;

  // Shear rate profile γ̇(r) from τ(r) = τ_w * r/R
  const gdot = new Array(N + 1);
  for (let i = 0; i <= N; i++) {
    const tau = tau_w * (r[i] / R);
    gdot[i] = Math.max(0, tauToShearRateFn(tau));
  }

  // Velocity profile: u(r) = ∫_{r}^{R} γ̇(ξ) dξ  (no-slip at wall: u(R)=0)
  const u = new Array(N + 1);
  u[N] = 0; // at r=R
  for (let i = N - 1; i >= 0; i--) {
    // Trapezoid for ∫ γ̇ dξ between r[i]..r[i+1]
    u[i] = u[i + 1] + 0.5 * (gdot[i] + gdot[i + 1]) * dr;
  }

  // Volumetric flow: Q = 2π ∫_{0}^{R} u(r) r dr
  let Q = 0;
  for (let i = 0; i < N; i++) {
    const r1 = r[i], r2 = r[i + 1];
    const u1 = u[i], u2 = u[i + 1];
    const ring = 0.5 * (u1 * r1 + u2 * r2) * (r2 - r1); // trapezoid in r
    Q += ring;
  }
  Q *= 2 * Math.PI; // m^3/s
  return Math.max(0, Q);
}

// Bingham: τ = τy + μP * γ̇  →  γ̇ = max(0, (τ - τy) / μP)
function binghamFlow(dP_psi, D_m, L_m, tauY_Pa, muP_Pa_s) {
  const tauToShear = (tau) => (tau <= (tauY_Pa || 0)) ? 0 : (tau - (tauY_Pa || 0)) / Math.max(muP_Pa_s || 1e-9, 1e-9);
  return laminarPipeFlow_GNF(dP_psi, D_m, L_m, tauToShear);
}

// Power-Law: τ = K * γ̇^n  →  γ̇ = (τ / K)^(1/n)
function powerLawFlow(dP_psi, D_m, L_m, K_Pa_s_n, n_dim) {
  const n = Math.max(1e-6, n_dim || 1);
  const K = Math.max(1e-12, K_Pa_s_n || 1e-12);
  const tauToShear = (tau) => Math.pow(Math.max(tau, 0) / K, 1 / n);
  return laminarPipeFlow_GNF(dP_psi, D_m, L_m, tauToShear);
}

// Herschel–Bulkley: τ = τy + K * γ̇^n  →  γ̇ = ((τ - τy)/K)^(1/n) if τ>τy, else 0
function herschelBulkleyFlow(dP_psi, D_m, L_m, tauY_Pa, K_Pa_s_n, n_dim) {
  const n = Math.max(1e-6, n_dim || 1);
  const K = Math.max(1e-12, K_Pa_s_n || 1e-12);
  const tauY = Math.max(0, tauY_Pa || 0);
  const tauToShear = (tau) => (tau <= tauY) ? 0 : Math.pow((tau - tauY) / K, 1 / n);
  return laminarPipeFlow_GNF(dP_psi, D_m, L_m, tauToShear);
}

/* ===================== NEW PHYSICS: BHP-BASED WITH FRICTION REDISTRIBUTION ===================== */

// Calculate fracture friction: ΔP caused by flow through fracture
function calculateFractureFriction_psi(qFrac_m3s, zone) {
  if (!zone || qFrac_m3s <= 0) return 0;

  const qFrac_gpm = qFrac_m3s * 15850.323;
  const n = zone.n || 1.0;

  // Use zone's reference calibration if available
  if (zone.Qref_gpm > 0 && zone.DPref_psi > 0) {
    const C_frac = zone.Qref_gpm / Math.pow(zone.DPref_psi, n);
    const dP_frac = Math.pow(qFrac_gpm / Math.max(C_frac, 1e-6), 1/n);
    return dP_frac;
  }

  // Fallback: Estimate fracture friction as percentage of annulus friction
  // Fractures are easier path but NOT frictionless
  // Assume fracture has ~20% of annulus resistance (can be tuned)
  const qEquiv_m3s = qFrac_m3s;
  const depth_m = zone.depth_m;

  // Calculate what annulus friction would be for this flow
  const qAbove_save = window.__qAnnAbove_m3s;
  window.__qAnnAbove_m3s = qEquiv_m3s;
  const P_fric_ann_equiv = frictionPsi_withCML_rheo(depth_m);
  window.__qAnnAbove_m3s = qAbove_save;

  // Fracture friction is ~20% of annulus friction (easier path but not zero)
  return P_fric_ann_equiv * 0.2;
}

// Fast friction approximation for losses solver (trades accuracy for speed)
// Uses simple power-law: dP ~ K * Q^n instead of full GNF rheology
// This gives ~10x speedup in the iterative BHP solver with acceptable accuracy
function frictionPsi_fast(depth_m, q_m3s) {
  if (q_m3s < 1e-9 || depth_m < 1) return 0;

  const q_gpm = q_m3s * 15850.323;

  // Power-law exponent from current rheology
  const n = (typeof window.N_dim === 'number') ? window.N_dim : 0.7;

  // Calibrate K_approx based on actual friction at reference condition
  // Use memoization to avoid recalculating every call
  if (typeof frictionPsi_fast._K_ref === 'undefined' || (frameCount % 60) === 0) {
    // Recalibrate every second (60 frames)
    const q_ref_m3s = 1000 / 15850.323; // 1000 gpm reference
    window.__qAnnAbove_m3s = q_ref_m3s;
    window.__qAnnBelow_m3s = q_ref_m3s;
    const fric_ref = frictionPsi_withCML_rheo(TD_DEPTH || 4500);
    const q_ref_gpm = 1000;
    // dP_ref = K_approx * (q_ref_gpm)^n * depth
    // K_approx = dP_ref / (q_ref_gpm^n * depth)
    frictionPsi_fast._K_ref = fric_ref / (Math.pow(q_ref_gpm, n) * (TD_DEPTH || 4500));
  }

  const K_approx = frictionPsi_fast._K_ref || 0.00015; // Fallback

  const dP_psi = K_approx * Math.pow(q_gpm, n) * depth_m;

  return dP_psi;
}

// Calculate BHP at zone with flow split between annulus and fracture
// This is the CORE of the new physics model
function calculateBHPWithLossSplit(zone, qLoss_m3s, qIn_m3s) {
  if (!zone) return 0;

  const depth_m = zone.depth_m;
  const wetTop = annulusTopDepthGlobal();

  // Hydrostatic (only below fluid level)
  const depth_wet = Math.max(0, depth_m - wetTop);
  const ecd_ppg = ecdAtDepth(depth_m);
  const P_hydro = PSI_COEF * ecd_ppg * depth_wet;

  // Split flow
  // PHYSICS: Fluid flows UP from TD (bottom) through annulus to loss zone
  // At loss zone, flow splits:
  //   - qLoss_m3s exits to fracture
  //   - qUp_m3s continues UP to surface
  //
  // qIn_m3s = flow arriving at loss zone from below (flowing UP from TD)
  const qUp_m3s = Math.max(0, qIn_m3s - qLoss_m3s);
  const qFrac_m3s = Math.max(0, qLoss_m3s);

  // Use FAST friction approximations for losses solver iterations
  // This gives ~10x speedup with acceptable accuracy for iterative convergence
  // NOTE: We only need relative changes during iterations, not absolute accuracy

  // Annulus friction (from TD to zone)
  const P_fric_ann = frictionPsi_fast(depth_m, qIn_m3s);

  // Fracture friction (simplified: ~20% of annulus friction)
  const P_fric_frac = frictionPsi_fast(depth_m, qFrac_m3s) * 0.2;

  // SBP (only when riser full)
  const riserFull = (wetTop <= 0.5);
  const P_sbp = (MPD_ON && riserFull) ? (CURRENT_SBP || 0) : 0;

  // BHP = Hydrostatic + Annulus Friction (for qUp only) + Fracture Friction + SBP
  const BHP = P_hydro + P_fric_ann + P_fric_frac + P_sbp;

  return BHP;
}

// Iteratively solve for loss rate where BHP balances at fracture pressure
// OPTIMIZED: Feedforward + reduced iterations + relaxed tolerance
function solveZoneLossEquilibrium(zone, qIn_m3s, dt_s) {
  if (!zone || !zone.enabled) return 0;

  const Pfrac = zone.fracPressure_psi || 0;
  const wetTop = annulusTopDepthGlobal();

  // Zone must be below fluid level
  if (zone.depth_m <= wetTop) return 0;

  // Check static condition (no flow)
  const BHP_static = calculateBHPWithLossSplit(zone, 0, 0);

  // OPTIMIZATION 1: Early exit if far below fracture pressure
  if (BHP_static < Pfrac - LOSS_DEADBAND_PSI) return 0;

  // SPECIAL CASE: Static overbalance
  // User physics: Level only drops if Hyd + ΔP_frac + Friction_going_down > Pfrac
  // Check if we're in static overbalance case (no flow, but pressure > Pfrac)
  if (BHP_static > Pfrac && qIn_m3s < 1e-6) {
    // This means Hyd + SBP > Pfrac with no flow
    // This would cause level to drop, which removes SBP, causing oscillation
    //
    // SOLUTION: Override SBP to anchor at fracture pressure
    // This prevents the drop-lose-SBP-rise-gain-SBP oscillation cycle
    const depth_wet = Math.max(0, zone.depth_m - wetTop);
    const ecd_ppg = ecdAtDepth(zone.depth_m);
    const P_hydro = PSI_COEF * ecd_ppg * depth_wet;

    // Calculate friction of any flow going down (booster during losses)
    // If booster is pumping down, include its friction
    const qDown_m3s = window.__qAnnBelow_m3s || 0;

    // Calculate friction for downward flow
    const qBelow_save = window.__qAnnBelow_m3s;
    window.__qAnnBelow_m3s = qDown_m3s;
    const P_fric_down = qDown_m3s > 1e-6 ? frictionPsi_withCML_rheo(zone.depth_m) : 0;
    window.__qAnnBelow_m3s = qBelow_save;

    // SBP override: balance at Pfrac considering hydrostatic and friction going down
    // Pfrac = P_hydro + P_fric_down + P_sbp
    // P_sbp = Pfrac - P_hydro - P_fric_down - margin
    const SBP_override = Math.max(0, Pfrac - P_hydro - P_fric_down - 50); // 50 psi safety margin

    if (MPD_ON && wetTop <= 0.5) {
      CURRENT_SBP = SBP_override;
    }
    return 0; // No losses needed, system balanced
  }

  // OPTIMIZATION 2: Feedforward - start search near previous result
  const qLoss_prev_m3s = (typeof zone._Q_filt === 'number') ? zone._Q_filt / 15850.323 : 0;

  let qLoss_min, qLoss_max;
  if (qLoss_prev_m3s > 1e-6) {
    // Use previous result as starting point (bracket around it)
    qLoss_min = Math.max(0, qLoss_prev_m3s * 0.3);
    qLoss_max = Math.min(qIn_m3s * 10, qLoss_prev_m3s * 3.0);
  } else {
    // First time or was zero - use wide bracket
    qLoss_min = 0;
    qLoss_max = qIn_m3s * 10;
  }

  let qLoss_result = (qLoss_min + qLoss_max) / 2;

  // OPTIMIZATION 3: Fast iterations with approximation friction
  // Binary search with fast friction converges quickly: 5 iterations = 2^5 = 32x resolution
  // With feedforward and damping, typically converges in 2-3 iterations
  const MAX_ITERATIONS = 5; // Reduced from 6 for performance
  const TOLERANCE_PSI = 40; // Increased for stability - damping/filtering handle precision

  for (let iter = 0; iter < MAX_ITERATIONS; iter++) {
    const qLoss_trial = (qLoss_min + qLoss_max) / 2;
    const BHP = calculateBHPWithLossSplit(zone, qLoss_trial, qIn_m3s);

    if (Math.abs(BHP - Pfrac) < TOLERANCE_PSI) {
      qLoss_result = qLoss_trial;
      break; // OPTIMIZATION 5: Early exit on convergence
    }

    if (BHP > Pfrac) {
      // Pressure too high → need MORE losses to reduce annulus friction
      qLoss_min = qLoss_trial;
    } else {
      // Pressure too low → reduce losses
      // NOTE: This allows RECOVERY from total losses:
      //   - If MW changes (lighter) → BHP drops
      //   - If flow reduces → friction drops → BHP drops
      //   - Solver reduces qLoss → qUp increases → flow resumes to surface
      qLoss_max = qLoss_trial;
    }

    qLoss_result = (qLoss_min + qLoss_max) / 2;
  }

  // Apply zone capacity limit if calibrated
  // NOTE: dP_available uses BHP_static (no losses), so if BHP_static < Pfrac,
  //       capacity = 0, which allows RECOVERY from total losses when BHP drops
  if (zone.Qref_gpm > 0 && zone.DPref_psi > 0) {
    const n = zone.n || 1.0;
    const dP_available = Math.max(0, BHP_static - Pfrac);
    const C_L = zone.Qref_gpm / Math.pow(zone.DPref_psi, n);
    const Q_capacity_gpm = C_L * Math.pow(dP_available, n);
    const Q_capacity_m3s = Q_capacity_gpm / 15850.323;

    qLoss_result = Math.min(qLoss_result, Q_capacity_m3s);
  }

  // STABILITY: Blend with previous solution to reduce oscillation (0.7 = 70% new, 30% old)
  // This provides additional damping on top of the filtering in zoneLoss_gpm
  if (qLoss_prev_m3s > 1e-6) {
    const SOLVER_DAMPING = 0.7; // Tune between 0.5 (heavy damping) and 1.0 (no damping)
    qLoss_result = SOLVER_DAMPING * qLoss_result + (1 - SOLVER_DAMPING) * qLoss_prev_m3s;
  }

  return qLoss_result; // m3/s (recalculated every frame, allows dynamic response)
}

/* ===================== PER-ZONE LOSS (ATTENUATED) ===================== */
// UPDATED: Now uses BHP-based physics with friction redistribution
// Uses iterative solver to find equilibrium where BHP ≈ Pfrac
// Returns gpm.

function zoneLoss_gpm(z, dt_s = 0.1){
  if (!z || !z.enabled || !(z.depth_m > 0)) return 0;

  const wetTop = annulusTopDepthGlobal();

  // Zone must be BELOW fluid level to be active
  if (z.depth_m <= wetTop) {
    z._Q_filt = 0;
    z.Qloss_gpm = 0;
    return 0;
  }

  // ============================================================================
  // NEW PHYSICS: Use iterative equilibrium solver
  // ============================================================================
  const qIn_m3s = ((Q_DS || 0) + (Q_BO || 0) - (Q_CML || 0)) / 15850.323;
  const qLoss_equilibrium_m3s = solveZoneLossEquilibrium(z, qIn_m3s, dt_s);
  const Q_target_gpm = qLoss_equilibrium_m3s * 15850.323;

  // ============================================================================
  // Apply filtering and slew limiting for stability
  // ============================================================================
  z._P_filt = (typeof z._P_filt === 'number') ? z._P_filt : 0;
  z._Q_filt = (typeof z._Q_filt === 'number') ? z._Q_filt : (z.Qloss_gpm || 0);

  const dt = Math.max(1e-3, dt_s);

  // Low-pass filter
  const Q_lpf = __lp(z._Q_filt, Q_target_gpm, dt, LOSS_Q_TAU_S);

  // Slew rate limiter
  const Q_slew = __slew(z._Q_filt, Q_lpf, LOSS_DQDT_MAX_GPM_S, dt);

  z._Q_filt = Math.max(0, Q_slew);
  z.Qloss_gpm = z._Q_filt;

  return z._Q_filt;
}

/* ===================== COUPLED LOSS SOLVER (ATTENUATED) ===================== */
// Iterates with relaxation, uses filtered per-zone losses. Returns total losses (gpm).
function solveCoupledLosses(dt_s = 0.1){
  if (!LOSSES_ON){ (lossZones||[]).forEach(z => { if (z){ z.Qloss_gpm = 0; z._Q_filt = 0; z._P_filt = 0; } }); return 0; }

  mapLossZonesToGrid?.();

  for (let it = 0; it < LOSS_SOLVER_MAX_IT; it++){
    // Recompute section flows (above/below) for friction using current losses
    recomputeAnnulusSectionFlowsForLosses();

    let maxDelta = 0;
    for (const z of (lossZones || [])){
      if (!z || !z.enabled){
        if (z){ z.Qloss_gpm = 0; z._Q_filt = 0; z._P_filt = 0; }
        continue;
      }

      // Attenuated per-zone loss (uses ΔP deadband, LPFs, dQ/dt limiter)
      const Qnew = zoneLoss_gpm(z, dt_s);

      // Iterative relaxation (fixed-point stability)
      const Qupd = z.Qloss_gpm + LOSS_RELAX_PER_ITER * (Qnew - z.Qloss_gpm);
      const clipped = Math.max(0, Qupd);

      maxDelta = Math.max(maxDelta, Math.abs(clipped - z.Qloss_gpm));
      z.Qloss_gpm = clipped;   // published value used by the rest of the sim
      z._Q_filt   = clipped;   // keep filter state coherent with published value
    }

    if (maxDelta < LOSS_SOLVER_TOL_GPM) break;
  }

  // Final pass so the rest of the frame sees consistent section flows
  recomputeAnnulusSectionFlowsForLosses();

  return totalLossRate_gpm(); // gpm
}
// --- helpers used by the filter (place once, near utils) ---
function lp1(prev, x, alpha){ return prev + alpha * (x - prev); }
function slewLimit(prev, target, maxPerSec, dt){
  const maxStep = maxPerSec * dt, d = target - prev;
  return Math.abs(d) <= maxStep ? target : prev + Math.sign(d) * maxStep;
}

// --- filtered loss-demand (define once) ---
function refreshLossDemandFiltered(dt_s){
  if (!LOSSES_ON || !Array.isArray(lossZones)) return;

  const ALPHA = 0.20;      // low-pass weight
  const DQDT_MAX = 600;    // gpm/s per zone

  for (const z of lossZones){
    if (!z || !z.enabled) continue;

    const P  = pressureAtDepth(z.depth_m);
    const dP = Math.max(0, (P - (z.fracPressure_psi||0)) - (LOSS_DEADBAND_PSI||0));
    const n  = (z.n != null ? z.n : 1.0);

    let Qdem_raw_gpm = 0;
    if (z.Qref_gpm > 0 && z.DPref_psi > 0){
      const C = z.Qref_gpm / Math.pow(z.DPref_psi, n);
      Qdem_raw_gpm = C * Math.pow(dP, n);
    } else {
      Qdem_raw_gpm = 1e6; // “infinite”/karst; slew will tame it
    }

    if (typeof z.Qdem_filt_gpm !== 'number') z.Qdem_filt_gpm = 0;

    const Q_lp     = lp1(z.Qdem_filt_gpm, Qdem_raw_gpm, ALPHA);
    const Q_smooth = slewLimit(z.Qdem_filt_gpm, Q_lp, DQDT_MAX, dt_s);

    z.Qdem_filt_gpm = Math.max(0, Q_smooth);
  }
}

// REPLACE the loss zone update section in your main loop/draw:

function updateAllLossZones(dt_s) {
  if (!LOSSES_ON || !lossZones) return;

  // Get active wet zones
  const fluidTop = annulusTopDepthGlobal();
  const activeZones = lossZones
    .filter(z => z && z.enabled && z.depth_m > 0 && z.depth_m > fluidTop)
    .sort((a, b) => a.depth_m - b.depth_m); // SHALLOWEST to DEEPEST for spatial processing

  if (activeZones.length === 0) {
    // All zones dry - decay to zero
    for (const z of lossZones.filter(z => z)) {
      const decay = Math.exp(-dt_s / 2.0);
      z._Q_filt = (z._Q_filt || 0) * decay;
      z._Q_vel = (z._Q_vel || 0) * decay;
      z.Qloss_gpm = z._Q_filt;
    }
    return;
  }

  // Initialize zone states if needed
  for (const z of activeZones) {
    if (typeof z._active === 'undefined') z._active = false;
    if (typeof z._Q_filt === 'undefined') z._Q_filt = 0;
    if (typeof z._Q_vel === 'undefined') z._Q_vel = 0;
  }

  // ========================================================================
  // SPATIAL FLOW ROUTING: Track DS (upward) and Booster (downward) separately
  // ========================================================================
  const Q_DS_gpm = Q_DS || 0;
  const Q_BO_gpm = Q_BO || 0;
  const Q_TF_gpm = (TOPFILL_ON ? Q_TOPFILL : 0) || 0;
  const boosterDown = (fluidTop > 0.5);

  // DS flows UP from TD, so it's available to all zones (processed deepest to shallowest)
  let qDS_remaining = Q_DS_gpm;

  // Booster flows DOWN from BOP, so it's consumed by zones top-to-bottom
  // Only zones BELOW BOP can receive booster flow
  let qBO_remaining = boosterDown ? (Q_BO_gpm + Q_TF_gpm) : 0;

  // Track total loss change for global rate limit
  let totalLossChange_gpm = 0;

  // ========================================================================
  // Process zones from SHALLOW to DEEP (spatial order for downward booster flow)
  // ========================================================================
  for (const z of activeZones) {
    // Calculate zone capacity based on pressure
    const P_psi = pressureAtDepth(z.depth_m);
    const P_frac_psi = z.fracPressure_psi || 0;
    const dP = P_psi - P_frac_psi;

    // === HYSTERESIS: Prevent chattering on/off ===
    if (!z._active) {
      if (dP < LOSS_ACTIVATION_HYST_PSI) {
        z.Qloss_gpm = 0;
        z._Q_filt = 0;
        z._Q_vel = 0;
        continue;
      }
      z._active = true;
    } else {
      if (dP < -LOSS_DEACTIVATION_HYST_PSI) {
        z._active = false;
        const decay = Math.exp(-dt_s / 1.0);
        z._Q_filt *= decay;
        z._Q_vel *= decay;
        z.Qloss_gpm = z._Q_filt;
        continue;
      }
    }

    // === Calculate zone capacity ===
    const n = z.n || 1.0;
    const dP_eff = Math.max(0, dP);

    let Q_capacity_gpm = 0;
    if (z.Qref_gpm > 0 && z.DPref_psi > 0) {
      const C_L = z.Qref_gpm / Math.pow(z.DPref_psi, n);
      Q_capacity_gpm = C_L * Math.pow(dP_eff, n);
    } else {
      Q_capacity_gpm = 10000;  // Karstic (large capacity)
    }

    // === SPATIAL FLOW AVAILABILITY ===
    // Booster can only reach zones BELOW BOP_DEPTH (it flows downward from BOP)
    const zoneCanSeeBooster = (z.depth_m >= BOP_DEPTH);
    const qBoosterAvailable = zoneCanSeeBooster ? qBO_remaining : 0;

    // DS return is available to all zones (flows upward from TD)
    const qDSAvailable = qDS_remaining;

    // Total available to this zone
    const qAvailable_gpm = qBoosterAvailable + qDSAvailable;

    // Target flow limited by capacity and availability
    const Q_target = Math.min(Q_capacity_gpm, qAvailable_gpm);

    // === ACCELERATION LIMITING (prevents spikes) ===
    const Q_current = z._Q_filt || 0;
    const Q_vel_current = z._Q_vel || 0;
    const Q_vel_desired = (Q_target - Q_current) / Math.max(dt_s, 0.01);

    const max_accel = LOSS_MAX_ACCEL_GPM_S2 * dt_s;
    const Q_vel_new = Math.max(
      Q_vel_current - max_accel,
      Math.min(Q_vel_current + max_accel, Q_vel_desired)
    );

    let Q_new = Q_current + Q_vel_new * dt_s;
    Q_new = Math.max(0, Math.min(Q_new, qAvailable_gpm));

    // Track change
    const deltaQ = Math.abs(Q_new - z._Q_filt);
    totalLossChange_gpm += deltaQ;

    // Update zone state
    z._Q_vel = Q_vel_new;
    z._Q_filt = Q_new;
    z.Qloss_gpm = Q_new;

    // === CONSUME FLOW SPATIALLY ===
    // Preferentially consume booster first (if available), then DS
    if (zoneCanSeeBooster && qBO_remaining > 0) {
      const fromBooster = Math.min(Q_new, qBO_remaining);
      qBO_remaining -= fromBooster;
      const fromDS = Q_new - fromBooster;
      qDS_remaining -= fromDS;
    } else {
      // Only DS available
      qDS_remaining -= Q_new;
    }

    // Clamp to zero (avoid numerical errors)
    qBO_remaining = Math.max(0, qBO_remaining);
    qDS_remaining = Math.max(0, qDS_remaining);

    // Early exit if no flow left
    if (qBO_remaining < 0.1 && qDS_remaining < 0.1) break;
  }

  // === GLOBAL RATE LIMIT (prevents total system shock) ===
  if (totalLossChange_gpm > LOSS_GLOBAL_RATE_LIMIT * dt_s) {
    const scale = (LOSS_GLOBAL_RATE_LIMIT * dt_s) / totalLossChange_gpm;
    for (const z of activeZones) {
      if (z.Qloss_gpm > 0) {
        const oldQ = z._Q_filt;
        z._Q_filt = oldQ * scale;
        z.Qloss_gpm = z._Q_filt;
      }
    }
  }

  // Dry zones (above fluid level) - decay to zero
  for (const z of lossZones.filter(z => z && z.enabled && z.depth_m <= fluidTop)) {
    const decay = Math.exp(-dt_s / 2.0);
    z._Q_filt = (z._Q_filt || 0) * decay;
    z._Q_vel = (z._Q_vel || 0) * decay;
    z.Qloss_gpm = z._Q_filt;
  }
}


// Call this INSTEAD OF individual zoneLoss_gpm calls:
// In your main loop, REPLACE:
//   for (const z of lossZones) { z.Qloss_gpm = zoneLoss_gpm(z, dt); }
// WITH:
//   updateAllLossZones(dt);
/* ===================== TOTAL & EXTRA ===================== */
function totalLossRate_gpm(){ return (lossZones || []).reduce((s,z)=>s+(z.Qloss_gpm||0),0); }
function totalLossDemand_m3s(){
  if (!LOSSES_ON || !lossZones) return 0;

  let demand_gpm = 0;

  for (const z of lossZones){
    if (!z || !z.enabled || !(z.depth_m > 0)) continue;

    // Skip dry zones
    const top = (typeof annulusTopDepthGlobal === 'function') ? annulusTopDepthGlobal() : 0;
    if (z.depth_m <= top) continue;

    const P_psi      = pressureAtDepth(z.depth_m);
    const P_frac_psi = z.fracPressure_psi || 0;
    const dP         = Math.max(0, P_psi - P_frac_psi - (LOSS_DEADBAND_PSI || 0));

    // Demand capacity based on injectivity (no qAvailable clamp)
    const n = z.n || 1.0;
    if (z.Qref_gpm > 0 && z.DPref_psi > 0){
      const C_L = z.Qref_gpm / Math.pow(z.DPref_psi, n);
      demand_gpm += C_L * Math.pow(dP, n);
    } else {
      // Karstic/infinite – set a large number so deficit is driven by supply
      demand_gpm += 1e9; // effectively unbounded
    }
  }

  return demand_gpm / 15850.323; // -> m³/s
}

// Composition-aware extraction at zone cell (called inside advection step)
// Replace extractLossFluidFromGrid with this improved version:
function extractLossFluidFromGrid(z, dt_s){
  if (!z.enabled || z.cellIdx < 0 || z.Qloss_gpm <= 0) return;
  
  const Q_m3s = z.Qloss_gpm / 15850.323;
  const Vloss = Q_m3s * dt_s;
  
  let A = 0, grid = null;
  if (z.section === 'riser'){ 
    A = A_riserAnn(); 
    grid = annAboveGrid; 
  } else if (z.section === 'casing'){ 
    A = A_casingAnn(); 
    grid = annBelowGrid; 
  } else { 
    A = A_openAnn(); 
    grid = annBelowGrid;
  }

  if (!grid || !grid.length) return;
  
  const i = Math.min(Math.max(0, z.cellIdx), grid.length-1);
  const Vcell = A * CELL_M;
  const fractionLost = Math.min(0.95, Vloss / Math.max(Vcell, 1e-9));

  // ✅ Extract fluid from this specific cell only
  // The lost fluid "disappears" - reduce density slightly toward lighter neighbor
  // This simulates the cell partially draining
  const upwindIdx = Math.max(0, i - 1); // Fluid comes from below
  
  // Weighted average: keep most of current, blend slightly with upwind
  grid[i] = (1 - fractionLost * 0.5) * grid[i] + (fractionLost * 0.5) * grid[upwindIdx];
  
  // ✅ The flow rate reduction is already handled in recomputeAnnulusSectionFlowsForLosses()
  // so the advection above this zone will automatically slow down
}

function effective_Q_CML_gpm(){
  if (!CML_ON) return 0;
  const intakeDepth = CML_DEPTH || 0;
  const annulusTop = annulusTopDepthGlobal();
  if (intakeDepth <= annulusTop) return 0; // intake “in air”
  return Q_CML || 0;
}


function computeFlowOut_gpm(dt_s) {
  const top = annulusTopDepthGlobal();
  const riserAtSurface = (top <= 0.5);
  const riserAboveBOP = (top < BOP_DEPTH);
  const lossesActive = LOSSES_ON && totalLossRate_gpm() > 1.0;

  // ============================================================================
  // CRITICAL: 4-Layer FO Protection (from commit 19d8516)
  // ============================================================================

  // Check 1: Active losses and level not at surface → FO must be zero
  if (lossesActive && !riserAtSurface) {
    FLOW_OUT_gpm = 0;
    FLOWOUT_VELOCITY_gpm_s = 0;
    return 0;
  }

  // Check 2: Level below BOP → no returns possible
  if (!riserAboveBOP) {
    FLOW_OUT_gpm = 0;
    FLOWOUT_VELOCITY_gpm_s = 0;
    return 0;
  }

  // Check 3: If losses consuming >50% of flow → FO must be zero
  const totalIn_gpm = (Q_DS || 0) + (Q_BO || 0);
  const lossRate_gpm = totalLossRate_gpm();
  if (lossRate_gpm > totalIn_gpm * 0.5) {
    FLOW_OUT_gpm = 0;
    FLOWOUT_VELOCITY_gpm_s = 0;
    return 0;
  }

  // Riser above BOP and no significant losses - calculate target
  // FIX: Use correct variable name - recomputeAnnulusSectionFlowsForLosses publishes to __qAnnAbove_m3s
  const qAnnUp_m3s = window.__qAnnAbove_m3s || 0;

  // Check 4: Sanity check on qAnnUp itself
  if (qAnnUp_m3s < 1e-9) {
    FLOW_OUT_gpm = 0;
    FLOWOUT_VELOCITY_gpm_s = 0;
    return 0;
  }

  let targetFO_gpm = qAnnUp_m3s * 15850.323;

  // CRITICAL SANITY CHECK: FO cannot exceed total inflow (reduced from 1.5x to 1.2x)
  const totalInflow_gpm = totalIn_gpm;
  const maxReasonableFO_gpm = totalInflow_gpm * 1.2;
  if (targetFO_gpm > maxReasonableFO_gpm) {
    console.warn(`FO explosion detected! targetFO=${targetFO_gpm.toFixed(0)} gpm, clamping to ${maxReasonableFO_gpm.toFixed(0)} gpm. qAnnUp=${qAnnUp_m3s.toFixed(4)}, loss=${lossRate_gpm.toFixed(0)}`);
    targetFO_gpm = maxReasonableFO_gpm;
  }
  
  // Current state
  const FO_current = FLOW_OUT_gpm || 0;
  const FO_vel_current = FLOWOUT_VELOCITY_gpm_s || 0;
  
  // Apply deadband
  const error = targetFO_gpm - FO_current;
  if (Math.abs(error) < FLOWOUT_DEADBAND_GPM) {
    // In deadband - decay velocity
    FLOWOUT_VELOCITY_gpm_s *= 0.95;
    FLOW_OUT_gpm += FLOWOUT_VELOCITY_gpm_s * dt_s;
    return FLOW_OUT_gpm;
  }
  
  // Desired velocity (with LPF)
  const tau = FLOWOUT_LPF_TAU;
  const alpha = Math.min(1.0, dt_s / (tau + dt_s));
  const FO_vel_desired = error / tau;
  
  // Acceleration limit
  const max_accel = FLOWOUT_MAX_ACCEL * dt_s;
  const FO_vel_new = Math.max(
    FO_vel_current - max_accel,
    Math.min(FO_vel_current + max_accel, FO_vel_desired)
  );
  
  // Integrate
  FLOWOUT_VELOCITY_gpm_s = FO_vel_new;
  FLOW_OUT_gpm = Math.max(0, FO_current + FO_vel_new * dt_s);
  
  // Optional smooth
  if (typeof FLOW_OUT_ALPHA === 'number') {
    window.FLOW_OUT_smooth = (window.FLOW_OUT_smooth || 0) + 
      FLOW_OUT_ALPHA * (FLOW_OUT_gpm - (window.FLOW_OUT_smooth || 0));
  }
  
  return FLOW_OUT_gpm;
}
// Run the coupled loss solver and get instantaneous losses (gpm)


function chokeCv(pct){
  const p = Math.max(0, Math.min(1, pct/100));
  return CHOKE_CV_MAX * (1 - Math.exp(-CHOKE_K * p)) / (1 - Math.exp(-CHOKE_K));
}
function updateChokeFromFO(){
  if (!MPD_ON || FLOW_OUT_gpm < 1 || CURRENT_SBP < 1){ CHOKE_POS_pct = 0; return 0; }
  const SG = rhoDynamic()/1000;
  const Cv_req = FLOW_OUT_gpm / Math.sqrt(Math.max(CURRENT_SBP/Math.max(SG,0.7), 1e-6));
  let best = 0;
  for (let p=0; p<=100; p+=0.5){ if (chokeCv(p) >= Cv_req){ best = p; break; } }
  if (chokeCv(100) < Cv_req) best = 100;
  CHOKE_POS_pct = 0.85*CHOKE_POS_pct + 0.15*best;
  return CHOKE_POS_pct;
}

 // === LEVEL / MASS-BALANCE CORE (drop-in) ===
// Drives ANN_TOP_DEPTH_m using inflows, top fill, CML, surface outflow,
// *and* loss demand that can exceed inflow (deficit drains the annulus).

// Helper: area at the current free surface (uses your existing A_* funcs)
function annulusAreaAtTop(){
  const top = annulusTopDepthGlobal ? annulusTopDepthGlobal() : (LOSS_TOP_DEPTH_m || 0);
  if (top <= BOP_DEPTH)  return A_riserAnn();
  if (top <= SHOE_DEPTH) return A_casingAnn();
  return A_openAnn();
}

// --- Simple exponential low-pass (single-pole): y += a*(x - y), a in (0,1]
function lp1(prev, x, alpha){ return prev + alpha * (x - prev); }

// --- Slew limiter (caps rate of change): max |Δ per second|
function slewLimit(prev, target, maxPerSec, dt){
  const maxStep = maxPerSec * dt;
  const d = target - prev;
  if (Math.abs(d) <= maxStep) return target;
  return prev + Math.sign(d) * maxStep;
}


// ---- DROP-IN: replace your current updateRiserLevelWithLosses entirely ----

// DROP-IN: complete, self-contained, robust
// ---------------------------------------------------------------------------
// Recompute annulus section flows (above-BOP & below-BOP) + FLOW_OUT with
// hysteresis and smoothing to prevent 600↔0 ping-pong.
// Call this once per sub-iteration, *before* pressure/friction calls.
// Requires: GPM_PER_M3S, annulusTopDepthGlobal(), totalLossDemand_m3s()
// Publishes: window.__qAnnAbove_m3s, window.__qAnnBelow_m3s, window.__qBelowIsDownward
//            and updates FLOW_OUT_gpm via low-pass + slew.
// ---------------------------------------------------------------------------
function recomputeAnnulusSectionFlowsForLosses(dt_s){
  const M3_PER_GPM = 1/15850.323;

  // Inflows that truly enter annulus "bucket"
  const qIn_m3s      = ((Q_DS||0) + (Q_BO||0)) * M3_PER_GPM;
  const qTopFill_m3s = (TOPFILL_ON ? (Q_TOPFILL||0) : 0) * M3_PER_GPM;
  const qCML_m3s     = (typeof effective_Q_CML_gpm==='function' ? (effective_Q_CML_gpm()||0) : 0) * M3_PER_GPM;

  // Use *filtered* demand if you added it; else sum actuals
  const qDem_m3s = (typeof totalLossDemand_m3s==='function') ? totalLossDemand_m3s() :
                   ((typeof totalLossRate_gpm==='function' ? totalLossRate_gpm() : 0) * M3_PER_GPM);

  // Net available to annulus after CML (before losses)
  const qAvail_m3s = Math.max(0, qIn_m3s + qTopFill_m3s - qCML_m3s);

  // Split into sections: below BOP consumes losses first (dominant sink)
  // Whatever demand can't be met (deficit) will pull the level down.
  const qBelow_m3s = Math.min(qDem_m3s, qAvail_m3s);         // what actually goes down to loss zone
  const qAbove_m3s = (qIn_m3s + qTopFill_m3s - qCML_m3s) - qBelow_m3s; // remainder goes up the riser

  // Publish section flows (using both new and old variable names for compatibility)
  window.__qAnnBelow_m3s   = qBelow_m3s;
  window.__qAnnAbove_m3s   = qAbove_m3s;
  window.__qAnnDown_m3s    = qBelow_m3s;  // Compatibility alias for advection code
  window.__qAnnUp_m3s      = qAbove_m3s;  // Compatibility alias for advection code
  window.__qBelowIsDownward = true; // sign convention handled in friction function

  // NOTE: FLOW_OUT_gpm calculation REMOVED from this function!
  // FO is now calculated ONLY in routeAnnulusFlowsWithLosses() which has:
  //   - Adaptive filter (fast when no losses)
  //   - Adaptive slew rate (5000 gpm/s when no losses)
  //   - Proper booster routing logic
  //
  // This function should ONLY publish section flows for friction calculations.
  // DO NOT add FLOW_OUT_gpm calculation here - it causes conflicts and slow response!
}


// REPLACE updateRiserLevelWithLosses() with rate-limited version
// ============================================================================

function updateRiserLevelWithLosses(dt_s) {
  // ========================================================================
  // SPATIAL MASS BALANCE SOLVER
  // Handles multiple fluid sections with different densities and flow directions
  // ========================================================================
  const GPM_PER_M3S = 15850.323;
  const to_m3s = (gpm) => (gpm || 0) / GPM_PER_M3S;

  const qDS_m3s = to_m3s(Q_DS || 0);
  const qBO_m3s = to_m3s(Q_BO || 0);
  const qTF_m3s = TOPFILL_ON ? to_m3s(Q_TOPFILL || 0) : 0;
  const qCML_m3s = to_m3s(effective_Q_CML_gpm() || 0);

  // Get active loss zones sorted by depth (deepest first)
  const activeLossZones = (LOSSES_ON && Array.isArray(lossZones))
    ? lossZones.filter(z => z && z.enabled && (z.Qloss_gpm || 0) > 1.0).sort((a,b) => b.depth_m - a.depth_m)
    : [];

  const topDepthNow = LOSS_TOP_DEPTH_m || 0;
  const riserIsNotFull = topDepthNow > 0.5;
  const qOutSurface_m3s = riserIsNotFull ? 0 : to_m3s(FLOW_OUT_gpm || 0);

  // ========================================================================
  // SPATIAL SECTION ANALYSIS
  // ========================================================================

  if (activeLossZones.length === 0) {
    // NO ACTIVE LOSSES: Simple global mass balance
    const qIn_total = qDS_m3s + qBO_m3s + qTF_m3s - qCML_m3s;
    const qOut_total = qOutSurface_m3s;
    const qNet = qIn_total - qOut_total;

    let dV = qNet * dt_s;
    let newTop = topDepthNow;

    // Move level up/down
    let guard = 0;
    while (Math.abs(dV) > 1e-12 && guard++ < 4) {
      const A = Math.max(areaAtDepthTop_(newTop), 1e-12);
      const dH = dV / A;
      newTop = clamp(newTop - dH, 0, TD_DEPTH);

      // Check boundary crossing
      const nextBoundary = (dH < 0) ? nextBoundaryAfter_(newTop, false) : nextBoundaryAfter_(newTop, true);
      if (Math.abs(newTop - nextBoundary) < 0.1) {
        const dV_toBoundary = A * Math.abs(newTop - nextBoundary);
        if (Math.abs(dV) > dV_toBoundary) {
          dV -= (dH < 0 ? -dV_toBoundary : dV_toBoundary);
          newTop = nextBoundary;
        } else {
          break;
        }
      } else {
        break;
      }
    }

    // Rate limiting
    const deltaTop = newTop - topDepthNow;
    const maxChange = (deltaTop < 0 ? LEVEL_MAX_DROP_RATE_M_S : LEVEL_MAX_RISE_RATE_M_S) * dt_s;
    newTop = topDepthNow + clamp(deltaTop, -maxChange, maxChange);

    LOSS_TOP_DEPTH_m = clamp(newTop, 0, TD_DEPTH);
    if (typeof ANN_TOP_DEPTH_m !== 'undefined') ANN_TOP_DEPTH_m = LOSS_TOP_DEPTH_m;
    return;
  }

  // ========================================================================
  // WITH ACTIVE LOSSES: Spatial mass balance
  // ========================================================================

  // The deepest active loss zone determines the lower boundary
  const deepestLossZone = activeLossZones[0];
  const deepestLossDepth = deepestLossZone.depth_m;

  // Below deepest loss zone: Always full (DS fluid enters at TD, flows up)
  // At loss zones: Fluid exits spatially
  // Above highest loss zone: Calculate fluid top

  // Total losses
  const qLoss_total_m3s = activeLossZones.reduce((sum, z) => sum + to_m3s(z.Qloss_gpm || 0), 0);

  // Net flow above the deepest loss zone
  // If all fluid exits at losses, nothing reaches surface
  const qReachingSurface = Math.max(0, qDS_m3s + qBO_m3s + qTF_m3s - qCML_m3s - qLoss_total_m3s);
  const qNet_above = qReachingSurface - qOutSurface_m3s;

  // Calculate new fluid top
  let dV_above = qNet_above * dt_s;
  let newTop = topDepthNow;

  // If losses consume everything, fluid top should drop towards highest loss zone
  if (qLoss_total_m3s >= (qDS_m3s + qBO_m3s + qTF_m3s - qCML_m3s)) {
    // Find highest active loss zone
    const highestLossZone = activeLossZones[activeLossZones.length - 1];
    const targetTop = highestLossZone.depth_m;

    // Move towards target
    const deltaToTarget = targetTop - topDepthNow;
    const moveRate = Math.min(LEVEL_MAX_DROP_RATE_M_S * dt_s, Math.abs(deltaToTarget));
    newTop = topDepthNow + (deltaToTarget > 0 ? moveRate : -moveRate);
  } else {
    // Some fluid reaches surface, use volumetric balance
    let guard = 0;
    while (Math.abs(dV_above) > 1e-12 && guard++ < 4) {
      const A = Math.max(areaAtDepthTop_(newTop), 1e-12);
      const dH = dV_above / A;
      const proposedTop = newTop - dH;

      // Don't go below highest loss zone
      const highestLossDepth = activeLossZones[activeLossZones.length - 1].depth_m;
      newTop = Math.max(0, Math.min(proposedTop, TD_DEPTH));

      if (newTop > highestLossDepth) {
        newTop = proposedTop;
        break;
      } else {
        newTop = highestLossDepth;
        break;
      }
    }

    // Rate limiting
    const deltaTop = newTop - topDepthNow;
    const maxChange = (deltaTop < 0 ? LEVEL_MAX_DROP_RATE_M_S : LEVEL_MAX_RISE_RATE_M_S) * dt_s;
    newTop = topDepthNow + clamp(deltaTop, -maxChange, maxChange);
  }

  LOSS_TOP_DEPTH_m = clamp(newTop, 0, TD_DEPTH);
  if (typeof ANN_TOP_DEPTH_m !== 'undefined') ANN_TOP_DEPTH_m = LOSS_TOP_DEPTH_m;

  // Diagnostics
  if (typeof window !== 'undefined') {
    window.qResid_gpm = qNet_above * GPM_PER_M3S;
  }
}

// Helper functions for level solver
function areaAtDepthTop_(d) {
  if (d <= BOP_DEPTH) return A_riserAnn();
  if (d <= SHOE_DEPTH) return A_casingAnn();
  return A_openAnn();
}

function nextBoundaryAfter_(d, goingUp) {
  if (goingUp) {
    if (d > SHOE_DEPTH) return SHOE_DEPTH;
    if (d > BOP_DEPTH) return BOP_DEPTH;
    return 0;
  } else {
    if (d < BOP_DEPTH) return BOP_DEPTH;
    if (d < SHOE_DEPTH) return SHOE_DEPTH;
    return TD_DEPTH;
  }
}


function equilibrateFluidLevel(dt_s, maxIterations = 5) {
  const M3_PER_GPM = 1 / 15850.323;
  const dt_sub = dt_s / Math.max(1, maxIterations);

  for (let i = 0; i < maxIterations; i++) {
    // 1) Zones: compute ΔP, capacity, and per-zone actual qLoss_gpm
    updateAllLossZones(dt_sub); // produces z.qLoss_gpm and window.sumLoss_gpm

    // 2) Smooth/slew the DEMAND used by mass-balance (if present)
    if (typeof refreshLossDemandFiltered === 'function') {
      refreshLossDemandFiltered(dt_sub);
    }

    // 3) Route flows so friction/advection know directions & returns are stable
    if (typeof routeAnnulusFlowsWithLosses === 'function') {
      routeAnnulusFlowsWithLosses(dt_sub); // publishes __qAnnUp_m3s, __qAnnDown_m3s, smooth FLOW_OUT_gpm
    } else if (typeof recomputeAnnulusSectionFlowsForLosses === 'function') {
      // Backward-compatible: if you kept the older helper name
      recomputeAnnulusSectionFlowsForLosses(dt_sub);
    }

    // (Your friction/advection step should read __qAnnUp_m3s / __qAnnDown_m3s and wet lengths)

    // 4) Level solver: hybrid (actual zone outflow + demand deficit)
    updateRiserLevelWithLosses(dt_sub);

    // 5) Optional early-exit (demand ≈ available supply)
    const qIn_m3s = (
      ((Q_DS || 0) + (Q_BO || 0)) * M3_PER_GPM
      + (TOPFILL_ON ? (Q_TOPFILL || 0) * M3_PER_GPM : 0)
    );
    const qDemand_m3s = (typeof totalLossDemand_m3s === 'function')
      ? totalLossDemand_m3s()
      : ((typeof totalLossRate_gpm === 'function' ? totalLossRate_gpm() : 0) * M3_PER_GPM);

    const eps = Math.max(1e-6, 0.02 * Math.max(qIn_m3s, 1e-3)); // ~2% band
    if (Math.abs(qDemand_m3s - qIn_m3s) <= eps) break;
  }
}



// ---------------------------------------------------------------------------
// Recompute effective annulus section flows (above-BOP and below-BOP) 
// given current losses, CML intake, and whether the riser is dry.
// Publishes window.__qAnnAbove_m3s and window.__qAnnBelow_m3s for friction.
// NOTE: Duplicate function definition removed - using comprehensive version at line ~2510
// with FO protection and friction redistribution for losses physics

function safeRheoVal(key, def){
  const el = rheoPanel && rheoPanel[key];
  return (el && typeof el.value === 'function') ? num(el.value()) : def;
}
// --- U-tube helper (riser leg: surface -> pump depth) ---
function dPperM_riserLeg_forUTube(Q, dTop, dPump){
  // use the same riser annulus model, but only the wet span (surface→top is "dry")
  const L = Math.max(0, Math.min(BOP_DEPTH, dPump) - Math.max(0, dTop));
  if (L <= 0) return 0;
  // Use your existing function for the riser section at current total annulus flow
  return dPperM_riserAnnulus(Q);
}
// Linearized hydraulic resistance of the leg (psi per m³/s)
function riserLegResistancePsiPer_m3s(dTop, dPump){
  const L = Math.max(0, Math.min(BOP_DEPTH, dPump) - Math.max(0, dTop));
  if (L <= 0) return 1e9; // practically infinite (no wet column)
  // Evaluate slope around a small reference flow through the leg
  const qRef = (Q_REF/15850.323); // m³/s
  const dpdl_Pa = dPperM_riserLeg_forUTube(qRef, dTop, dPump); // Pa/m
  const dp_Pa = dpdl_Pa * L; // Pa
  const dp_psi = dp_Pa * PSI_PER_PASCAL; // psi
  // "resistance" R = ΔP / Q (psi per m³/s)
  return Math.max(dp_psi / Math.max(qRef, 1e-9), 1); // avoid tiny values
}
// --- Visual column helpers (ADD near other helpers) ---

// Minimal fallback line plotter for the active time-chart panel.
// Assumes you have a current chart rect and transforms already set.
// If not, it draws in normalized screen space at top-left  (safe default).
function plotTimeSeriesLine(series, ymin, ymax, strokeCol) {
  if (!series || !series.length) return;
  push();
  if (strokeCol) stroke(strokeCol); else stroke(255);
  noFill();
  beginShape();
  // Draw left-to-right with newest at left (index 0)
  const N = series.length;
  for (let i = 0; i < N; i++) {
    const x = map(i, 0, N-1, 10, 10 + Math.min(width-20, 600));  // fallback width 600
    const yVal = constrain(series[i], ymin, ymax);
    const y = map(yVal, ymin, ymax, 10 + 100, 10);                // fallback height 100
    vertex(x, y);
  }
  endShape();
  pop();
}


function clipFillY_forRiser(){
  const wetTop = riserTopDepth(); // 0..BOP
  return mapDepthToY(wetTop);
}
function clipFillY_forDS(){
  const dsTop = clamp(levelDeficit_m, 0, TD_DEPTH);
  return mapDepthToY(dsTop);
}
function clipFillY_forBooster(){
  const boTop = clamp(levelDeficit_bo_m, 0, BOP_DEPTH);
  return mapDepthToY(boTop);
}
// --- CML visual helpers (ADD near mapDepthToY / riserTopDepth) ---
function cmlPumpY() {
  // clamp to riser leg interval (0..BOP_DEPTH)
  const d = clamp(CML_DEPTH || 0, 0, BOP_DEPTH);
  return mapDepthToY(d);
}
// ============================ RHEOLOGY CORE ============================
function getRheoForCalc(){
  let K, n, tauY;
  if (ACTIVE_RHEO_MODEL === "Bingham"){
    K = Math.max(fitParams.mu_p_Pa_s || 0, 1e-6);
    n = 1.0;
    tauY = Math.max(fitParams.tau_y_Pa || 0, 0);
  } else if (ACTIVE_RHEO_MODEL === "PowerLaw"){
    K = Math.max(fitParams.K_PL_Pa_s_n || 0.05, 1e-6);
    n = clamp(fitParams.n_PL ?? 0.9, 0.25, 1.0);
    tauY = 0;
  } else { // HB
    K = Math.max(fitParams.K_HB_Pa_s_n || 0.05, 1e-6);
    n = clamp(fitParams.n_HB ?? 0.9, 0.25, 1.0);
    tauY = Math.max(fitParams.tau_y_HB_Pa || 0, 0);
  }
  return { K, n, tauY };
}
// Rheology fitting functions
function collectRheoPoints(){
  const rVal = (key, def) => {
    const el = rheoPanel && rheoPanel[key];
    if (el && typeof el.value === 'function') return num(el.value());
    return def;
  };
  const rows = [
    { rpm: 600, dial: rVal('R600', rheoDefaults.R600) },
    { rpm: 300, dial: rVal('R300', rheoDefaults.R300) },
    { rpm: 200, dial: rVal('R200', rheoDefaults.R200) },
    { rpm: 100, dial: rVal('R100', rheoDefaults.R100) },
    { rpm: 6, dial: rVal('R6', rheoDefaults.R6) },
    { rpm: 3, dial: rVal('R3', rheoDefaults.R3) },
    { rpm: 1, dial: rVal('R1', rheoDefaults.R1) },
  ].filter(r => r.dial > 0);
  return rows.map(r => {
    const gdot = 1.703 * r.rpm; // s^-1
    const tauPa = r.dial * LBF100FT2_to_Pa; // Pa
    return { gdot, tauPa, rpm: r.rpm, dial: r.dial };
  });
}
function fitBingham(pts){
  let Sx=0, Sy=0, Sxx=0, Sxy=0, n=0;
  for (const p of pts){
    const x=p.gdot, y=p.tauPa;
    Sx+=x; Sy+=y; Sxx+=x*x; Sxy+=x*y; n++;
  }
  if (n<2){ return {mu_p:null, tau_y:null, sse:Infinity}; }
  const denom = (n*Sxx - Sx*Sx) || 1e-12;
  const b = (n*Sxy - Sx*Sy)/denom; // μp
  const a = (Sy - b*Sx)/n; // τy
  let sse=0;
  for(const p of pts){
    const yhat=a+b*p.gdot;
    sse+=(p.tauPa-yhat)**2;
  }
  return { mu_p: Math.max(b,0), tau_y: Math.max(a,0), sse };
}
function fitPowerLaw(pts){
  let Sx=0, Sy=0, Sxx=0, Sxy=0, n=0;
  for(const p of pts){
    if (p.tauPa<=0 || p.gdot<=0) continue;
    const x=Math.log(p.gdot), y=Math.log(p.tauPa);
    Sx+=x; Sy+=y; Sxx+=x*x; Sxy+=x*y; n++;
  }
  if (n<2){ return {K:null, n:null, sse:Infinity}; }
  const denom=(n*Sxx - Sx*Sx) || 1e-12;
  const n_pl=(n*Sxy - Sx*Sy)/denom;
  const logK=(Sy - n_pl*Sx)/n;
  const K=Math.exp(logK);
  let sse=0;
  for(const p of pts){
    if (p.tauPa<=0 || p.gdot<=0) continue;
    const yhat=Math.log(K) + n_pl*Math.log(p.gdot);
    sse+=(Math.log(p.tauPa)-yhat)**2;
  }
  return {K, n: n_pl, sse};
}
function fitHB(pts){
  const taus = pts.map(p => p.tauPa);
  const tauMin = 0;
  const tauMax = Math.max(...taus) * 0.9;
  let best = { tau_y:null, K:null, n:null, sse:Infinity };
  const coarseSteps = 60; // coarse sweep
  for (let i=0; i<=coarseSteps; i++){
    const tau_y = tauMin + (tauMax - tauMin) * i / coarseSteps;
    const res = [];
    for (const p of pts){
      const tr = p.tauPa - tau_y;
      if (tr > 0 && p.gdot > 0) res.push({ gdot:p.gdot, tauR:tr, rpm:p.rpm });
    }
    if (res.length < 2) continue;
    let Sx=0, Sy=0, Sxx=0, Sxy=0, n=0;
    for (const r of res){
      const x=Math.log(r.gdot), y=Math.log(r.tauR);
      Sx+=x; Sy+=y; Sxx+=x*x; Sxy+=x*y; n++;
    }
    const denom = (n*Sxx - Sx*Sx) || 1e-12;
    const nHB = (n*Sxy - Sx*Sy)/denom;
    const logK = (Sy - nHB*Sx)/n;
    const KHB = Math.exp(logK);
    // mild weighting for low-shear points (stabilizes τy)
    let sse=0;
    for (const p of pts){
      const pred = tau_y + KHB*Math.pow(p.gdot, nHB);
      const w = (p.rpm <= 100) ? 1.5 : 1.0;
      sse += w * Math.pow(p.tauPa - pred, 2);
    }
    if (sse < best.sse) best = { tau_y, K:KHB, n:nHB, sse };
  }
  // local refine around best
  if (isFinite(best.sse) && best.tau_y != null){
    const t0 = best.tau_y;
    const lo = Math.max(0, t0*0.8), hi = t0*1.2;
    for (let i=0; i<=60; i++){
      const tau_y = lo + (hi-lo)*i/60;
      const res = [];
      for (const p of pts){
        const tr = p.tauPa - tau_y;
        if (tr>0 && p.gdot>0) res.push({ gdot:p.gdot, tauR:tr, rpm:p.rpm });
      }
      if (res.length < 2) continue;
      let Sx=0, Sy=0, Sxx=0, Sxy=0, n=0;
      for (const r of res){
        const x=Math.log(r.gdot), y=Math.log(r.tauR);
        Sx+=x; Sy+=y; Sxx+=x*x; Sxy+=x*y; n++;
      }
      const denom=(n*Sxx - Sx*Sx) || 1e-12;
      const nHB=(n*Sxy - Sx*Sy)/denom;
      const logK=(Sy - nHB*Sx)/n;
      const KHB=Math.exp(logK);
      let sse=0;
      for (const p of pts){
        const pred = tau_y + KHB*Math.pow(p.gdot, nHB);
        const w = (p.rpm <= 100) ? 1.5 : 1.0;
        sse += w * Math.pow(p.tauPa - pred, 2);
      }
      if (sse < best.sse) best = { tau_y, K:KHB, n:nHB, sse };
    }
  }
  return best;
}
function doRheologyFit(){
  const pts = collectRheoPoints();
  if (!pts.length){
    rheoPanel.statusDiv.html("No rheology points provided.");
    return;
  }


  // Direct Bingham if PV/YP are provided and Bingham is selected
 const PVcp = safeRheoVal('PV', 0); // cP
 const YPlbf = safeRheoVal('YP', 0); // lbf/100ft²
  const usePVYP = (ACTIVE_RHEO_MODEL === "Bingham") && (PVcp > 0 || YPlbf > 0);


  let b, p, h;
  if (usePVYP){
    b = { mu_p: PVcp * 1e-3, // Pa·s
         tau_y: YPlbf * LBF100FT2_to_Pa, // Pa
         sse: 0 };
  } else {
    b = fitBingham(pts);
  }
  p = fitPowerLaw(pts);
  h = fitHB(pts);

  fitParams.mu_p_Pa_s = b.mu_p ?? fitParams.mu_p_Pa_s;
  fitParams.tau_y_Pa = b.tau_y ?? fitParams.tau_y_Pa;
  fitParams.K_PL_Pa_s_n = p.K;
  fitParams.n_PL = p.n;
  fitParams.K_HB_Pa_s_n = h.K;
  fitParams.n_HB = h.n;
  fitParams.tau_y_HB_Pa = h.tau_y;

  publishRheoToGlobals()

  // gel from 10s if provided
const g10s = safeRheoVal('G10s', rheoDefaults.G10s ?? 0);
if (g10s > 0) gel_Pa = g10s * LBF100FT2_to_Pa;
  const srcNote = usePVYP ? "Bingham (PV/YP direct)" : "Bingham (regressed)";
  rheoPanel.statusDiv.html(
    `Fit OK <br> ${srcNote} <br> Bingham SSE=${(b.sse??0).toFixed(3)} <br>
PL SSE=${(p.sse??0).toFixed(3)} HB SSE=${(h.sse??0).toFixed(3)}`
  );
}
function showFittedParams(){
  const s = (v, d=4) => (v == null ? "—" : Number(v).toFixed(d));
  const msg = `
    Model = ${ACTIVE_RHEO_MODEL}<br>
    + Bingham: μp = ${s(fitParams.mu_p_Pa_s)} Pa·s; τy = ${s(fitParams.tau_y_Pa)} Pa<br>
    + Power-Law: K = ${s(fitParams.K_PL_Pa_s_n)} Pa·s^n; n = ${s(fitParams.n_PL)}<br>
    + HB: K = ${s(fitParams.K_HB_Pa_s_n)} Pa·s^n; n = ${s(fitParams.n_HB)}; τy = ${s(fitParams.tau_y_HB_Pa)} Pa;
  `;
  rheoPanel.statusDiv.html(msg);
}

// --- Global annulus top (can drop below BOP due to losses) ---
function annulusTopDepthGlobal(){
  // Returns the PHYSICAL top of fluid column (deepest of all constraints)
  
  let top = 0;
  
  // CML contribution
  if (CML_ON && typeof CML_TOP_DEPTH === 'number') {
    top = Math.max(top, CML_TOP_DEPTH);
  }
  
  // Loss contribution
  if (LOSSES_ON && typeof LOSS_TOP_DEPTH_m === 'number') {
    top = Math.max(top, LOSS_TOP_DEPTH_m);
  }
  
  // ✅ CRITICAL FIX: When BOTH are active, they should converge
  // If losses are occurring, LOSS_TOP_DEPTH_m is the TRUE physical boundary
  if (LOSSES_ON && totalLossRate_gpm() > 0) {
    // Loss-driven top takes precedence
    top = LOSS_TOP_DEPTH_m;
    
    // Sync CML to match (they should be the same in steady state)
    if (CML_ON && Math.abs(CML_TOP_DEPTH - LOSS_TOP_DEPTH_m) > 0.1) {
      CML_TOP_DEPTH = LOSS_TOP_DEPTH_m; // Force sync
    }
  }
  
  return top;
}

// ================== CML level update + simple controller ==================

function computeImbalanceFlows(){
  const fluidTop = annulusTopDepthGlobal();
  
  // Heights of wet fluid columns
  const H_riser = Math.max(BOP_DEPTH - fluidTop, 0);
  const H_below = Math.max(TD_DEPTH - Math.max(BOP_DEPTH, fluidTop), 0);
  const H_ds = TD_DEPTH; // DS always full
  const H_bo = BOP_DEPTH; // Booster line always full

  // Mean densities
  const MW_ds = dsAvgPPG();
  const MW_abv = average(annAboveGrid) || MW_ds;
  const MW_blw = average(annBelowGrid) || MW_ds;
  const MW_bo = boosterAvgPPG();

  // Hydrostatic pressures at key points
  const P_ds_TD = PSI_COEF * MW_ds * H_ds;
  const P_ann_TD = PSI_COEF * (MW_abv * H_riser + MW_blw * H_below);
  const P_bo_BOP = PSI_COEF * MW_bo * H_bo;
  const P_ris_BOP = PSI_COEF * MW_abv * H_riser;

  // ΔP with soft deadband
  const dP_ds_ann = smoothDeadbandPsi(P_ds_TD - P_ann_TD, IMB_DEADBAND_PSI);
  const dP_bo_ris = smoothDeadbandPsi(P_bo_BOP - P_ris_BOP, IMB_DEADBAND_PSI);

  // Calculate resistances at reference flow
  const qRef = (Q_REF / 15850.323);
  
  // DS loop resistance (DS + annulus + bit)
  const R_ds = drillstringLegResistancePsiPer_m3s();
  const R_ann_below = belowBOPResistancePsiPer_m3s();
  const R_ann_riser = riserResistancePsiPer_m3s();
  const R_bit = 1000 / Math.max(qRef, 1e-9); // ~1000 psi @ Qref
  const R_loop_DS = R_ds + R_ann_below + R_ann_riser + R_bit;

  // Booster loop resistance
  const R_bo = boosterResistancePsiPer_m3s();
  const R_loop_BO = R_bo + R_ann_riser;

  // Raw imbalance flows
  const q_ds2ann_raw = dP_ds_ann / Math.max(R_loop_DS, 1e-6);
  const q_bo2ris_raw = dP_bo_ris / Math.max(R_loop_BO, 1e-6);

  // Smooth and limit (max 5% of total flow as imbalance)
  const qMax_imb = ((Q_DS + Q_BO) / 15850.323) * 0.05;
  
  QIMB_DS2ANN_m3s = (1 - IMB_ALPHA) * QIMB_DS2ANN_m3s + 
                    IMB_ALPHA * clamp(q_ds2ann_raw, -qMax_imb, qMax_imb);
  QIMB_BO2RIS_m3s = (1 - IMB_ALPHA) * QIMB_BO2RIS_m3s + 
                    IMB_ALPHA * clamp(q_bo2ris_raw, -qMax_imb, qMax_imb);
}

// Helper: Riser resistance
function riserResistancePsiPer_m3s() {
  const L = Math.max(BOP_DEPTH - annulusTopDepthGlobal(), 0);
  if (L <= 0) return 1e9;
  const qRef = (Q_REF / 15850.323);
  const dpdl_Pa = dPperM_riserAnnulus(qRef);
  return (dpdl_Pa * L * PSI_PER_PASCAL) / Math.max(qRef, 1e-9);
}

// Helper: Below BOP resistance
function belowBOPResistancePsiPer_m3s() {
  const top = Math.max(BOP_DEPTH, annulusTopDepthGlobal());
  const L_csg = Math.max(0, SHOE_DEPTH - top);
  const L_oh = Math.max(0, TD_DEPTH - Math.max(SHOE_DEPTH, top));
  
  if (L_csg + L_oh <= 0) return 1e9;
  
  const qRef = (Q_REF / 15850.323);
  const dp_csg_Pa = dPperM_casingAnnulus(qRef) * L_csg;
  const dp_oh_Pa = dPperM_openholeAnnulus(qRef) * L_oh;
  
  return ((dp_csg_Pa + dp_oh_Pa) * PSI_PER_PASCAL) / Math.max(qRef, 1e-9);
}

// Helper: DS resistance
function drillstringLegResistancePsiPer_m3s() {
  const L = TD_DEPTH;
  const qRef = (Q_REF / 15850.323);
  const dpdl_Pa = dPperM_drillstring(qRef);
  return (dpdl_Pa * L * PSI_PER_PASCAL) / Math.max(qRef, 1e-9);
}

// Helper: Booster resistance
function boosterResistancePsiPer_m3s() {
  const L = BOP_DEPTH;
  const qRef = (Q_REF / 15850.323);
  const dpdl_Pa = dPperM_booster(qRef);
  return (dpdl_Pa * L * PSI_PER_PASCAL) / Math.max(qRef, 1e-9);
}

// ================== CML level update + controller ==================
function updateCMLLevelAndControl(){
  // --- 0) Inputs we need every frame
  const { qDS: qDS_m3s, qBO: qBO_m3s } = flows_m3s();
  const dt_ctrl = frameSeconds();
// --- 1) Auto CML (pressure-anchored, ultra-smooth) ---
// Optional: keep imbalance feed-forward commented until stable
let qIn_total_m3s = qDS_m3s + qBO_m3s;
// qIn_total_m3s += Math.max(0, QIMB_DS2ANN_m3s) + Math.max(0, QIMB_BO2RIS_m3s);

// Tunables (conservative defaults)
const CML_DB_HOLD_PSI   = 10;    // freeze band near setpoint
const CML_DB_INT_PSI    = 20;    // don't integrate inside this
const CML_PSOFT_BLEND   = 150;   // how fast we move from FF to PI
const CML_P_LPF_TAU_S   = 4.0;   // pressure LPF
const CML_FF_LPF_TAU_S  = 2.0;   // inflow LPF
const CML_KP_BASE       = 0.40;  // gpm/psi (base; scheduled)
const CML_KI_BASE       = 0.015; // gpm/psi/s (base; scheduled)
const CML_SLEW_GPM_S    = 80;    // |ΔQ|/s
const CML_ACCEL_GPM_S2  = 400;   // |ΔΔQ|/s² (accel limit)
const CML_CMD_LPF_TAU_S = 1.2;   // final command LPF

// Controller state (extend your cmlCtrl safely)
cmlCtrl.P_lpf_psi   = cmlCtrl.P_lpf_psi   || 0;
cmlCtrl.qFF_lpf_gpm = cmlCtrl.qFF_lpf_gpm || 0;
cmlCtrl.I_gpm       = cmlCtrl.I_gpm       || 0;
cmlCtrl.Q_cmd_prev  = cmlCtrl.Q_cmd_prev  || (Q_CML || 0);
cmlCtrl.dQ_prev     = cmlCtrl.dQ_prev     || 0; // for accel limiting
cmlCtrl.Q_out_lpf   = cmlCtrl.Q_out_lpf   || (Q_CML || 0);

if (AUTO_CML_ON && CML_AP_DEPTH > 0 && CML_AP_ECD > 0){
  const P_set = PSI_COEF * CML_AP_ECD * CML_AP_DEPTH; // psi

  // LPF helper
  const lpf = (yPrev, x, tau, dt) => {
    const a = clamp(dt / Math.max(tau, 1e-6), 0, 1);
    return (1 - a) * yPrev + a * x;
  };

  // Filtered pressure & error
  const P_meas = pressureAtDepth_noSBP_withCML(CML_AP_DEPTH);
  cmlCtrl.P_lpf_psi = lpf(cmlCtrl.P_lpf_psi, P_meas, CML_P_LPF_TAU_S, dt_ctrl);

  const e_raw = cmlCtrl.P_lpf_psi - P_set; // + → pull more (↑Q_CML)
  const inHold = Math.abs(e_raw) <= CML_DB_HOLD_PSI;
  const e_db = inHold ? 0
                      : (e_raw > 0 ? e_raw - CML_DB_HOLD_PSI
                                   : e_raw + CML_DB_HOLD_PSI);

  // Feed-forward = filtered inflow
  const qFF_gpm_raw = clamp(qIn_total_m3s * 15850.323, 0, Q_MAX);
  cmlCtrl.qFF_lpf_gpm = lpf(cmlCtrl.qFF_lpf_gpm, qFF_gpm_raw, CML_FF_LPF_TAU_S, dt_ctrl);

  // Gain scheduling & integral separation
  const wPI = clamp((Math.abs(e_raw) - CML_DB_HOLD_PSI) / Math.max(CML_PSOFT_BLEND, 1e-6), 0, 1);
  const smoothstep = (t) => (t<=0?0:t>=1?1:t*t*(3-2*t));
  const W = smoothstep(wPI); // 0→trust FF, 1→use PI

  const Kp = CML_KP_BASE * W;
  const Ki = CML_KI_BASE * W;
  const allowI = (Math.abs(e_raw) > CML_DB_INT_PSI);

  const Pterm_gpm = Kp * e_db;
  if (allowI){
    cmlCtrl.I_gpm += Ki * e_db * dt_ctrl;
    cmlCtrl.I_gpm = clamp(cmlCtrl.I_gpm, -400, +400);
  }

  // Blend FF and PI
  const qPI_gpm = cmlCtrl.qFF_lpf_gpm + Pterm_gpm + cmlCtrl.I_gpm;
  let qCmd_gpm = (1 - W) * cmlCtrl.qFF_lpf_gpm + W * qPI_gpm;

  // Two-stage motion limiting: accel then slew
  const dQ_des   = (qCmd_gpm - cmlCtrl.Q_cmd_prev) / Math.max(dt_ctrl, 1e-6);
  const dQ_rate  = clamp(
    dQ_des,
    cmlCtrl.dQ_prev - CML_ACCEL_GPM_S2*dt_ctrl,
    cmlCtrl.dQ_prev + CML_ACCEL_GPM_S2*dt_ctrl
  );
  let qCmd_accel = cmlCtrl.Q_cmd_prev + dQ_rate * dt_ctrl;

  const maxStep  = CML_SLEW_GPM_S * dt_ctrl;
  let qCmd_slew  = cmlCtrl.Q_cmd_prev + clamp(qCmd_accel - cmlCtrl.Q_cmd_prev, -maxStep, +maxStep);
  qCmd_slew = clamp(qCmd_slew, 0, Q_MAX);

  // Final command LPF
  cmlCtrl.Q_out_lpf = lpf(cmlCtrl.Q_out_lpf, qCmd_slew, CML_CMD_LPF_TAU_S, dt_ctrl);
  Q_CML = cmlCtrl.Q_out_lpf;

  // Anti-windup & hold-band housekeeping
  const atHi = (Q_CML >= Q_MAX - 1e-3) && (e_db > 0);
  const atLo = (Q_CML <= 0 + 1e-3)     && (e_db < 0);
  if (atHi || atLo) cmlCtrl.I_gpm *= 0.98;
  if (inHold)       cmlCtrl.I_gpm *= 0.99;

  // Advance state
  cmlCtrl.dQ_prev    = (Q_CML - cmlCtrl.Q_cmd_prev) / Math.max(dt_ctrl, 1e-6);
  cmlCtrl.Q_cmd_prev = Q_CML;

  if (cmlQSlider) cmlQSlider.value(Q_CML);
  if (cmlQInput)  cmlQInput.value(nf(Q_CML,1,0));

} else {
  // Auto off / anchor invalid → reset controller state
  cmlCtrl.I_gpm = 0;
  cmlCtrl.Q_cmd_prev = (Q_CML || 0);
  cmlCtrl.dQ_prev = 0;
}

 
  // --- 2) Soft limiter near pump pickup (prevents sucking air)
  const margin_m = Math.max(0, CML_DEPTH - CML_TOP_DEPTH);
  let qCML_m3s = (Q_CML || 0) / 15850.323;
  const m0 = 2.0;
  const s = clamp((margin_m / m0), 0, 1);
  const soft = s*s*(3 - 2*s);
  qCML_m3s *= soft;
  if (margin_m < 0.05) qCML_m3s = 0;

  // --- 3) Level update (riser volume integration)
  const qIn_total = qDS_m3s + qBO_m3s; // keep imbalances off for now
  const Aann_riser = A_riser();
  const dt_effective = dt_ctrl * CML_TIME_ACCEL;
  const netFlow_m3s = qIn_total - qCML_m3s;
  const dVol_m3 = netFlow_m3s * dt_effective;
  const dH_signed = dVol_m3 / Math.max(Aann_riser, 1e-12); // + fill, - drain

  const newTopDepth = (CML_TOP_DEPTH || 0) - dH_signed;
  const CML_ALPHA = 0.35;
  const cand = clamp(newTopDepth, 0, BOP_DEPTH);
  CML_TOP_DEPTH = (1 - CML_ALPHA) * (CML_TOP_DEPTH || 0) + CML_ALPHA * cand;

  CML_Q_MAX = Q_MAX; // expose max to UI
}


// Linearized DS leg resistance (psi per m³/s) at ~Q_REF
function drillstringLegResistancePsiPer_m3s() {
  const L = TD_DEPTH;
  if (L <= 0) return 1e9;
  const qRef = (Q_REF/15850.323); // m³/s
  const dpdl_Pa = dPperM_drillstring(qRef); // Pa/m at qRef
  const dp_Pa = dpdl_Pa * L; // Pa
  const dp_psi = dp_Pa * PSI_PER_PASCAL; // psi
  return Math.max(dp_psi / Math.max(qRef, 1e-9), 1);
}
const R_BIT_NOZZLE = 800 / Math.max((Q_REF/15850.323), 1e-9); // ~800 psi at Q_REF
// One frame worth of "simulation time" (keeps the fast-clock consistent)
function frameSeconds(){
  // BASE_M_PER_FRAME is tied to a reference velocity. Convert to a time step.
  const qRef_m3s = (Q_REF/15850.323);
  const vRef = qRef_m3s / Math.max(A_riser(), 1e-12); // m/s in riser
  const dx = BASE_M_PER_FRAME; // m advanced per frame at vRef
  return dx / Math.max(vRef, 1e-9); // seconds per frame
}
// ========================== CAPTURE / OVERLAYS =========================
function captureState(){
  const step = 25;
  const n = Math.floor(MAX_DEPTH / step) + 1;
  capturedP = Array.from({ length: n }, (_, i) => pressureAtDepth(i * step));
  capturedECD = Array.from({ length: n }, (_, i) => ecdWithSBPAtDepth(i * step));
}
window.captureState = captureState; // allow console trigger
// ============================== UI HELPERS =============================
function mkLabel(txt, x, y){ createDiv(txt).position(x,y).style("color","#EEE").style("font-size","12px"); }
// ================================ SETUP ================================
function setup(){
  createCanvas(W, H+220);
  colorMode(HSB, 360, 100, 100, 255);
  textFont('Arial');
  textAlign(CENTER, CENTER);
  frameRate(30);


  // ========== Bottom: 4 equal panels side-by-side ==========
  const padding = 30;
  frameWidth  = (W - 2 * padding - 40) / 3; // 3 equal panels
  frameHeight = 280;
  frameY      = well.y + well.h + 100;

  rheoFrameX = padding;
  rheoFrameW = frameWidth;

  gelFrameX = rheoFrameX + rheoFrameW + 20;
  gelFrameW = frameWidth / 2;

  // Legacy geometry frame variables (not used but kept for compatibility)
  geomFrameX = gelFrameX + gelFrameW + 20;
  geomFrameW = gelFrameW;

  // Enhanced Hydraulics on the RIGHT (same row)
  ehFrameX = geomFrameX + gelFrameW + 20;
  ehFrameW = frameWidth;
  ehFrameH = frameHeight;
  ehFrameY = frameY; // Same Y as other panels

  // Convert inches to meters
  riser_ID_m    = riser_ID_in    * 0.0254;
  casing_ID_m   = casing_ID_in   * 0.0254;
  openhole_ODm  = openhole_OD_in * 0.0254;
  ds_OD_m       = ds_OD_in       * 0.0254;
  ds_ID_m       = ds_ID_in       * 0.0254;
  booster_ID_m  = booster_ID_in  * 0.0254;

  // ========== Top: 2 compact rows ==========
  const rowY1 = 75;
  const rowY2 = 20;
  const slotW = 240;

  let xPos = 16;
  

  
  // Row 1: All sliders in ONE row
  mkLabel("DS MW", xPos, rowY1 - 14);
  dsMWSlider = createSlider(MW_MIN, MW_MAX, MW_DS, MW_STEP).position(xPos, rowY1).style('width', '160px');
  dsMWInput  = createInput(nf(MW_DS, 1, 1), 'number').position(xPos + 170, rowY1).size(55);
  xPos += slotW;

  mkLabel("DS Flow", xPos, rowY1 - 14);
  dsQSlider = createSlider(Q_MIN, Q_MAX, Q_DS, Q_STEP).position(xPos, rowY1).style('width', '160px');
  dsQInput  = createInput(nf(Q_DS, 1, 0), 'number').position(xPos + 170, rowY1).size(55);
  xPos += slotW;

  mkLabel("Bo MW", xPos, rowY1 - 14);
  boMWSlider = createSlider(MW_MIN, MW_MAX, MW_BO, MW_STEP).position(xPos, rowY1).style('width', '160px');
  boMWInput  = createInput(nf(MW_BO, 1, 1), 'number').position(xPos + 170, rowY1).size(55);
  xPos += slotW;

  mkLabel("Bo Flow", xPos, rowY1 - 14);
  boQSlider = createSlider(Q_MIN, Q_MAX, Q_BO, Q_STEP).position(xPos, rowY1).style('width', '160px');
  boQInput  = createInput(nf(Q_BO, 1, 0), 'number').position(xPos + 170, rowY1).size(55);
  xPos += slotW;

  mkLabel("Friction k", xPos, rowY1 - 14);
  kSlider = createSlider(0.0, 0.0002, K_FAC, 0.000005).position(xPos, rowY1).style('width', '160px');
  kInput  = createInput(nf(K_FAC, 1, 6), 'number').position(xPos + 170, rowY1).size(70);
  xPos += slotW + 20;

  mkLabel("SBP", xPos, rowY1 - 14);
  sbpSlider = createSlider(0, 3000, SBP_MANUAL, 10).position(xPos, rowY1).style('width', '160px');
  sbpInput  = createInput(nf(SBP_MANUAL, 1, 0), 'number').position(xPos + 170, rowY1).size(55);
  xPos += slotW;

  mkLabel("RPM", xPos, rowY1 - 14);
  rpmSlider = createSlider(0, 220, RPM, 5).position(xPos, rowY1).style('width', '160px');
  rpmInput  = createInput(String(RPM), 'number').position(xPos + 170, rowY1).size(55);
  xPos += slotW;

  mkLabel("CML Flow", xPos, rowY1 - 14);
  cmlQSlider = createSlider(Q_MIN, Q_MAX, Q_CML, Q_STEP).position(xPos, rowY1).style('width', '160px');
  cmlQInput  = createInput(nf(Q_CML || 0, 1, 0), 'number').position(xPos + 170, rowY1).size(55);

  // Row 2: Buttons and anchor inputs
  xPos = 16;

  mkLabel("CML AP Depth", xPos, rowY2 - 14);
  cmlApDepthInput = createInput('', 'number').position(xPos, rowY2).size(80);
  xPos += 90;

  // --- CML AP ECD (2 decimals, 0.01 step) ---
  cmlApEcdInput = makeTwoDecimalInput("CML AP ECD", xPos, rowY2, 0);
  xPos += 90;

  mkLabel("SBP AP Depth", xPos, rowY2 - 14);
  apDepthInput = createInput('', 'number').position(xPos, rowY2).size(80);
  xPos += 90;

  // --- SBP AP ECD (2 decimals, 0.01 step) ---
  apEcdInput = makeTwoDecimalInput("SBP AP ECD", xPos, rowY2, 0);
  xPos += 90;

  mkLabel("CML Depth", xPos, rowY2 - 14);
  cmlDepthInput = createInput(nf(CML_DEPTH || 0, 1, 0), 'number').position(xPos, rowY2).size(80);
  xPos += 100;

  // Buttons
  mpdBtn = createButton(MPD_ON ? 'MPD: ON' : 'MPD: OFF').size(90, 22).position(xPos, rowY2);
  xPos += 100;

  sbpModeBtn = createButton('SBP: ' + (SBP_MODE === 'manual' ? 'Manual' : 'Anchor')).size(110, 22).position(xPos, rowY2);
  xPos += 120;

  cmlBtn = createButton(CML_ON ? 'CML: ON' : 'CML: OFF').size(90, 22).position(xPos, rowY2)
    .style('background', '#ffe74a').style('font-weight', 'bold');
  xPos += 100;

  cmlAutoBtn = createButton(AUTO_CML_ON ? 'Auto CML: ON' : 'Auto CML: OFF').size(120, 22).position(xPos, rowY2)
    .style('background', '#ffe74a').style('font-weight', 'bold');
  xPos += 130;

  captureBtn = createButton('Capture State').size(100, 22).position(xPos, rowY2);
  xPos += 110;

  displayBtn = createButton(showCaptured ? 'Display: ON' : 'Display: OFF').size(100, 22).position(xPos, rowY2);
  xPos += 110;
  // Add UI controls in setup() near CML controls:
mkLabel("Top Fill Flow", xPos, rowY2 - 14);
const topfillQInput = createInput('0', 'number').position(xPos, rowY2).size(80);
topfillQInput.input(() => { Q_TOPFILL = clamp(num(topfillQInput.value()), 0, Q_MAX); });
xPos += 90;

mkLabel("Top Fill MW", xPos, rowY2 - 14);
const topfillMWInput = createInput('9.5', 'number').position(xPos, rowY2).size(80);
topfillMWInput.input(() => { MW_TOPFILL = clamp(num(topfillMWInput.value()), MW_MIN, MW_MAX); });
xPos += 90;

const topfillBtn = createButton('Top Fill: OFF').size(100, 22).position(xPos, rowY2);
topfillBtn.mousePressed(() => {
  TOPFILL_ON = !TOPFILL_ON;
  topfillBtn.html(TOPFILL_ON ? 'Top Fill: ON' : 'Top Fill: OFF');
});
xPos += 110;

// ========== FORMATION FLUIDS UI ==========
// Row 3: Formation fluids controls (below row 2)
const rowY3 = rowY2 + 32;
let xPos3 = 16;

mkLabel("Form Fluids", xPos3, rowY3 - 14);
const formFluidsBtn = createButton(formationFluidEnabled ? 'Kicks: ON' : 'Kicks: OFF')
  .size(90, 22).position(xPos3, rowY3)
  .style('background', '#ff6b6b').style('font-weight', 'bold');
formFluidsBtn.mousePressed(() => {
  formationFluidEnabled = !formationFluidEnabled;
  formFluidsBtn.html(formationFluidEnabled ? 'Kicks: ON' : 'Kicks: OFF');
});
xPos3 += 100;

mkLabel("Fluid Type", xPos3, rowY3 - 14);
const formFluidTypeSelect = createSelect().position(xPos3, rowY3).size(90);
formFluidTypeSelect.option('WATER');
formFluidTypeSelect.option('OIL');
formFluidTypeSelect.option('GAS');
formFluidTypeSelect.option('BLACKOIL');
formFluidTypeSelect.selected(formationFluidType);
formFluidTypeSelect.changed(() => {
  formationFluidType = formFluidTypeSelect.value();
});
xPos3 += 100;

mkLabel("Influx Rate (gpm)", xPos3, rowY3 - 14);
const formFluidRateInput = createInput(String(formationFluidRate_gpm), 'number')
  .position(xPos3, rowY3).size(80);
formFluidRateInput.input(() => {
  formationFluidRate_gpm = Math.max(0, Number(formFluidRateInput.value()) || 0);
});
xPos3 += 90;

mkLabel("Influx Depth (m)", xPos3, rowY3 - 14);
const formFluidDepthInput = createInput(String(formationFluidDepth_m), 'number')
  .position(xPos3, rowY3).size(80);
formFluidDepthInput.input(() => {
  formationFluidDepth_m = Math.max(BOP_DEPTH, Math.min(TD_DEPTH, Number(formFluidDepthInput.value()) || 4500));
});
xPos3 += 90;

mkLabel("Migration Model", xPos3, rowY3 - 14);
const migrationModelSelect = createSelect().position(xPos3, rowY3).size(140);
migrationModelSelect.option('SHUTIN');
migrationModelSelect.option('HARMATHY');
migrationModelSelect.option('MODIFIED_HARMATHY');
migrationModelSelect.selected(formationFluidMigrationModel);
migrationModelSelect.changed(() => {
  formationFluidMigrationModel = migrationModelSelect.value();
});
xPos3 += 150;

// ========== DIAGNOSTIC LOGGING BUTTONS ==========
mkLabel("Diagnostic Log", xPos3, rowY3 - 14);
logStartBtn = createButton('START').size(70, 22).position(xPos3, rowY3)
  .style('background', '#4ade80').style('font-weight', 'bold');
logStartBtn.mousePressed(() => {
  diagnosticLog.recording = true;
  diagnosticLog.data = [];
  diagnosticLog.startTime = millis();
  diagnosticLog.lastLogFrame = frameCount;
  logStartBtn.attribute('disabled', '');
  logStopBtn.removeAttribute('disabled');
});

logStopBtn = createButton('STOP').size(70, 22).position(xPos3 + 75, rowY3)
  .style('background', '#f87171').style('font-weight', 'bold');
logStopBtn.attribute('disabled', '');
logStopBtn.mousePressed(() => {
  diagnosticLog.recording = false;
  logStopBtn.attribute('disabled', '');
  logDownloadBtn.removeAttribute('disabled');
  logStartBtn.removeAttribute('disabled');
});

logDownloadBtn = createButton('SAVE').size(70, 22).position(xPos3 + 150, rowY3)
  .style('background', '#60a5fa').style('font-weight', 'bold');
logDownloadBtn.attribute('disabled', '');
logDownloadBtn.mousePressed(() => {
  saveDiagnosticLog();
});

    // small local helper (scoped to setup) to make 2-decimal number inputs
  function makeTwoDecimalInput(label, x, y, initial = 0) {
    mkLabel(label, x, y - 14);
    const input = createInput(nf(initial, 1, 2), 'number')
      .position(x, y)
      .size(80);
    input.attribute('step', '0.01');
    input.attribute('min', '0');              // optional
    input.attribute('inputmode', 'decimal');  // nicer mobile keyboard
    input.elt.addEventListener('change', () => {
      const v = Number(input.value());
      if (Number.isFinite(v)) input.value(v.toFixed(2));
    });
    return input;
  }
  // ========== Build bottom panels ==========
  // ========== Build bottom panels ==========
  buildRheologyUI(rheoFrameX + 16, frameY + 40);
  buildGelAndGeometryUI(gelFrameX + 16, frameY + 40); // Combined panel
  buildEnhancedHydraulicsUI(ehFrameX + 16, ehFrameY + 40);
  
  doRheologyFit();
    publishRheoToGlobals(); // 
  
  // Value bindings
  dsMWSlider.input(() => setDSMW(dsMWSlider.value()));
  dsMWInput.input(() => setDSMW(num(dsMWInput.value())));
  dsQSlider.input(() => setDSQ(dsQSlider.value()));
  dsQInput.input(() => setDSQ(num(dsQInput.value())));
  boMWSlider.input(() => setBOMW(boMWSlider.value()));
  boMWInput.input(() => setBOMW(num(boMWInput.value())));
  boQSlider.input(() => setBOQ(boQSlider.value()));
  boQInput.input(() => setBOQ(num(boQInput.value())));
  kSlider.input(() => setK(kSlider.value()));
  kInput.input(() => setK(num(kInput.value())));
  sbpSlider.input(() => { SBP_MANUAL = Number(sbpSlider.value()); sbpInput.value(nf(SBP_MANUAL,1,0)); });
  sbpInput.input(() => { SBP_MANUAL = Math.max(0, Number(sbpInput.value())||0); sbpSlider.value(SBP_MANUAL); });
  rpmSlider.input(() => setRPM(rpmSlider.value()));
  rpmInput.input(() => setRPM(Number(rpmInput.value())||0));
  apDepthInput.input(() => { ANCHOR_DEPTH = Math.max(0, num(apDepthInput.value())); });
  apEcdInput.input(() => { ANCHOR_ECD = Math.max(0, num(apEcdInput.value())); });
  cmlApDepthInput.input(() => { CML_AP_DEPTH = Math.max(0, num(cmlApDepthInput.value())); });
  cmlApEcdInput.input(() => { CML_AP_ECD = Math.max(0, num(cmlApEcdInput.value())); });
  cmlQSlider.input(() => { if (!AUTO_CML_ON){ Q_CML = cmlQSlider.value(); cmlQInput.value(nf(Q_CML,1,0)); }});
  cmlQInput.input(() => { if (!AUTO_CML_ON){ Q_CML = clamp(num(cmlQInput.value()), Q_MIN, Q_MAX); cmlQSlider.value(Q_CML); }});
  cmlDepthInput.input(() => { CML_DEPTH = clamp(num(cmlDepthInput.value()), 0, BOP_DEPTH); });
  
  mpdBtn.mousePressed(() => { MPD_ON = !MPD_ON; mpdBtn.html(MPD_ON ? 'MPD: ON' : 'MPD: OFF'); });
  sbpModeBtn.mousePressed(() => {
    SBP_MODE = (SBP_MODE === 'manual') ? 'anchor' : 'manual';
    sbpModeBtn.html(SBP_MODE === 'manual' ? 'SBP: Manual' : 'SBP: Anchor');
  });
  cmlBtn.mousePressed(() => {
    CML_ON = !CML_ON;
    if (!CML_ON) { CML_TOP_DEPTH = 0; }
    cmlBtn.html(CML_ON ? 'CML: ON' : 'CML: OFF');
  });
  cmlAutoBtn.mousePressed(() => {
    AUTO_CML_ON = !AUTO_CML_ON;
    cmlAutoBtn.html(AUTO_CML_ON ? 'Auto CML: ON' : 'Auto CML: OFF');
  });
  captureBtn.mousePressed(captureState);
  displayBtn.mousePressed(() => { 
    showCaptured = !showCaptured; 
    displayBtn.html(showCaptured ? 'Display: ON' : 'Display: OFF'); 
  });
  
  buildLossesUI();
buildDiagnosticsUI();

  // Initialize formation fluid cells
  initializeFormationFluidCells();
}

function buildGelAndGeometryUI(x, y){
  // Gel section (top)
  mkLabel("Gel τ (Pa)", x, y-18);
  const gelIn = createInput(String(gel_Pa), 'number').position(x, y).size(70);
  gelIn.input(() => { gel_Pa = num(gelIn.value()); });
  
  const gelBtn = createButton(use_gel ? 'Gel: ON' : 'Gel: OFF').position(x+80, y).size(70,22);
  gelBtn.mousePressed(() => { use_gel = !use_gel; gelBtn.html(use_gel ? 'Gel: ON' : 'Gel: OFF'); });
  
  let y2 = y + 40;
  mkLabel("G10s", x, y2-16);
  rheoPanel.G10s = createInput(String(rheoDefaults.G10s),'number').position(x, y2).size(65);
  mkLabel("G10m", x+75, y2-16);
  rheoPanel.G10m = createInput(String(rheoDefaults.G10m),'number').position(x+75, y2).size(65);
  mkLabel("G30m", x+150, y2-16);
  rheoPanel.G30m = createInput(String(rheoDefaults.G30m),'number').position(x+150, y2).size(65);
  
  // Geometry section (below gel)
  y2 -= 40;
  mkLabel("Riser ID", x +360, y2-16);
  const risIn = createInput(String(riser_ID_in),'number').position(x+360, y2).size(70);
  risIn.input(() => { riser_ID_in = num(risIn.value()); riser_ID_m = riser_ID_in * 0.0254; });
  
  mkLabel("DS OD", x+500, y2-16);
  const dsoIn = createInput(String(ds_OD_in),'number').position(x+500, y2).size(70);
  dsoIn.input(() => { ds_OD_in = num(dsoIn.value()); ds_OD_m = ds_OD_in * 0.0254; });
  
  y2 += 40;
  mkLabel("Casing ID", x+360, y2-16);
  const casIn = createInput(String(casing_ID_in),'number').position(x+360, y2).size(70);
  casIn.input(() => { casing_ID_in = num(casIn.value()); casing_ID_m = casing_ID_in * 0.0254; });
  
  mkLabel("OH OD", x+500, y2-16);
  const ohIn = createInput(String(openhole_OD_in),'number').position(x+500, y2).size(70);
  ohIn.input(() => { openhole_OD_in = num(ohIn.value()); openhole_ODm = openhole_OD_in * 0.0254; });
  
  y2 += 40;
  mkLabel("DS ID", x+360, y2-16);
  const dsiIn = createInput(String(ds_ID_in),'number').position(x+360, y2).size(70);
  dsiIn.input(() => { ds_ID_in = num(dsiIn.value()); ds_ID_m = ds_ID_in * 0.0254; });
}

if (typeof window.__qAnnAbove_m3s !== 'number' || typeof window.__qAnnBelow_m3s !== 'number') {
  if (typeof recomputeAnnulusSectionFlowsForLosses === 'function') {
    recomputeAnnulusSectionFlowsForLosses();
  }
}

// ========================================================================
// DIAGNOSTIC LOGGING FUNCTIONS
// ========================================================================
function captureDiagnosticData() {
  const timestamp = ((millis() - diagnosticLog.startTime) / 1000).toFixed(2);
  const fluidTop = annulusTopDepthGlobal();

  // Get average MW values
  const MW_DS_avg = dsAvgPPG ? dsAvgPPG() : (MW_DS || 0);
  const MW_BO_avg = boosterAvgPPG ? boosterAvgPPG() : (MW_BO || 0);

  // Flow routing values
  const qDS_m3s = (Q_DS || 0) / 15850.323;
  const qBO_m3s = (Q_BO || 0) / 15850.323;
  const qAnnUp_m3s = window.__qAnnUp_m3s || window.__qAnnAbove_m3s || 0;
  const qAnnDown_m3s = window.__qAnnDown_m3s || 0;
  const qAnnBelow_m3s = window.__qAnnBelow_m3s || 0;
  const qAnnAbove_m3s = window.__qAnnAbove_m3s || 0;

  // Build row
  const row = {
    time_s: timestamp,
    frameCount: frameCount,

    // Fluid properties
    MW_DS: MW_DS_avg.toFixed(2),
    MW_BO: MW_BO_avg.toFixed(2),

    // Flow rates
    Q_DS_gpm: (Q_DS || 0).toFixed(1),
    Q_BO_gpm: (Q_BO || 0).toFixed(1),
    Q_TF_gpm: (TOPFILL_ON ? (Q_TOPFILL || 0) : 0).toFixed(1),
    Q_CML_gpm: (Q_CML || 0).toFixed(1),
    FLOW_OUT_gpm: (FLOW_OUT_gpm || 0).toFixed(1),

    // Fluid level
    fluidTop_m: fluidTop.toFixed(1),
    riserFull: (fluidTop <= 0.5) ? 'YES' : 'NO',

    // Flow routing (section flows)
    qAnnUp_gpm: (qAnnUp_m3s * 15850.323).toFixed(1),
    qAnnDown_gpm: (qAnnDown_m3s * 15850.323).toFixed(1),
    qAnnBelow_gpm: (qAnnBelow_m3s * 15850.323).toFixed(1),
    qAnnAbove_gpm: (qAnnAbove_m3s * 15850.323).toFixed(1),

    // SBP
    SBP_psi: (CURRENT_SBP || 0).toFixed(0),
    MPD_ON: MPD_ON ? 'YES' : 'NO'
  };

  // Loss zones data
  if (LOSSES_ON && Array.isArray(lossZones)) {
    for (let i = 0; i < lossZones.length; i++) {
      const z = lossZones[i];
      if (!z || !z.enabled) continue;

      const zoneNum = i + 1;
      const P_calc = pressureAtDepth(z.depth_m);
      const P_frac = z.fracPressure_psi || 0;
      const dP = P_calc - P_frac;
      const isWet = z.depth_m > fluidTop;
      const isActive = z._active || false;

      row[`Z${zoneNum}_depth_m`] = z.depth_m.toFixed(0);
      row[`Z${zoneNum}_P_calc_psi`] = P_calc.toFixed(1);
      row[`Z${zoneNum}_P_frac_psi`] = P_frac.toFixed(0);
      row[`Z${zoneNum}_dP_psi`] = dP.toFixed(1);
      row[`Z${zoneNum}_Qloss_gpm`] = (z.Qloss_gpm || 0).toFixed(1);
      row[`Z${zoneNum}_wet`] = isWet ? 'YES' : 'NO';
      row[`Z${zoneNum}_active`] = isActive ? 'YES' : 'NO';
    }
  }

  // Advection parameters (example - add what's most relevant)
  row.CELL_M = CELL_M;
  row.N_ABV = N_ABV;
  row.N_BELOW = N_BELOW;

  diagnosticLog.data.push(row);
}

function saveDiagnosticLog() {
  if (diagnosticLog.data.length === 0) {
    alert('No data to save. Start recording first.');
    return;
  }

  // Get all unique keys from all rows (for CSV header)
  const allKeys = new Set();
  diagnosticLog.data.forEach(row => {
    Object.keys(row).forEach(key => allKeys.add(key));
  });
  const headers = Array.from(allKeys);

  // Build CSV
  let csv = headers.join(',') + '\n';
  diagnosticLog.data.forEach(row => {
    const values = headers.map(h => row[h] !== undefined ? row[h] : '');
    csv += values.join(',') + '\n';
  });

  // Download
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  a.download = `diagnostic_log_${timestamp}.csv`;
  a.click();
  URL.revokeObjectURL(url);

  console.log(`Saved ${diagnosticLog.data.length} data points to CSV`);
}

// ================================ DRAW =================================
function draw(){
  background(0,0,12);
  // Panels background bands
  noStroke();
  fill(210, 80, 30);
  rect(0, 0, width, 120);
  fill(30, 60, 20);
  rect(0, 120, width, 520);
  fill(0, 0, 20);
  rect(0, 640, width, height-640);
  // Bottom frames (visual only; your UI inputs sit on top of these)
  drawBottomFrames();
  drawEnhancedHydraulicsFrame();

  // ✅ CRITICAL FIX: Update annulus flows BEFORE any pressure/friction calculations
  // The SBP logic below calls pressureAtDepth_noSBP() which needs friction which
  // needs window.__qAnnBelow_m3s. Update flows first to avoid 1-frame lag!
  // Call with dt_s=0 to just update flow variables without advancing simulation time
  routeAnnulusFlowsWithLosses(0);

  // SBP logic
  if (MPD_ON){
    // Rule #8: SBP can only be applied if riser is full (CML_TOP_DEPTH must be 0)
    const riserIsFull = (!CML_ON || CML_TOP_DEPTH < 0.1);
    
    if (riserIsFull) {
      if (SBP_MODE === "manual"){
        CURRENT_SBP = Math.max(0, SBP_MANUAL);
      } else {
        if (ANCHOR_DEPTH > 0 && ANCHOR_ECD > 0){
          const p_set = PSI_COEF * ANCHOR_ECD * ANCHOR_DEPTH;
          const p_actual = pressureAtDepth_noSBP(ANCHOR_DEPTH);
          CURRENT_SBP = Math.max(0, p_set - p_actual);
        } else {
          CURRENT_SBP = 0;
        }
      }
    } else {
      CURRENT_SBP = 0; // Cannot apply SBP when riser level is dropped
    }
  } else {
    CURRENT_SBP = 0;
  }
  
  // SBP logic
if (MPD_ON){
  const riserIsFull = (!CML_ON || CML_TOP_DEPTH < 0.1);
  
  if (riserIsFull) {
    if (SBP_MODE === "manual"){
      CURRENT_SBP = Math.max(0, SBP_MANUAL);
    } else {
      // Anchor mode
      if (ANCHOR_DEPTH > 0 && ANCHOR_ECD > 0){
        const p_set = PSI_COEF * ANCHOR_ECD * ANCHOR_DEPTH;
        const p_actual = pressureAtDepth_noSBP(ANCHOR_DEPTH);
        CURRENT_SBP = Math.max(0, p_set - p_actual);
        
        // ✅ ADD THIS: Update slider and input to show calculated setpoint
        if (sbpSlider) sbpSlider.value(CURRENT_SBP);
        if (sbpInput) sbpInput.value(nf(CURRENT_SBP, 1, 0));
      } else {
        CURRENT_SBP = 0;
      }
    }
  } else {
    CURRENT_SBP = 0;
  }
} else {
  CURRENT_SBP = 0;
}
  // Update CML level and (if enabled) Auto-CML flow command BEFORE pressures are used
  updateCMLLevelAndControl();
  // Well visuals and charts
  drawWellAndFluids();
  drawFractureSymbols();
  drawDepthGrid();
  drawReferenceBadges();
  drawGaugesAndCharts();
 
  
// Time series logging (right before stepAdvection)
tsFrame++;
if (tsFrame % TS_STRIDE === 0){
  const totalIn = Q_DS + Q_BO;
  
  // Push to beginning (right-to-left display)
  tsData.totalFlowIn.unshift(totalIn);
  tsData.dsFlow.unshift(Q_DS);
  tsData.cmlFlow.unshift(Q_CML || 0);
  tsData.spp.unshift(lastSPP);
  tsData.sbpApplied.unshift(CURRENT_SBP);
  
  
// Flow Out line (0–QMAX)
const QMAX = (typeof Q_MAX !== 'undefined' && Q_MAX > 0) ? Q_MAX : 1000;
plotTimeSeriesLine(tsFlowOut_gpm, 0, QMAX, null);

// Choke line (0–100%)
plotTimeSeriesLine(tsChoke_pct, 0, 100, null);


  
  // SBP setpoint
  const sbpSet = (SBP_MODE === 'anchor' && ANCHOR_DEPTH > 0 && ANCHOR_ECD > 0) 
    ? (PSI_COEF * ANCHOR_ECD * ANCHOR_DEPTH) : NaN;
  tsData.sbpSetpoint.unshift(sbpSet);
  
  // CML anchor setpoint & actual
  const cmlSet = (AUTO_CML_ON && CML_AP_DEPTH > 0 && CML_AP_ECD > 0)
    ? (PSI_COEF * CML_AP_ECD * CML_AP_DEPTH) : NaN;
  const cmlAct = (AUTO_CML_ON && CML_AP_DEPTH > 0)
    ? pressureAtDepth(CML_AP_DEPTH) : NaN;
  tsData.cmlAnchorSet.unshift(cmlSet);
  tsData.cmlAnchorActual.unshift(cmlAct);
  
  // SBP anchor point setpoint & actual
  const sbpAPSet = (ANCHOR_DEPTH > 0 && ANCHOR_ECD > 0)
    ? (PSI_COEF * ANCHOR_ECD * ANCHOR_DEPTH) : NaN;
  const sbpAPAct = (ANCHOR_DEPTH > 0)
    ? pressureAtDepth(ANCHOR_DEPTH) : NaN;
  tsData.sbpAPSet.unshift(sbpAPSet);
  tsData.sbpAPActual.unshift(sbpAPAct);
  
  // Trim to max length
  for (let key in tsData) {
    if (tsData[key].length > TS_MAX) tsData[key].pop();
  }
}
  
  
  // Advection last (after SPP/levels reflect current step)
// ---- LOSSES → FO → CHOKE → ADVECT → LEVEL ----
// ---- PHYSICS UPDATE ORDER (Pattern A) ----
const dt_frame = frameSeconds();

// 1. Calculate U-tube imbalances FIRST
computeImbalanceFlows();

// 2-5: Equilibrate losses and level together (iterative)
// NOTE: This calls routeAnnulusFlowsWithLosses() internally which sets:
//   - window.__qAnnUp_m3s, window.__qAnnDown_m3s (section flows)
//   - FLOW_OUT_gpm (with proper hysteresis and smoothing)
// Adaptive iterations: fewer when stable, more when active losses
const adaptiveIters = (() => {
  if (!LOSSES_ON) return 1;
  const totalLoss = (typeof totalLossRate_gpm === 'function') ? totalLossRate_gpm() : 0;
  const totalFlow = (Q_DS || 0) + (Q_BO || 0);
  const lossRatio = totalFlow > 10 ? totalLoss / totalFlow : 0;
  // High loss activity → 3 iterations, low/stable → 2 iterations
  return (lossRatio > 0.3 || totalLoss > 500) ? 3 : 2;
})();
equilibrateFluidLevel(dt_frame, adaptiveIters);

// 6. Section flows already computed by routeAnnulusFlowsWithLosses() inside equilibrateFluidLevel()
// DO NOT call recomputeAnnulusSectionFlowsForLosses() here - it uses old routing logic!

// 7. Update CML controller
// (already called earlier - skip if done)

// 8. Choke update (FO already computed by routeAnnulusFlowsWithLosses)
if (MPD_ON) updateChokeFromFO();

// 9. Advect fluids
stepAdvection();

// 9b. Update formation fluid migration (kicks)
if (formationFluidEnabled) {
  updateFormationFluidMigration(dt_frame);
}

// 10. Gravity settling
gravityDensitySwap();

// 11. UI updates
refreshLossesUIFromModel();
updateDiagnosticsUI(dt_frame);

  // ========== DIAGNOSTIC LOGGING ==========
  // Capture data at regular intervals when recording
  if (diagnosticLog.recording && (frameCount - diagnosticLog.lastLogFrame) >= diagnosticLog.LOG_INTERVAL) {
    captureDiagnosticData();
    diagnosticLog.lastLogFrame = frameCount;
  }

  // Footer labels
  fill(0,0,95); textSize(12);
  text("Rheology/Hydraulics controls at bottom-left; SBP/MPD top-right.", width/2, height-16);
}



// ============================== DRAW HELPERS ===========================
function drawWellAndFluids(){
  const px = well.x + (well.w - dp.w) / 2;
  stroke(0, 0, 95); strokeWeight(2.5); noFill(); rect(well.x, well.y, well.w, well.h, 8);
  stroke(0, 0, 80); strokeWeight(5);
  line(px, well.y, px, well.y + well.h);
  line(px + dp.w, well.y, px + dp.w, well.y + well.h);
  noStroke();

  const yBOP = mapDepthToY(BOP_DEPTH);
  const boosterW = 12, boosterX = well.x - 14;
  stroke(0, 0, 50, 160); strokeWeight(1.5); noFill(); rect(boosterX - boosterW/2, well.y, boosterW, yBOP - well.y, 3);

  const yTopWetBo = clipFillY_forBooster();
  const lvl_bo_m = clamp(levelDeficit_bo_m, 0, BOP_DEPTH);
  for (let i = 0; i < N_ABV; i++) {
    const dTop_m = i * CELL_M;
    const dBot_m = Math.min((i + 1) * CELL_M, BOP_DEPTH);
    if (dBot_m <= lvl_bo_m) continue;
    const yTop = mapDepthToY(Math.max(dTop_m, lvl_bo_m));
    const yBot = mapDepthToY(dBot_m);
    const hue = remap(boosterGrid[i], MW_MIN, MW_MAX, 170, 355);
    noStroke(); fill(hue, 70, 70, 210);
    rect(boosterX - boosterW/2 + 1, Math.max(yTop, yTopWetBo), boosterW - 2, yBot - Math.max(yTop, yTopWetBo));
  }

  if (levelDeficit_bo_m > 0.01) {
    const levelY_bo = mapDepthToY(Math.min(levelDeficit_bo_m, BOP_DEPTH));
    noStroke(); fill(0, 0, 0, 80); rect(boosterX - boosterW/2 + 1, well.y, boosterW - 2, levelY_bo - well.y);
    stroke(55, 80, 90); strokeWeight(2); line(boosterX - boosterW/2 + 3, levelY_bo, boosterX + boosterW/2 - 3, levelY_bo);
    noStroke(); fill(0, 0, 95); textAlign(RIGHT, CENTER); textSize(11);
    text(`Bo level ↓ ${nf(levelDeficit_bo_m,1,1)} m`, boosterX - boosterW/2 , levelY_bo);
    textAlign(CENTER, CENTER);
  }

  noStroke(); fill(0,0,80); triangle(boosterX + 1, yBOP - 16, boosterX + 1, yBOP - 4, boosterX + 12, yBOP - 10);
  push(); translate(boosterX - boosterW/2 - 10, (well.y + yBOP) / 2); rotate(-HALF_PI); fill(0, 0, 80); textSize(11); textAlign(CENTER, CENTER); text("Booster Line", 0, 0); pop();

  const xLeftAnn = well.x + 1;
  const xRightAnn = px + dp.w + 1;
  const wLeftAnn = Math.max(0, px - xLeftAnn - 1);
  const wRightAnn = Math.max(0, (well.x + well.w - 1) - xRightAnn);

  // ===== DRILLSTRING (INSIDE) =====
  const lvl_m = clamp(levelDeficit_m, 0, TD_DEPTH);
  const yTopWetDS = clipFillY_forDS();
  for (let i = 0; i < N_DS; i++) {
    const dTop_m = i * CELL_M;
    const dBot_m = Math.min((i + 1) * CELL_M, TD_DEPTH);
    if (dBot_m <= lvl_m) continue;
    const yTop = mapDepthToY(Math.max(dTop_m, lvl_m));
    const yBot = mapDepthToY(dBot_m);
    const hue = remap(dsGrid[i], MW_MIN, MW_MAX, 170, 355);
    fill(hue, 70, 70, 220); rect(px + 1, Math.max(yTop, yTopWetDS), dp.w - 2, yBot - Math.max(yTop, yTopWetDS));
  }

  if (levelDeficit_m > 0.01) {
    const levelY = mapDepthToY(Math.min(levelDeficit_m, TD_DEPTH));
    noStroke(); fill(0, 0, 0, 80); rect(px + 1, well.y, dp.w - 2, levelY - well.y);
    stroke(55, 80, 90); strokeWeight(2); line(px + 3, levelY, px + dp.w - 3, levelY);
    noStroke(); fill(0, 0, 95); textAlign(LEFT, CENTER); textSize(11);
    text(`DS level ↓ ${nf(levelDeficit_m, 1, 1)} m`, px + dp.w , levelY );
    textAlign(CENTER, CENTER);
  }

// ===== ANNULUS RISER (above BOP) =====
const annulusTop = annulusTopDepthGlobal(); // Global top (max of CML and loss)
const yTopWetRis = mapDepthToY(Math.min(annulusTop, BOP_DEPTH));

// Draw riser annulus cells (skip dry cells above annulusTop)
for (let i = 0; i < N_ABV; i++) {
  const dTop_m = i * CELL_M;
  const dBot_m = Math.min((i + 1) * CELL_M, BOP_DEPTH);
  
  // Skip completely dry cells
  if (dBot_m <= annulusTop) continue;
  
  const yTop = mapDepthToY(dTop_m);
  const yBot = mapDepthToY(dBot_m);
  const hue = remap(annAboveGrid[i], MW_MIN, MW_MAX, 170, 355);
  fill(hue, 70, 70, 190);
  const clippedTop = Math.max(yTop, yTopWetRis);
  const cellHeight = yBot - clippedTop;
  if (cellHeight > 0) {
    if (wLeftAnn > 0) rect(xLeftAnn, clippedTop, wLeftAnn, cellHeight);
    if (wRightAnn > 0) rect(xRightAnn, clippedTop, wRightAnn, cellHeight);
  }
}

// ===== ANNULUS BELOW BOP (casing + openhole) =====
const annulusBelowTop = Math.max(BOP_DEPTH, annulusTop);
for (let i = 0; i < N_BELOW; i++) {
  const dTop_m = BOP_DEPTH + i * CELL_M;
  const dBot_m = Math.min(BOP_DEPTH + (i + 1) * CELL_M, TD_DEPTH);
  
  // Skip cells above the wet top
  if (dBot_m <= annulusBelowTop) continue;
  
  const yTop = mapDepthToY(Math.max(dTop_m, annulusBelowTop));
  const yBot = mapDepthToY(dBot_m);
  const hue = remap(annBelowGrid[i], MW_MIN, MW_MAX, 170, 355);
  fill(hue, 70, 70, 210);
  if (wLeftAnn > 0) rect(xLeftAnn, yTop, wLeftAnn, yBot - yTop);
  if (wRightAnn > 0) rect(xRightAnn, yTop, wRightAnn, yBot - yTop);
}

// ===== FORMATION FLUIDS VISUALIZATION (LEFT SIDE) =====
if (formationFluidEnabled) {
  const formFluidBarX = well.x - 35; // Left of well
  const formFluidBarW = 18;

  // Draw background bar
  stroke(0, 0, 30); strokeWeight(1); fill(0, 0, 10, 150);
  rect(formFluidBarX, mapDepthToY(BOP_DEPTH), formFluidBarW, mapDepthToY(TD_DEPTH) - mapDepthToY(BOP_DEPTH), 3);

  // Draw formation fluid cells
  for (let i = 0; i < N_BELOW; i++) {
    const dTop_m = BOP_DEPTH + i * CELL_M;
    const dBot_m = Math.min(BOP_DEPTH + (i + 1) * CELL_M, TD_DEPTH);

    const gasAmt = gasPhaseFrom_below[i] || 0;
    const oilAmt = oilPhaseFrom_below[i] || 0;
    const waterAmt = waterPhaseFrom_below[i] || 0;
    const totalFormFluid = gasAmt + oilAmt + waterAmt;

    if (totalFormFluid > 0.01) {
      const yTop = mapDepthToY(dTop_m);
      const yBot = mapDepthToY(dBot_m);
      const cellH = yBot - yTop;

      // Stack formation fluids (gas on top, then oil, then water)
      let yOffset = 0;

      // Gas (lightest, rises to top)
      if (gasAmt > 0.01) {
        const gasH = cellH * (gasAmt / totalFormFluid);
        const gasColor = FORMATION_FLUID_TYPES.GAS.color;
        noStroke(); fill(gasColor[0], gasColor[1], gasColor[2], 220);
        rect(formFluidBarX + 2, yTop + yOffset, formFluidBarW - 4, gasH);
        yOffset += gasH;
      }

      // Oil (medium density)
      if (oilAmt > 0.01) {
        const oilH = cellH * (oilAmt / totalFormFluid);
        const oilColor = formationFluidType === 'BLACKOIL'
          ? FORMATION_FLUID_TYPES.BLACKOIL.color
          : FORMATION_FLUID_TYPES.OIL.color;
        noStroke(); fill(oilColor[0], oilColor[1], oilColor[2], 220);
        rect(formFluidBarX + 2, yTop + yOffset, formFluidBarW - 4, oilH);
        yOffset += oilH;
      }

      // Water (heaviest, sinks to bottom)
      if (waterAmt > 0.01) {
        const waterH = cellH * (waterAmt / totalFormFluid);
        const waterColor = FORMATION_FLUID_TYPES.WATER.color;
        noStroke(); fill(waterColor[0], waterColor[1], waterColor[2], 220);
        rect(formFluidBarX + 2, yTop + yOffset, formFluidBarW - 4, waterH);
      }
    }
  }

  // Label
  push();
  translate(formFluidBarX + formFluidBarW/2, (mapDepthToY(BOP_DEPTH) + mapDepthToY(TD_DEPTH))/2);
  rotate(-HALF_PI);
  fill(0, 0, 90); textSize(10); textAlign(CENTER, CENTER);
  text("Formation Fluids", 0, 0);
  pop();
}

  // ===== DRY OVERLAYS & LABELS (UNIFIED WHEN EQUAL) =====

const cmlActive = CML_ON && CML_TOP_DEPTH > 0.01;
const lossActive = LOSSES_ON && LOSS_TOP_DEPTH_m > 0.01;
const topsDiffer = Math.abs((CML_TOP_DEPTH || 0) - (LOSS_TOP_DEPTH_m || 0)) > 10;

if (cmlActive && lossActive && !topsDiffer) {
  // ✅ UNIFIED: Both active and at same depth
  const levelY = mapDepthToY(Math.min(LOSS_TOP_DEPTH_m, TD_DEPTH));
  
  noStroke(); fill(0, 0, 0, 80);
  if (LOSS_TOP_DEPTH_m <= BOP_DEPTH) {
    if (wLeftAnn > 0) rect(xLeftAnn, well.y, wLeftAnn, levelY - well.y);
    if (wRightAnn > 0) rect(xRightAnn, well.y, wRightAnn, levelY - well.y);
  } else {
    const yBOP = mapDepthToY(BOP_DEPTH);
    if (wLeftAnn > 0) rect(xLeftAnn, yBOP, wLeftAnn, levelY - yBOP);
    if (wRightAnn > 0) rect(xRightAnn, yBOP, wRightAnn, levelY - yBOP);
  }
  
  stroke(30, 100, 90); strokeWeight(2); // Orange (CML+Loss)
  if (wLeftAnn > 0) line(xLeftAnn + 3, levelY, xLeftAnn + wLeftAnn - 3, levelY);
  if (wRightAnn > 0) line(xRightAnn + 3, levelY, xRightAnn + wRightAnn - 3, levelY);
  
  noStroke(); fill(30, 100, 95); textAlign(LEFT, CENTER); textSize(11);
  text(`Fluid top ↓ ${nf(LOSS_TOP_DEPTH_m,1,1)} m (CML+Loss)`, xRightAnn + 6, levelY);
  textAlign(CENTER, CENTER);
  
} else {
  // ✅ SEPARATE: Show individually if different
  
  if (cmlActive) {
    const levelY_cml = mapDepthToY(Math.min(CML_TOP_DEPTH, BOP_DEPTH));
    noStroke(); fill(0, 0, 0, 80);
    if (wLeftAnn > 0) rect(xLeftAnn, well.y, wLeftAnn, levelY_cml - well.y);
    if (wRightAnn > 0) rect(xRightAnn, well.y, wRightAnn, levelY_cml - well.y);
    
    stroke(180, 80, 90); strokeWeight(2);
    if (wLeftAnn > 0) line(xLeftAnn + 3, levelY_cml, xLeftAnn + wLeftAnn - 3, levelY_cml);
    if (wRightAnn > 0) line(xRightAnn + 3, levelY_cml, xRightAnn + wRightAnn - 3, levelY_cml);
    
    noStroke(); fill(180, 80, 95); textAlign(LEFT, CENTER); textSize(11);
    text(`CML top ↓ ${nf(CML_TOP_DEPTH,1,1)} m`, xRightAnn + 6, levelY_cml);
    textAlign(CENTER, CENTER);
  }
  
  if (lossActive && topsDiffer) {
    const levelY_loss = mapDepthToY(Math.min(LOSS_TOP_DEPTH_m, TD_DEPTH));
    noStroke(); fill(0, 0, 0, 60);
    
    if (LOSS_TOP_DEPTH_m <= BOP_DEPTH) {
      if (wLeftAnn > 0) rect(xLeftAnn, well.y, wLeftAnn, levelY_loss - well.y);
      if (wRightAnn > 0) rect(xRightAnn, well.y, wRightAnn, levelY_loss - well.y);
    } else {
      const yBOP = mapDepthToY(BOP_DEPTH);
      if (wLeftAnn > 0) rect(xLeftAnn, yBOP, wLeftAnn, levelY_loss - yBOP);
      if (wRightAnn > 0) rect(xRightAnn, yBOP, wRightAnn, levelY_loss - yBOP);
    }
    
    stroke(0, 100, 90); strokeWeight(2);
    if (wLeftAnn > 0) line(xLeftAnn + 3, levelY_loss, xLeftAnn + wLeftAnn - 3, levelY_loss);
    if (wRightAnn > 0) line(xRightAnn + 3, levelY_loss, xRightAnn + wRightAnn - 3, levelY_loss);
    
    noStroke(); fill(0, 100, 95); textAlign(LEFT, CENTER); textSize(11);
    text(`Loss top ↓ ${nf(LOSS_TOP_DEPTH_m,1,1)} m`, xRightAnn + 6, levelY_loss);
    textAlign(CENTER, CENTER);
  }
}
  
  

// MPD RCD cap
if (MPD_ON){
  const capY = well.y - 8;
  const xL = well.x + 2;
  const xR = well.x + well.w - 2;
  noStroke(); fill(0, 80, 80, 230); rect(xL, capY, xR - xL, 14, 3);
  fill(0,0,100); textSize(12); textAlign(CENTER, BASELINE); text("RCD", (xL + xR)/2, capY + 12);
  textAlign(CENTER, CENTER);
}

drawCMLVisual();
}

function drawFractureSymbols(){
  if (!LOSSES_ON || !Array.isArray(lossZones)) return;
  
  const symbolSize = 24;
  const xPos = well.x + well.w + 30; // To the right of the well
  
  for (const z of lossZones) {
    if (!z || !z.enabled || !(z.depth_m > 0)) continue;
    
    const y = mapDepthToY(z.depth_m);
    const isActive = (z.Qloss_gpm || 0) > 10; // Active if losing >10 gpm
    
    push();
    translate(xPos, y);
    
    // Draw explosion/burst symbol
    if (isActive) {
      // Active fracture - animated burst
      const pulsePhase = (frameCount % 30) / 30;
      const pulse = 1 + 0.3 * Math.sin(pulsePhase * TWO_PI);
      
      // Bright red/orange burst
      fill(0, 100, 100, 200); // Red in HSB
      stroke(30, 100, 100, 255); // Orange
      strokeWeight(2);
      
      // Draw starburst
      for (let i = 0; i < 8; i++) {
        const angle = (i * TWO_PI / 8) + pulsePhase * PI;
        const r1 = symbolSize * 0.3 * pulse;
        const r2 = symbolSize * 0.6 * pulse;
        line(
          cos(angle) * r1, sin(angle) * r1,
          cos(angle) * r2, sin(angle) * r2
        );
      }
      
      // Center circle
      noStroke();
      fill(0, 100, 100, 255);
      circle(0, 0, symbolSize * 0.4 * pulse);
      
    } else {
      // Dormant fracture - static crack symbol
      stroke(0, 0, 60, 180); // Gray
      strokeWeight(2);
      noFill();
      
      // Draw crack lines
      beginShape();
      vertex(-symbolSize/3, -symbolSize/3);
      vertex(0, 0);
      vertex(symbolSize/3, -symbolSize/4);
      endShape();
      
      beginShape();
      vertex(0, 0);
      vertex(-symbolSize/4, symbolSize/3);
      endShape();
      
      beginShape();
      vertex(0, 0);
      vertex(symbolSize/4, symbolSize/4);
      endShape();
    }
    
    // Label
    noStroke();
    fill(isActive ? color(0, 100, 100) : color(0, 0, 80));
    textSize(10);
    textAlign(LEFT, CENTER);
    const qStr = isActive ? ` (${nf(z.Qloss_gpm, 1, 0)} gpm)` : '';
    text(`${nf(z.depth_m, 1, 0)}m${qStr}`, symbolSize/2 + 8, 0);
    
    pop();
  }
}

function drawCMLVisual(){
  if (!CML_ON) return;
  const yPump = mapDepthToY(CML_DEPTH);
  const pumpX = well.x + well.w + 8;
  const pumpSize = 16;
  noStroke(); fill(55, 100, 100, 240);
  rect(pumpX, yPump - pumpSize/2, pumpSize, pumpSize, 3);

  const pipeW = 12, pipeX = pumpX + pumpSize + 10;
  stroke(0,0,50,160); noFill();
  const yTop = well.y;
  rect(pipeX - pipeW/2, yTop, pipeW, yPump - yTop, 3);
  noStroke();
  for (let i = 0; i < N_ABV; i++){
    const dTop = i * CELL_M;
    const dBot = Math.min((i+1) * CELL_M, BOP_DEPTH);
    if (dTop >= CML_DEPTH) break;
    const segTop = mapDepthToY(dTop);
    const segBot = mapDepthToY(Math.min(dBot, CML_DEPTH));
    const hue = remap(cmlPipeGrid[i], MW_MIN, MW_MAX, 170, 355);
    fill(hue, 70, 70, 210);
    rect(pipeX - pipeW/2 + 1, segTop, pipeW - 2, segBot - segTop);
  }
  stroke(55,100,100); strokeWeight(2);
  line(pipeX, yTop + 8, pipeX, yTop + 28);
  line(pipeX - 5, yTop + 14, pipeX, yTop + 8);
  line(pipeX + 5, yTop + 14, pipeX, yTop + 8);
}

function drawBottomFrames(){
  stroke(0,0,100); noFill();
  rect(rheoFrameX, frameY, rheoFrameW, frameHeight, 8);
  rect(gelFrameX, frameY, gelFrameW, frameHeight, 8);
  rect(geomFrameX, frameY, geomFrameW, frameHeight, 8);
  noStroke(); fill(0,0,95); textAlign(CENTER, TOP); textSize(12);
  text("Rheology Configurations", rheoFrameX + rheoFrameW/2, frameY + frameHeight + 10);
  text("Gel Configurations", gelFrameX + gelFrameW/2, frameY + frameHeight + 10);
  text("Well Geometry", geomFrameX + geomFrameW/2, frameY + frameHeight + 10);
  const badgeX = rheoFrameX + 350;
  const badgeY = frameY + 38;
  drawBadge(badgeX, badgeY, `Friction: ${FRICTION_MODE}, Model: ${HYDRAULICS_MODEL} | Rheo: ${ACTIVE_RHEO_MODEL}`);
}




function drawEnhancedHydraulicsFrame(){
  stroke(0,0,100); noFill();
  rect(ehFrameX, ehFrameY, ehFrameW, ehFrameH, 8);
  noStroke(); fill(0,0,95); textAlign(CENTER, TOP); textSize(12);
  text("Enhanced Hydraulics controls", ehFrameX + ehFrameW/2, ehFrameY + ehFrameH + 10);
  textAlign(LEFT, TOP); fill(0,0,95); textSize(12);
  const st = (k) => EH[k].on ? 'ON' : 'OFF';
  const sv = (k) => nf(EH[k].s, 1, 2);
  const ehStatus =
    `ECC: ${st('ECC')} (s=${sv('ECC')}) | ` +
    `ROUGH: ${st('ROUGH')} (s=${sv('ROUGH')}) | ` +
    `KLOSS: ${st('KLOSS')} (s=${sv('KLOSS')}) | ` +
    `P-only: ${st('PCOR')} (s=${sv('PCOR')}) | Fluid: ${EH.PCOR.fluid}`;
  text(ehStatus, ehFrameX + 12, ehFrameY + ehFrameH - 22);
  textAlign(CENTER, CENTER);
}

function drawDepthGrid(){
  fill(0,0,80); noStroke(); textSize(12);
  for (let d=0; d<=MAX_DEPTH; d+=1000){
    const y = mapDepthToY(d);
    text(d+" m", well.x -75, y);
    stroke(0,0,60,120); line(well.x-40, y, well.x+well.w+40, y); noStroke();
  }
}

function drawReferenceBadges(){
  const starX = well.x - 40;
  for (const m of MARKS){
    const y = mapDepthToY(m.d);
    drawStar(starX, y);
    const p = pressureAtDepth(m.d);
    const ecdEff = ecdWithSBPAtDepth(m.d);
    drawBadge(well.x + well.w/2, y, `${m.name} • ${nf(p,0,0)} psi`, `Eff. ECD • ${nf(ecdEff,1,2)} ppg`);
  }
}

function drawGaugesAndCharts(){
  // use the SAME spacing as the top gauges
  const colGap = 40;                            // same as gap between SPP and Booster SPP
  const baseX  = well.x + well.w + 150;        // same as cxSPP

  // Top gauges (unchanged, but now derived from baseX)
  const cxSPP = baseX;
  const cyTop = well.y + 48;
  const vSPPraw = surfacePumpPressure();
  lastSPP = updateSPP(vSPPraw);
  drawGauge(cxSPP, cyTop, lastSPP, 16000, "SPP", "psi", R, "left");
  if (levelDeficit_m > 0.01){
    textAlign(LEFT, CENTER); textSize(11); fill(0,0,95);
    text(`DS level ↓ ${nf(levelDeficit_m,1,1)} m`, cxSPP -30, cyTop + 40);
    textAlign(CENTER, CENTER);
  }

  const cxBo = baseX + 2*R + colGap;           // Booster aligned to the right of SPP
  const vBoRaw = boosterPumpPressure();
  const vBo = updateBoosterSPP(vBoRaw);
  drawGauge(cxBo, cyTop, vBo, 16000, "Booster SPP", "psi", R, "right");
  if (levelDeficit_bo_m > 0.01){
    textAlign(LEFT, CENTER); textSize(11); fill(0,0,95);
    text(`Bo level ↓ ${nf(levelDeficit_bo_m,1,1)} m`, cxBo -30 , cyTop + 40);
    textAlign(CENTER, CENTER);
  }

  
  
  // Depth gauges — centers aligned UNDER the top gauges now
  const colLeft  = baseX;                       // under SPP
  const colRight = baseX + 2*R + colGap;        // under Booster
  drawGauge(colLeft,  mapDepthToY(BOP_DEPTH),  pressureAtDepth(BOP_DEPTH),  16000, " ", "psi", R, "left");
  drawGauge(colLeft,  mapDepthToY(BOP_DEPTH),  pressureAtDepth(BOP_DEPTH),  16000, " ", "psi", R, "left");
  drawGauge(colLeft,  mapDepthToY(SHOE_DEPTH), pressureAtDepth(SHOE_DEPTH), 16000, " ", "psi", R, "left");
  drawGauge(colLeft,  mapDepthToY(TD_DEPTH),   pressureAtDepth(TD_DEPTH),   16000, " ", "psi", R, "left");

  drawGauge(colRight, mapDepthToY(BOP_DEPTH),  ecdWithSBPAtDepth(BOP_DEPTH), 18, "BOP",  "ppg", R, "right");
  drawGauge(colRight, mapDepthToY(SHOE_DEPTH), ecdWithSBPAtDepth(SHOE_DEPTH),18, "Shoe", "ppg", R, "right");
  drawGauge(colRight, mapDepthToY(TD_DEPTH),   ecdWithSBPAtDepth(TD_DEPTH),  18, "TD",   "ppg", R, "right");

  drawStatusPanelRight(colRight);

  // === Loss-zone markers on depth charts ===
function drawLossMarkersOnPressure(px, py, w, h, padL, padR, padT, padB, xMinPsi, xMaxPsi, col) {
  if (!LOSSES_ON) return;
  push();
  stroke(col || color(60, 100, 0));
  strokeWeight(1.5);
  fill(255, 200);
  textSize(10);
  textAlign(LEFT, CENTER);

  const x0 = px + padL, x1 = px + w - padR;
  const y0 = py + padT, y1 = py + h - padB;

  for (const z of lossZones) {
    if (!z.enabled || z.depth_m <= 0 || z.fracPressure_psi <= 0) continue;
    // map depth -> y (0 at surface at top of chart)
    const y = map(z.depth_m, 0, TD_DEPTH, y0, y1);
    // map fracture pressure -> x
    const x = map(z.fracPressure_psi, xMinPsi, xMaxPsi, x0, x1);

    // crosshair
    stroke(255, 120, 120, 200);
    line(x - 6, y, x + 6, y);
    line(x, y - 6, x, y + 6);

    // label
    noStroke();
    fill(255, 180);
    text(`${nf(z.fracPressure_psi,1,0)} psi @ ${nf(z.depth_m,1,0)} m`, x + 8, y);
  }
  pop();
}

function drawLossMarkersOnECD(px, py, w, h, padL, padR, padT, padB, xMinPpg, xMaxPpg, col) {
  if (!LOSSES_ON) return;
  push();
  stroke(col || color(0, 80, 80));
  strokeWeight(1.5);
  fill(255, 200);
  textSize(10);
  textAlign(LEFT, CENTER);

  const x0 = px + padL, x1 = px + w - padR;
  const y0 = py + padT, y1 = py + h - padB;

  for (const z of lossZones) {
    if (!z.enabled || z.depth_m <= 0 || z.fracPressure_psi <= 0) continue;

    // Convert fracture pressure at that depth to "fracture gradient" in ppg for the ECD panel
    // FG_ppg = P_frac / (PSI_COEF * depth)
    const fg_ppg = z.depth_m > 0 ? (z.fracPressure_psi / (PSI_COEF * z.depth_m)) : NaN;
    if (!isFinite(fg_ppg)) continue;

    const y = map(z.depth_m, 0, TD_DEPTH, y0, y1);
    const x = map(fg_ppg, xMinPpg, xMaxPpg, x0, x1);

    // crosshair
    stroke(255, 120, 120, 200);
    line(x - 6, y, x + 6, y);
    line(x, y - 6, x, y + 6);

    // label
    noStroke();
    fill(255, 180);
    text(`${nf(fg_ppg,1,2)} ppg @ ${nf(z.depth_m,1,0)} m`, x + 8, y);
  }
  pop();
}

  
  
  // Charts follow to the right of the right column
  const chartX = colRight + (R*2) + 20;
  drawCharts(chartX);
}


function drawStatusPanelRight(colRight){
  const x = colRight + R -240 ; // More spacing from gauges
  const y = well.y + 200; // Lower position
  
  textAlign(LEFT, TOP); 
  textSize(12); 
  fill(0,0,95);
  
  text(`Annulus MW above BOP: ${nf(average(annAboveGrid),1,2)} ppg`, x, y);
  
  let y2 = y + 20;
  text(`SBP Applied: ${nf(CURRENT_SBP,1,0)} psi | Mode: ${SBP_MODE.toUpperCase()}`, x, y2);
  
  y2 += 20;
  if (ANCHOR_DEPTH > 0 && ANCHOR_ECD > 0){
    text(`SBP Anchor: ${ANCHOR_DEPTH} m @ ${nf(ANCHOR_ECD,1,2)} ppg`, x, y2);
  }
  
  y2 += 15;
  const topDepth = riserTopDepth();
  const cmlMode = AUTO_CML_ON ? "AUTO" : "MANUAL";
  let cmlExtra = "";
  if (AUTO_CML_ON && CML_AP_DEPTH > 0 && CML_AP_ECD > 0){
    cmlExtra = ` | Anchor: ${nf(CML_AP_DEPTH,1,0)} m @ ${nf(CML_AP_ECD,1,2)} ppg`;
  }
  text(`CML Mode: ${cmlMode} | Pump @ ${nf(CML_DEPTH,1,0)} m`, x, y2);
  
  y2 += 16;
  text(`Q_out: ${nf(Q_CML,1,0)} gpm | Riser top: ${nf(topDepth,1,1)} m${cmlExtra}`, x, y2);
  
  textAlign(CENTER, CENTER);
  // Overpressure warnings hidden for now
  // if (LOSSES_ON) {
  //   for (const z of lossZones) {
  //     if (!z || !z.enabled) continue;
  //     const P = pressureAtDepth(z.depth_m);
  //     if (P > z.fracPressure_psi + 50) { // 50 psi tolerance
  //       push();
  //       fill(0, 100, 100); // RED warning
  //       textSize(12);
  //       text(`⚠ OVERPRESSURE at ${z.depth_m}m: ${nf(P,1,0)} > ${nf(z.fracPressure_psi,1,0)} psi`,
  //            x, y + 100);
  //       pop();
  //     }
  //   }
  // }
}


function drawLossMarkersOnECD(px, py, w, h, padL, padR, padT, padB, xMinPpg, xMaxPpg, col) {
  if (!LOSSES_ON) return;
  push();
  stroke(col || color(0, 80, 80));
  strokeWeight(1.5);
  fill(255, 200);
  textSize(10);
  textAlign(LEFT, CENTER);

  const x0 = px + padL, x1 = px + w - padR;
  const y0 = py + padT, y1 = py + h - padB;

  for (const z of lossZones) {
    if (!z.enabled || z.depth_m <= 0 || z.fracPressure_psi <= 0) continue;

    // Convert fracture pressure to gradient (ppg) at that depth
    const fg_ppg = z.depth_m > 0 ? (z.fracPressure_psi / (PSI_COEF * z.depth_m)) : NaN;
    if (!isFinite(fg_ppg)) continue;

    const y = map(z.depth_m, 0, TD_DEPTH, y0, y1);
    const x = map(fg_ppg, xMinPpg, xMaxPpg, x0, x1);

    stroke(255, 120, 120, 200);
    line(x - 6, y, x + 6, y);
    line(x, y - 6, x, y + 6);

    noStroke();
    fill(255, 180);
    text(`${nf(fg_ppg,1,2)} ppg @ ${nf(z.depth_m,1,0)} m`, x + 8, y);
  }
  pop();
}

// === Panel-aware polyline plotter for time-series (newest at left index 0) ===
function plotSeriesInPanel(px, py, w, h, padL, padR, padT, padB, data, ymin, ymax, col) {
  if (!data || !data.length) return;
  const x0 = px + padL, x1 = px + w - padR;
  const y0 = py + padT, y1 = py + h - padB;
  push();
  if (col) stroke(col); else stroke(255);
  noFill();
  beginShape();
  const N = data.length;
  for (let i = 0; i < N; i++) {
    const x = map(i, 0, N - 1, x0, x1);                 // oldest on right
    const yv = constrain(data[i], ymin, ymax);
    const y = map(yv, ymin, ymax, y1, y0);
    vertex(x, y);
  }
  endShape();
  pop();
}


function drawCharts(x0){
  const top = 150;
  const h = 420;
  const wP = 260, wE = 340, gap = 40;
  const padL = 54, padR = 18, padT = 28, padB = 42;
  const axisCol = color(0, 0, 95);
  const gridCol = color(0, 0, 60, 120);
  const lineColP = color(0, 80, 80);

  const dx = 70;

  // -------- Pressure-depth (psi) --------
  const px = x0 + dx, py = top;
  drawChartPanel(px, py, wP, h, "Pressure (psi)");
  drawChartGrid(px, py, wP, h, padL, padR, padT, padB, gridCol);
  plotDepthFunction(px, py, wP, h, padL, padR, padT, padB, d => pressureAtDepth(d), 0, 16000, lineColP);
  drawAxes(px, py, wP, h, padL, padR, padT, padB, axisCol);
  drawDepthTicks(px, py, wP, h, padL, padR, padT, padB, axisCol);
  drawXTicks(px, py, wP, h, padL, padR, padT, padB, axisCol, 0, 16000, [0, 4000, 8000, 12000, 16000]);

  if (showCaptured && capturedP){
    plotDepthOverlay(px, py, wP, h, padL, padR, padT, padB, capturedP, 0, 16000, color(55,80,80));
  }
// --- Loss markers on PRESSURE chart (yellow star at Pressure×Depth) ---
{
  const xL = px + padL, xR = px + wP - padR;
  const yT = py + padT, yB = py + h - padB;
  const pMin = 0, pMax = 16000;

  if (LOSSES_ON && Array.isArray(lossZones)) {
    for (const z of lossZones) {
      if (!z || !z.enabled || !(z.depth_m > 0) || !(z.fracPressure_psi > 0)) continue;

      const y = map(z.depth_m, 0, MAX_DEPTH, yT, yB, true);
      const x = map(z.fracPressure_psi, pMin, pMax, xL, xR, true);

      // yellow star
      if (typeof drawStar === 'function') {
        drawStar(x, y, 7, 3.5, 5, color(60, 100, 100));
      } else {
        // fallback: small yellow cross
        push(); stroke(color(60,100,100)); strokeWeight(2);
        line(x-6,y, x+6,y); line(x,y-6, x,y+6); pop();
      }

      // small label
      push();
      noStroke(); fill(0,0,95); textSize(10); textAlign(LEFT, BOTTOM);
      const q = (z.Qloss_gpm || 0);
      text(`Loss @ ${nf(z.depth_m,1,0)} m (${q>0 ? `≈${nf(q,1,0)} gpm` : '≈0 gpm'})`, x + 8, y - 2);
      pop();
    }
  }
}

  
  

  // -------- ECD-depth (ppg) --------
  const ex = px + wP + gap, ey = top;
  drawChartPanel(ex, ey, wE, h, "ECD (ppg)");
  drawChartGrid(ex, ey, wE, h, padL, padR, padT, padB, gridCol);
  plotDepthFunctionMasked(ex, ey, wE, h, padL, padR, padT, padB, d => ecdWithSBPAtDepth(d), 6, 18, color(0, 80, 80), v => isFinite(v) && v > 6 && v <= 18 );
  drawAxes(ex, ey, wE, h, padL, padR, padT, padB, axisCol);
  drawDepthTicks(ex, ey, wE, h, padL, padR, padT, padB, axisCol);
  drawXTicks(ex, ey, wE, h, padL, padR, padT, padB, axisCol, 6, 18, [6, 9, 12, 15, 18]);

  if (showCaptured && capturedECD){
    plotDepthOverlayMasked(ex, ey, wE, h, padL, padR, padT, padB, capturedECD, 6, 18, color(55,80,80), v => isFinite(v) && v > 6 && v <= 18 );
  }

// --- Loss markers on ECD chart (yellow star at FG_ppg×Depth) ---
{
  const xL = ex + padL, xR = ex + wE - padR;
  const yT = ey + padT, yB = ey + h - padB;
  const eMin = 6, eMax = 18;

  if (LOSSES_ON && Array.isArray(lossZones)) {
    for (const z of lossZones) {
      if (!z || !z.enabled || !(z.depth_m > 0) || !(z.fracPressure_psi > 0)) continue;

      // fracture gradient in ppg at the selected depth
      const fg_ppg = z.depth_m > 0 ? (z.fracPressure_psi / (PSI_COEF * z.depth_m)) : NaN;
      if (!isFinite(fg_ppg)) continue;

      const y = map(z.depth_m, 0, MAX_DEPTH, yT, yB, true);
      const x = map(fg_ppg, eMin, eMax, xL, xR, true);

      // yellow star
      if (typeof drawStar === 'function') {
        drawStar(x, y, 7, 3.5, 5, color(60, 100, 100));
      } else {
        // fallback: small yellow cross
        push(); stroke(color(60,100,100)); strokeWeight(2);
        line(x-6,y, x+6,y); line(x,y-6, x,y+6); pop();
      }

      // small label
      push();
      noStroke(); fill(0,0,95); textSize(10); textAlign(LEFT, BOTTOM);
      text(`${nf(fg_ppg,1,2)} ppg @ ${nf(z.depth_m,1,0)} m`, x + 8, y - 2);
      pop();
    }
  }
}

function _tsCap(){ return (typeof TS_MAX === 'number' && TS_MAX > 0) ? TS_MAX : 600; }
// --- Losses time series (gpm) ---
if (!Array.isArray(window.tsLoss_gpm)) window.tsLoss_gpm = [];

  
  // -------- TIME SERIES panel --------
  const timeChartX = ex + wE + 40; // inherits +dx via px/ex
  drawTimeChart(timeChartX, top, 640, h);
}



// ---------- Helpers used by charts ----------
function drawChartPanel(x, y, w, h, title){
  noStroke(); fill(0,0,20,200); rect(x-10, y-14, w+20, h+44, 10);
  fill(0,0,0); rect(x, y, w, h, 8);
  fill(0,0,95); noStroke(); textSize(14); textAlign(CENTER, TOP);
  text(title, x + w/2, y + h + 6);
}
function drawChartGrid(x,y,w,h,padL,padR,padT,padB,col){
  const innerW=w-padL-padR, innerH=h-padT-padB;
  const left=x+padL, top=y+padT, right=x+w-padR, bottom=y+h-padB;
  stroke(col); strokeWeight(1);
  for (let i=1; i<4; i++){ const xx = left + (innerW*i)/4; line(xx, top, xx, bottom); }
  for (let d=1000; d<MAX_DEPTH; d+=1000){
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    line(left, yy, right, yy);
  }
}
function drawAxes(x,y,w,h,padL,padR,padT,padB,col){
  const left = x + padL, top = y + padT, right = x + w - padR, bottom = y + h - padB;
  stroke(col); strokeWeight(2);
  line(left, top, left, bottom);
  line(left, bottom, right, bottom);
}
function drawDepthTicks(x,y,w,h,padL,padR,padT,padB,col){
  const innerH=h-padT-padB, left=x+padL, top=y+padT;
  fill(col); noStroke(); textSize(11); textAlign(RIGHT, CENTER);
  stroke(col); strokeWeight(1.5);
  for (let d=0; d<=MAX_DEPTH; d+=1000){
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    line(left-5, yy, left, yy);
    noStroke(); text(`${d}`, left-8, yy); stroke(col);
  }
}
function drawXTicks(x,y,w,h,padL,padR,padT,padB,col,vmin,vmax,ticks){
  const innerW=w-padL-padR, left=x+padL, bottom=y+h-padB;
  fill(col); noStroke(); textSize(11); textAlign(CENTER, TOP);
  stroke(col); strokeWeight(1.5);
  for (const t of ticks){
    const xx = left + remap(t, vmin, vmax, 0, innerW, true);
    line(xx, bottom, xx, bottom+5);
    noStroke(); text(`${t}`, xx, bottom+8); stroke(col);
  }
}

function plotDepthFunction(x,y,w,h,padL,padR,padT,padB,f,xmin,xmax,col){
  const innerW=w-padL-padR, innerH=h-padT-padB;
  const left=x+padL, top=y+padT, right=x+w-padR, bottom=y+h-padB;
  
  noFill(); stroke(col); strokeWeight(3); beginShape();
  for (let d=0; d<=MAX_DEPTH; d+=25){
    const val = f(d);
    const xx = left + remap(val, xmin, xmax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true); // 0 at top
    vertex(xx, yy);
  }
  endShape();
  
  // TD line
  const yTD = top + innerH; // At bottom
  stroke(0,0,95); strokeWeight(2.5); 
  line(left, yTD, right, yTD);
}

function plotDepthFunctionMasked(x,y,w,h,padL,padR,padT,padB,f,xmin,xmax,col, valid){
  const innerW=w-padL-padR, innerH=h-padT-padB;
  const left=x+padL, top=y+padT, right=x+w-padR;
  let drawing = false;
  stroke(col); strokeWeight(3); noFill();
  for (let d=0; d<=MAX_DEPTH; d+=25){
    const val = f(d), ok = valid(val);
    const xx = left + remap(val, xmin, xmax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    if (ok){
      if (!drawing){ beginShape(); drawing = true; }
      vertex(xx, yy);
    } else {
      if (drawing){ endShape(); drawing = false; }
    }
  }
  if (drawing) endShape();
  const yTD = top + remap(TD_DEPTH, 0, MAX_DEPTH, 0, innerH, true);
  stroke(0,0,95); strokeWeight(2.5); line(left, yTD, right, yTD);
}
function plotDepthOverlay(x,y,w,h,padL,padR,padT,padB,arr,ymin,ymax,col){
  const step = 25, innerW = w - padL - padR, innerH = h - padT - padB;
  const left = x + padL, top = y + padT;
  noFill(); stroke(col); strokeWeight(2); beginShape();
  for (let i=0, d=0; d<=MAX_DEPTH; i++, d+=step){
    const val = arr[i];
    const xx = left + remap(val, ymin, ymax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    vertex(xx, yy);
  } endShape();
}
function plotDepthOverlayMasked(x,y,w,h,padL,padR,padT,padB,arr,ymin,ymax,col, valid){
  const step = 25, innerW = w - padL - padR, innerH = h - padT - padB;
  const left = x + padL, top = y + padT;
  let drawing = false;
  stroke(col); strokeWeight(2); noFill();
  for (let i=0, d=0; d<=MAX_DEPTH; i++, d+=step){
    const val = arr[i], ok = valid(val);
    const xx = left + remap(val, ymin, ymax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    if (ok){
      if (!drawing){ beginShape(); drawing = true; }
      vertex(xx, yy);
    } else {
      if (drawing){ endShape(); drawing = false; }
    }
  }
  if (drawing) endShape();
}
function drawBadge(cx, cy, line1, line2, withStar=false){
  push(); translate(cx,cy);
  const boxW=190, boxH=38;
  if (withStar){ noStroke(); fill(55,80,90); star(-boxW/2-12,0,4,9,5); }
  fill(0,0,20,230); rect(-boxW/2,-boxH/2,boxW,boxH,6);
  fill(0,0,95); textAlign(CENTER,CENTER); textSize(12); text(line1,0,-6);
  textSize(10); fill(0,0,80); text(line2,0,10);
  pop();
}
function drawGauge(cx, cy, value, vMax, label, units, r, labelSide){
  noFill(); stroke(0,0,95); strokeWeight(2.5); arc(cx,cy,r*2,r*2,PI,TWO_PI);
  strokeWeight(6); stroke(120,60,80); arc(cx,cy,r*2,r*2, PI,PI+0.33*PI);
  stroke(40,70,80); arc(cx,cy,r*2,r*2, PI+0.33*PI,PI+0.66*PI);
  stroke(0,80,80); arc(cx,cy,r*2,r*2, PI+0.66*PI,TWO_PI);
  const norm = clamp(value/Math.max(1e-9,vMax),0,1);
  const ang = PI + norm*PI;
  stroke(0,0,95); strokeWeight(2.5); line(cx,cy,cx+r*cos(ang),cy+r*sin(ang));
  noStroke(); fill(0,0,95); circle(cx,cy,7);
  fill(0,0,95); textSize(Math.max(12,Math.round(r*0.26)));
  const dec=(units==='ppg'?2:0); text(`${nf(value,0,dec)} ${units}`,cx,cy+(r*0.35));
  fill(0,0,80); textSize(Math.max(10,Math.round(r*0.18)));
  textAlign(labelSide==="left"?RIGHT:LEFT,CENTER);
  const lx=labelSide==="left"?(cx-r-14):(cx+r+14);
  text(label,lx,cy);
  textAlign(CENTER,CENTER);
}
function drawStar(x,y){ push(); noStroke(); fill(55, 80, 90); star(x, y, 4, 9, 5); pop(); }
function star(x,y,r1,r2,n){
  let a=TWO_PI/n, h=a/2; beginShape();
  for(let ang=0; ang<TWO_PI; ang+=a){
    vertex(x+cos(ang)*r2, y+sin(ang)*r2);
    vertex(x+cos(ang+h)*r1, y+sin(ang+h)*r1);
  } endShape(CLOSE);
}

// ---------- Safe CML series buffers (avoid TDZ) ----------
function ensureCMLSeries(){
  if (!Array.isArray(window.tsCMLPact)) window.tsCMLPact = [];
  if (!Array.isArray(window.tsCMLPset)) window.tsCMLPset = [];
}

function drawTimeChart(x, y, w, h){
  drawChartPanel(x, y, w, h, "Time Series");

  const padL = 54, padR = 18, padT = 38, padB = 42;
  const innerW = w - padL - padR;
  const innerH = h - padT - padB;
  const left = x + padL, topI = y + padT, right = x + w - padR, bottom = y + h - padB;

  // Grid
  const gridCol = color(0, 0, 30, 120);
  stroke(gridCol); strokeWeight(1);
  for (let i=1; i<4; i++){
    const xx = left + innerW*i/4;
    line(xx, topI, xx, bottom);
  }
  for (let i=1; i<6; i++){
    const yy = topI + innerH*i/6;
    line(left, yy, right, yy);
  }

  // Axes
  stroke(0, 0, 95); strokeWeight(2);
  line(left, topI, left, bottom);
  line(left, bottom, right, bottom);

  // Scales
  const maxQ = Math.max(100, (typeof Q_MAX!=='undefined' && Q_MAX>0 ? Q_MAX : 1000) * 1.1);
  const maxP = 16000;

  // Panel-aware plot util (newest sample at index 0 → right side)
  const plotSeriesLHS = (data, col, maxVal) => {
    if (!data || !data.length) return;
    noFill(); stroke(col); strokeWeight(2);
    beginShape();
    const N = Math.min(data.length, (typeof TS_MAX!=='undefined'?TS_MAX:600));
    for (let i=0; i<N; i++){
      const val = data[i];
      if (!isFinite(val)) continue;
      const t = i / Math.max(1, N - 1);
      const xx = right - t * innerW;            // right-to-left time
      const yy = bottom - remap(val, 0, maxVal, 0, innerH, true);
      vertex(xx, yy);
    }
    endShape();
  };

  // Core series (left scale for flow, right now we just use left-scale)
  plotSeriesLHS(tsData.totalFlowIn || [], color(180, 60, 90), maxQ);
  plotSeriesLHS(tsData.dsFlow       || [], color(200, 70, 85), maxQ);
  plotSeriesLHS(tsData.cmlFlow      || [], color(50,  80, 80), maxQ);
  // Losses (left scale, gpm) — use the same flow scale (maxQ or QMAX)
plotSeriesLHS(window.tsLoss_gpm || [], color(340, 75, 90), maxQ);


  // Pressure series (left scale = makes them small visually; if you want a true RHS, we can add it)
  plotSeriesLHS(tsData.spp          || [], color(30,  80, 90), maxP);
  plotSeriesLHS(tsData.sbpSetpoint  || [], color(280, 70, 85), maxP);
  plotSeriesLHS(tsData.sbpApplied   || [], color(300, 70, 80), maxP);
  plotSeriesLHS(tsData.cmlAnchorSet || [], color(210, 85, 85), maxP);
  plotSeriesLHS(tsData.cmlAnchorActual||[], color(25,  85, 90), maxP);
  plotSeriesLHS(tsData.sbpAPSet     || [], color(55,  100,80), maxP);
  plotSeriesLHS(tsData.sbpAPActual  || [], color(120, 60, 80), maxP);

  // === Overlays: Flow Out & Choke, inside this panel ===
  const QMAX = (typeof Q_MAX !== 'undefined' && Q_MAX > 0) ? Q_MAX : 1000;

  // Flow Out (left scale, gpm)
  if (Array.isArray(tsFlowOut_gpm)) {
    plotSeriesLHS(tsFlowOut_gpm, color(200, 60, 95), QMAX);
  }

  // Choke Position (%) — map to left scale for now (0–100 → 0–QMAX)
  if (Array.isArray(tsChoke_pct)) {
    const mapped = tsChoke_pct.map(v => v * QMAX / 100);
    plotSeriesLHS(mapped, color(40, 90, 85), QMAX);
  }

  // Legends (panel-local)
  const legend = [
    {label: 'Total Flow In', col: color(180, 60, 90)},
    {label: 'DS Flow', col: color(200, 70, 85)},
    {label: 'CML Flow', col: color(50, 80, 80)},
    {label: 'SPP', col: color(30, 80, 90)},
    {label: 'SBP Setpoint', col: color(280, 70, 85)},
    {label: 'SBP Applied', col: color(300, 70, 80)},
    {label: 'CML Anchor Set', col: color(210, 85, 85)},
    {label: 'CML Anchor Actual', col: color(25, 85, 90)},
    {label: 'SBP AP Set', col: color(55, 100, 80)},
    {label: 'SBP AP Actual', col: color(120, 60, 80)},
    {label: 'Losses (gpm)', col: color(340, 75, 90) },
    {label: 'Flow Out (gpm)', col: color(200, 60, 95)},
    {label: 'Choke Position (%)', col: color(40, 90, 85)}

  ];

  const lgX = right - 200, lgY = topI + 10;
  const lgW = 190, lgH = legend.length * 16 + 10;

  noStroke(); fill(0, 0, 10, 230);
  rect(lgX, lgY, lgW, lgH, 4);

  textAlign(LEFT, CENTER); textSize(10);
  for (let i=0; i<legend.length; i++){
    const yy = lgY + 8 + i*16;
    fill(legend[i].col);
    rect(lgX + 6, yy-4, 20, 8, 2);
    fill(0, 0, 95);
    text(legend[i].label, lgX + 30, yy);
  }
}

// Panel-aware polyline plotter (newest sample at index 0)
function plotSeriesInPanel(px, py, w, h, padL, padR, padT, padB, data, ymin, ymax, col) {
  if (!data || !data.length) return;
  const x0 = px + padL, x1 = px + w - padR;
  const y0 = py + padT, y1 = py + h - padB;
  push();
  if (col) stroke(col); else stroke(255);
  noFill();
  beginShape();
  const N = data.length;
  for (let i = 0; i < N; i++) {
    const x = map(i, 0, N - 1, x0, x1);
    const yv = constrain(data[i], ymin, ymax);
    const y = map(yv, ymin, ymax, y1, y0);
    vertex(x, y);
  }
  endShape();
  pop();
}


// --------- UI BUILDERS ---------
function buildRheologyUI(x, y){
  const mk = (lbl, key, def, dx=0, w=70) => {
    mkLabel(lbl, x + dx, y - 18);
    const el = createInput(String(def), 'number').position(x + dx, y).size(w);
    rheoPanel[key] = el;
    return el;
  };
  // Fann dial set + PV/YP
  let dx = 0, step = 70, block = 90;
  mk("R600", "R600", rheoDefaults.R600, dx); dx+=step;
  mk("R300", "R300", rheoDefaults.R300, dx); dx+=step;
  mk("R200", "R200", rheoDefaults.R200, dx); dx+=step;
  mk("R100", "R100", rheoDefaults.R100, dx); dx+=step;
  mk("R6",   "R6",   rheoDefaults.R6,   dx); dx+=step;
  mk("R3",   "R3",   rheoDefaults.R3,   dx); dx+=step;
  mk("R1",   "R1",   rheoDefaults.R1,   dx); dx+=block;

  mk("PV (cP)", "PV", rheoDefaults.PV, dx); dx+=step+10;
  mk("YP (lbf/100ft²)", "YP", rheoDefaults.YP, dx, 90);

  // Model toggle + Fit + Show
  const btnY = y + 36;
  const modelBtn = createButton(`Model: ${ACTIVE_RHEO_MODEL}`).position(x, btnY).size(130, 26);
  modelBtn.mousePressed(()=>{
    ACTIVE_RHEO_MODEL = (ACTIVE_RHEO_MODEL === "HB") ? "PowerLaw" :
                        (ACTIVE_RHEO_MODEL === "PowerLaw") ? "Bingham" : "HB";
    modelBtn.html(`Model: ${ACTIVE_RHEO_MODEL}`);
  });

  const fitBtn = createButton("Fit rheology").position(x+140, btnY).size(110,26);
  fitBtn.mousePressed(doRheologyFit);

  const showBtn = createButton("Show params").position(x+260, btnY).size(110,26);
  showBtn.mousePressed(showFittedParams);

  // Status DIV
  rheoPanel.statusDiv = createDiv("").position(x, btnY + 34).style("color","#EEE").style("font-size","12px");
}

function buildEnhancedHydraulicsUI(x, y){
  const mkToggle = (k, label, row) => {
    const yy = y + row*46;
    const btn = createButton(`${label}: ${EH[k].on ? 'ON' : 'OFF'}`)
      .position(x, yy).size(180, 26);
    btn.mousePressed(()=>{ 
      EH[k].on = !EH[k].on; 
      btn.html(`${label}: ${EH[k].on ? 'ON' : 'OFF'}`); 
    });
    
    mkLabel("Adjustment (-1 to +1)", x+190, yy+4);
    const sld = createSlider(-1, 1, EH[k].s, 0.01)
      .position(x+330, yy).style('width','200px');
    sld.input(()=>{ EH[k].s = sld.value(); });
  };
  
  mkToggle("ECC", "Eccentric Annulus", 0);
  mkToggle("ROUGH", "Roughness Effect", 1);
  mkToggle("KLOSS", "Local K-Losses (SPP)", 2);
  
  // P-only corrections (row 3)
  let row = 3;
  let yy = y + row*46;
  const pbtn = createButton(`P-only Corrections: ${EH.PCOR.on ? 'ON' : 'OFF'}`)
    .position(x, yy).size(180, 26);
  pbtn.mousePressed(()=>{ 
    EH.PCOR.on = !EH.PCOR.on; 
    pbtn.html(`P-only Corrections: ${EH.PCOR.on ? 'ON' : 'OFF'}`); 
  });
  
  mkLabel("Strength (-1 to +1)", x+190, yy+4);
  const psl = createSlider(-1, 1, EH.PCOR.s, 0.01)
    .position(x+330, yy).style('width','200px');
  psl.input(()=>{ EH.PCOR.s = psl.value(); });
  
  mkLabel("Fluid Type", x+550, yy+4);
  const sel = createSelect().position(x+620, yy).size(100, 26);
  ["WBM","OBM","Diesel"].forEach(f=> sel.option(f));
  sel.value(EH.PCOR.fluid);
  sel.changed(()=>{ EH.PCOR.fluid = sel.value(); });
  
  // Gravity swap (row 4)
  row = 4;
  yy = y + row*46;
  
  // ✅ Now just create the button (EH.GRAV already exists globally)
  const gravBtn = createButton(`Gravity Swap: ${EH.GRAV.on ? 'ON' : 'OFF'}`)
    .position(x, yy).size(180, 26)
    .mousePressed(()=>{
      EH.GRAV.on = !EH.GRAV.on;
      gravBtn.html(`Gravity Swap: ${EH.GRAV.on ? 'ON' : 'OFF'}`);
    });
  
  mkLabel('Density-driven settling (slow)', x+190, yy+4);
}
// ------------------------- Build Losses UI -------------------------
function buildLossesUI() {
  const pos = lossesUIPosition();

  uiLosses.root = createDiv('').position(pos.x, pos.y).style('padding', '8px')
    .style('border', '1px solid rgba(255,255,255,0.15)')
    .style('border-radius', '8px')
    .style('background', 'rgba(0,0,0,0.25)')
    .style('backdrop-filter', 'blur(6px)')
    .style('color', '#EEE');

  uiLosses.title = createDiv('Losses (β, ΔP, Coupled)').parent(uiLosses.root)
    .style('font-weight', 'bold').style('margin-bottom', '6px');

  uiLosses.toggleBtn = createButton(LOSSES_ON ? 'Losses: ON' : 'Losses: OFF')
    .parent(uiLosses.root)
    .mousePressed(() => {
      LOSSES_ON = !LOSSES_ON;
      uiLosses.toggleBtn.html(LOSSES_ON ? 'Losses: ON' : 'Losses: OFF');
    });

  const hdr = createDiv('').parent(uiLosses.root).style('margin-top', '8px');
// header row HTML
hdr.html(`<div style="display:grid;grid-template-columns:80px 100px 90px 90px 70px 90px;gap:6px;font-size:11px;opacity:.8">
  <div>Depth (m)</div>
  <div>Frac P (psi)</div>
  <div>Qref (gpm)</div>
  <div>ΔPref (psi)</div>
  <div>n</div>
  <div>PI (gpm/psi^n)</div>
</div>`);


  for (let i=0;i<3;i++){
    const row = createDiv('').parent(uiLosses.root)
      .style('display', 'grid')
      .style('grid-template-columns', '80px 100px 90px 90px 50px')
      .style('gap', '6px')
      .style('margin-top', '4px');

    const depth = createInput('', 'number').parent(row).attribute('placeholder', 'e.g., 2950');
    const fracP = createInput('', 'number').parent(row).attribute('placeholder', 'e.g., 6500');
    const qref  = createInput('', 'number').parent(row).attribute('placeholder', 'e.g., 500');
    const dpref = createInput('', 'number').parent(row).attribute('placeholder', 'e.g., 200');
    const n     = createInput('1.0', 'number').parent(row);

    [depth, fracP, qref, dpref, n].forEach(inp => {
      inp.style('background', 'rgba(255,255,255,0.07)')
         .style('color', '#EEE')
         .style('border', '1px solid rgba(255,255,255,0.12)')
         .style('height', '22px')
         .style('padding', '0 6px')
         .style('border-radius', '6px')
         .style('font-size', '12px');
    });

    depth.input(() => { const v = Number(depth.value()); lossZones[i].enabled = !isNaN(v) && v>0; lossZones[i].depth_m = isNaN(v) ? 0 : v; });
    fracP.input(() => { lossZones[i].fracPressure_psi = Number(fracP.value()) || 0; });
    qref.input (() => { lossZones[i].Qref_gpm        = Number(qref.value())  || 0; });
    dpref.input(()=> { lossZones[i].DPref_psi        = Number(dpref.value()) || 0; });
    n.input    (() => { const nv = Number(n.value()); lossZones[i].n = (!isNaN(nv) && nv>0) ? nv : 1.0; });

    uiLosses.rows[i] = { depth, fracP, qref, dpref, n };
  }

  uiLosses.help = createDiv(
    `<div style="margin-top:8px;font-size:11px;opacity:.8">
      <b>Model:</b> Q<sub>loss</sub>=C<sub>L</sub>(ΔP)<sup>n</sup>, C<sub>L</sub>=Q<sub>ref</sub>/ΔP<sub>ref</sub><sup>n</sup>.<br/>
      Loss fluid is extracted from the cell at depth (composition-aware). Coupled iteration adjusts P at each zone.<br/>
      Riser must be full to see Flow Out at surface; compressibility uses wet volume compliance.
    </div>`
  ).parent(uiLosses.root);
}
function refreshLossesUIFromModel(){
  if (!uiLosses.root) return;
  for (let i=0;i<3;i++){
    const z = lossZones[i], r = uiLosses.rows[i]; if (!r) continue;
    if (z.depth_m>0 && r.depth.value()!==String(z.depth_m)) r.depth.value(String(z.depth_m));
    if (z.fracPressure_psi>0 && r.fracP.value()!==String(z.fracPressure_psi)) r.fracP.value(String(z.fracPressure_psi));
    if (z.Qref_gpm>0 && r.qref.value()!==String(z.Qref_gpm)) r.qref.value(String(z.Qref_gpm));
    if (z.DPref_psi>0 && r.dpref.value()!==String(z.DPref_psi)) r.dpref.value(String(z.DPref_psi));
    if (z.n>0 && r.n.value()!==String(z.n)) r.n.value(String(z.n));
  }
  uiLosses.toggleBtn.html(LOSSES_ON ? 'Losses: ON' : 'Losses: OFF');
}

// ------------------------- Build Diagnostics UI -------------------------
function buildDiagnosticsUI() {
  const pos = lossesUIPosition();
  const dx = 430;
  const x = Math.min(width - 300, pos.x + dx);
  const y = pos.y;

  uiDiag.root = createDiv('').position(x, y).style('padding', '8px')
    .style('border', '1px solid rgba(255,255,255,0.15)')
    .style('border-radius', '8px')
    .style('background', 'rgba(0,0,0,0.25)')
    .style('backdrop-filter', 'blur(6px)')
    .style('color', '#EEE');

  createDiv('Diagnostics').parent(uiDiag.root)
    .style('font-weight','bold').style('margin-bottom','6px');

  uiDiag.text = createDiv('').parent(uiDiag.root)
    .style('font-family','monospace').style('font-size','12px').style('line-height','1.25');
}


function updateDiagnosticsUI(dt_s){
  if (!uiDiag.text) return;

  const M3_PER_GPM = 1 / 15850.323;

  // Prefer values produced by the solvers; fallback to local recompute
  const loss_gpm = (typeof window !== 'undefined' && typeof window.sumLoss_gpm === 'number')
    ? window.sumLoss_gpm
    : (typeof totalLossRate_gpm === 'function' ? (totalLossRate_gpm() || 0) : 0);

  const qCML_gpm  = (typeof effective_Q_CML_gpm === 'function' ? (effective_Q_CML_gpm() || 0) : 0);
  const qComp_gpm = (typeof compressionEquivalentFlow_gpm === 'function'
                      ? (compressionEquivalentFlow_gpm(Math.max(dt_s, 1/120)) || 0)
                      : 0);

  // Surface returns only when riser is "full"
  const topDepth = (typeof annulusTopDepthGlobal === 'function')
    ? annulusTopDepthGlobal()
    : (typeof riserTopDepth === 'function' ? riserTopDepth() : 0);
  const qOutSurf_gpm = (topDepth <= 0.5) ? (FLOW_OUT_gpm || 0) : 0;

  // Include TopFill in the inflow tally (if on)
  const qTopFill_gpm = (TOPFILL_ON ? (Q_TOPFILL || 0) : 0);
  const qIn_gpm = (Q_DS || 0) + (Q_BO || 0) + qTopFill_gpm;

  // Prefer residual published by the level solver; else compute locally
  const resid_gpm = (typeof window !== 'undefined' && typeof window.qResid_gpm === 'number')
    ? window.qResid_gpm
    : (qIn_gpm - (qOutSurf_gpm + qCML_gpm + loss_gpm) - qComp_gpm);

  const fmt = v => (+v).toFixed(1);

  uiDiag.text.html(
    `FO (gpm): ${fmt(FLOW_OUT_gpm)}<br/>` +
    `ΣLoss (gpm): ${fmt(loss_gpm)}<br/>` +
    `Q_CML_eff (gpm): ${fmt(qCML_gpm)}<br/>` +
    `Q_comp (gpm): ${fmt(qComp_gpm)}<br/>` +
    `Riser Top (m): ${fmt(topDepth)}<br/>` +
    `MassBal Resid (gpm): ${fmt(resid_gpm)}`
  );
}



// --------- SIMPLE BADGES / ICONS ---------
function drawBadge(x,y, line1, line2=""){
  push();
  textAlign(CENTER,CENTER); rectMode(CENTER);
  noStroke(); fill(0,0,30,200); rect(x, y, 210, 40, 8);
  fill(0,0,95); textSize(12);
  if (line2){
    text(line1, x, y-8);
    text(line2, x, y+8);
  } else {
    text(line1, x, y);
  }
  pop();
}
function drawStar(x,y){
  push(); noStroke(); fill(50,80,90);
  const r1=6,r2=3,n=5; beginShape();
  for(let i=0;i<2*n;i++){
    const a = i*PI/n;
    const r = (i%2===0)?r1:r2;
    vertex(x + r*Math.cos(a), y + r*Math.sin(a));
  } endShape(CLOSE);
  pop();
}

// --------- GAUGE ---------
function drawGauge(cx, cy, value, vMax, label, units, r, labelSide){
  noFill(); stroke(0,0,95); strokeWeight(2.5); arc(cx,cy,r*2,r*2,PI,TWO_PI);
  strokeWeight(6); stroke(120,60,80); arc(cx,cy,r*2,r*2, PI,PI+0.33*PI);
  stroke(40,70,80); arc(cx,cy,r*2,r*2, PI+0.33*PI,PI+0.66*PI);
  stroke(0,80,80); arc(cx,cy,r*2,r*2, PI+0.66*PI,TWO_PI);
  const norm = clamp(value/Math.max(1e-9,vMax),0,1);
  const ang = PI + norm*PI;
  stroke(0,0,95); strokeWeight(2.5); line(cx,cy,cx+r*cos(ang),cy+r*sin(ang));
  noStroke(); fill(0,0,95); circle(cx,cy,7);
  fill(0,0,95); textSize(Math.max(12,Math.round(r*0.26)));
  const dec=(units==='ppg'?2:0); text(`${nf(value,0,dec)} ${units}`,cx,cy+(r*0.35));
  fill(0,0,80); textSize(Math.max(10,Math.round(r*0.18)));
  textAlign(labelSide==="left"?RIGHT:LEFT,CENTER);
  const lx=labelSide==="left"?(cx-r-14):(cx+r+14);
  text(label,lx,cy);
  textAlign(CENTER,CENTER);
}

// --------- CHART PANELS + PLOTS ---------
function drawChartPanel(x, y, w, h, title){
  noStroke(); fill(0,0,20,200); rect(x-10, y-14, w+20, h+44, 10);
  fill(0,0,0); rect(x, y, w, h, 8);
  fill(0,0,95); noStroke(); textSize(14); textAlign(CENTER, TOP);
  text(title, x + w/2, y + h + 6);
}
function drawChartGrid(x,y,w,h, padL,padR,padT,padB, gridCol){
  const left = x+padL, right=x+w-padR, top=y+padT, bottom=y+h-padB;
  push();
  stroke(gridCol);
  strokeWeight(1);
  // horizontal lines
  for (let i=0; i<=6; i++){
    const yy = top + i*(bottom-top)/6;
    line(left, yy, right, yy);
  }
  // vertical lines
  for (let i=0; i<=4; i++){
    const xx = left + i*(right-left)/4;
    line(xx, top, xx, bottom);
  }
  pop();
}

function drawAxes(x,y,w,h, padL,padR,padT,padB, axisCol){
  const left = x+padL, right=x+w-padR, top=y+padT, bottom=y+h-padB;
  push(); stroke(axisCol); strokeWeight(2); line(left,top,left,bottom); line(left,bottom,right,bottom); pop();
}

function drawDepthTicks(x,y,w,h,padL,padR,padT,padB,col){
  const innerH=h-padT-padB, left=x+padL, top=y+padT;
  fill(col); noStroke(); textSize(11); textAlign(RIGHT, CENTER);
  stroke(col); strokeWeight(1.5);
  
  for (let d=0; d<=MAX_DEPTH; d+=1000){
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true); // 0 at top
    line(left-5, yy, left, yy);
    noStroke(); 
    text(`${d}`, left-8, yy); 
    stroke(col);
  }
}


function drawXTicks(x,y,w,h, padL,padR,padT,padB, axisCol, xmin,xmax, ticks){
  const left = x+padL, bottom=y+h-padB, innerW = w - padL - padR;
  push(); fill(axisCol); noStroke(); textSize(10); textAlign(CENTER,TOP);
  ticks.forEach(v=>{
    const tx = left + remap(v, xmin, xmax, 0, innerW, true);
    text(`${v}`, tx, bottom+6);
  });
  pop();
}
function plotDepthFunction(x,y,w,h, padL,padR,padT,padB, fDepth, xmin, xmax, col){
  const left = x+padL, right=x+w-padR, top=y+padT, bottom=y+h-padB;
  const innerW = right-left, innerH = bottom-top;
  push(); noFill(); stroke(col); strokeWeight(2); beginShape();
  for (let d=0; d<=MAX_DEPTH; d+=25){
    const vx = clamp(fDepth(d), xmin, xmax);
    const xx = left + remap(vx, xmin, xmax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true); // 0 at top, TD at bottom

    vertex(xx, yy);
  }
  endShape(); pop();
}
function plotDepthOverlay(x,y,w,h, padL,padR,padT,padB, arr, xmin,xmax, col){
  const left = x+padL, right=x+w-padR, top=y+padT, bottom=y+h-padB;
  const innerW = right-left, innerH = bottom-top;
  const step = Math.floor(MAX_DEPTH/ (arr.length-1));
  push(); noFill(); stroke(col); strokeWeight(1.5); beginShape();
  for (let i=0;i<arr.length;i++){
    const d = i*step;
    const v = clamp(arr[i], xmin, xmax);
    const xx = left + remap(v, xmin, xmax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true); // 0 at top, TD at bottom

    vertex(xx, yy);
  } endShape(); pop();
}
function plotDepthFunctionMasked(x,y,w,h, padL,padR,padT,padB, fDepth, xmin,xmax, col, maskFn){
  const left = x+padL, right=x+w-padR, top=y+padT, bottom=y+h-padB;
  const innerW = right-left, innerH = bottom-top;
  push(); noFill(); stroke(col); strokeWeight(2); beginShape();
  for (let d=0; d<=MAX_DEPTH; d+=25){
    const v = fDepth(d);
    if (!maskFn(v)) { endShape(); beginShape(); continue; }
    const xx = left + remap(v, xmin, xmax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true); // 0 at top, TD at bottom

    vertex(xx, yy);
  } endShape(); pop();
}
function plotDepthOverlayMasked(x,y,w,h, padL,padR,padT,padB, arr, xmin,xmax, col, maskFn){
  const left = x+padL, right=x+w-padR, top=y+padT, bottom=y+h-padB;
  const innerW = right-left, innerH = bottom-top;
  const step = Math.floor(MAX_DEPTH/ (arr.length-1));
  push(); noFill(); stroke(col); strokeWeight(1.5); beginShape();
  for (let i=0;i<arr.length;i++){
    const d = i*step, v = arr[i];
    if (!maskFn(v)) { endShape(); beginShape(); continue; }
    const xx = left + remap(v, xmin, xmax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true); // 0 at top, TD at bottom

    vertex(xx, yy);
  } endShape(); pop();
}



// ============================== RHEOLOGY UI BUILDER =============================
function buildRheologyUI(x0, y0){
  const label = (txt, x, y) =>
    createDiv(txt).position(x,y).style("color","#E6E6E6").style("font-size","12px");
  const box = (val, x, y, w=80) => {
    const el = createInput(String(val), 'number'); el.position(x,y).size(w); return el;
  };
  const SEP_Y = 50; // vertical spacing
  const COL_W = 100;
  const COL_GAP = 10;
  const xs = i => x0 + i * (COL_W + COL_GAP);
  // --- Model selector (create first, then bind) ---
  label("Rheology Model", x0, y0-30);
  rheoPanel.modelSel = createSelect();
  rheoPanel.modelSel.position(x0, y0-14).size(130, 24);
  ["HB","PowerLaw","Bingham"].forEach(o => rheoPanel.modelSel.option(o));
  rheoPanel.modelSel.selected(ACTIVE_RHEO_MODEL || "HB");
  rheoPanel.modelSel.changed(() => {
    ACTIVE_RHEO_MODEL = rheoPanel.modelSel.value();
    doRheologyFit(); // ensure PV/YP-direct or R-points apply immediately
  });

  // --- Friction Mode selector ---
  label("Friction Mode", x0+150, y0-30);
  rheoPanel.frictionSel = createSelect();
  rheoPanel.frictionSel.position(x0+150, y0-14).size(110, 24);
  ["hydraulics","generic"].forEach(o => rheoPanel.frictionSel.option(o));
  rheoPanel.frictionSel.selected(FRICTION_MODE || "hydraulics");
  rheoPanel.frictionSel.changed(() => {
    FRICTION_MODE = rheoPanel.frictionSel.value();
  });

  // --- Hydraulics Model selector ---
  label("Hydraulics Model", x0+280, y0-30);
  rheoPanel.hydraulicsSel = createSelect();
  rheoPanel.hydraulicsSel.position(x0+280, y0-14).size(110, 24);
  ["Refined","API"].forEach(o => rheoPanel.hydraulicsSel.option(o));
  rheoPanel.hydraulicsSel.selected(HYDRAULICS_MODEL || "Refined");
  rheoPanel.hydraulicsSel.changed(() => {
    HYDRAULICS_MODEL = rheoPanel.hydraulicsSel.value();
  });

  // --- Inputs ---
  let y = y0 + 90;
  label("Funnel (s/qt)", xs(0), y-18); rheoPanel.fv = box(rheoDefaults.fv, xs(0), y);
  label("Temp (°C)", xs(1), y-18); rheoPanel.T = box(rheoDefaults.T, xs(1), y);
  label("R600", xs(2), y-18); rheoPanel.R600 = box(rheoDefaults.R600, xs(2), y);
  label("R300", xs(3), y-18); rheoPanel.R300 = box(rheoDefaults.R300, xs(3), y);
  label("R200", xs(4), y-18); rheoPanel.R200 = box(rheoDefaults.R200, xs(4), y);
  label("R100", xs(5), y-18); rheoPanel.R100 = box(rheoDefaults.R100, xs(5), y);
  y += SEP_Y;
  label("R6", xs(0), y-18); rheoPanel.R6 = box(rheoDefaults.R6, xs(0), y);
  label("R3", xs(1), y-18); rheoPanel.R3 = box(rheoDefaults.R3, xs(1), y);
  label("R1", xs(2), y-18); rheoPanel.R1 = box(rheoDefaults.R1, xs(2), y);
  label("PV (cP)", xs(3), y-18); rheoPanel.PV = box(rheoDefaults.PV, xs(3), y);
  label("YP (lbf/100ft²)",xs(4), y-18);rheoPanel.YP = box(rheoDefaults.YP, xs(4), y, 110);
  // --- Actions & status ---
  y += SEP_Y-10;
  rheoPanel.fitBtn = createButton("Fit curves").position(x0, y).size(110, 26);
  rheoPanel.showFitBtn = createButton("Show fitted params").position(x0+120, y).size(170, 26);
  rheoPanel.fitBtn.mousePressed(() => doRheologyFit());
  rheoPanel.showFitBtn.mousePressed(() => showFittedParams());
  rheoPanel.statusDiv = createDiv("Awaiting fit.");
  rheoPanel.statusDiv.position(x0+300, y+2).style("color","#CCCCCC").style("font-size","12px");
  // Re-fit whenever any rheology input changes (incl. PV/YP)
  [
    rheoPanel.R600, rheoPanel.R300, rheoPanel.R200, rheoPanel.R100,
    rheoPanel.R6, rheoPanel.R3, rheoPanel.R1,
    rheoPanel.PV, rheoPanel.YP
  ].forEach(el => { if (el) el.input(() => doRheologyFit()); });
}

function buildEnhancedHydraulicsUI(x, y){
  const mkToggle = (k, label, row) => {
    const yy = y + row*46;
    const btn = createButton(`${label}: ${EH[k].on ? 'ON' : 'OFF'}`)
      .position(x, yy).size(180, 26);
    btn.mousePressed(()=>{ 
      EH[k].on = !EH[k].on; 
      btn.html(`${label}: ${EH[k].on ? 'ON' : 'OFF'}`); 
    });
    
    mkLabel("Adjustment (-1 to +1)", x+190, yy+4);
    const sld = createSlider(-1, 1, EH[k].s, 0.01)
      .position(x+330, yy).style('width','200px');
    sld.input(()=>{ EH[k].s = sld.value(); });
  };
  
  mkToggle("ECC", "Eccentric Annulus", 0);
  mkToggle("ROUGH", "Roughness Effect", 1);
  mkToggle("KLOSS", "Local K-Losses (SPP)", 2);
  
  // P-only corrections (row 3)
  let row = 3;
  let yy = y + row*46;
  const pbtn = createButton(`P-only Corrections: ${EH.PCOR.on ? 'ON' : 'OFF'}`)
    .position(x, yy).size(180, 26);
  pbtn.mousePressed(()=>{ 
    EH.PCOR.on = !EH.PCOR.on; 
    pbtn.html(`P-only Corrections: ${EH.PCOR.on ? 'ON' : 'OFF'}`); 
  });
  
  mkLabel("Strength (-1 to +1)", x+190, yy+4);
  const psl = createSlider(-1, 1, EH.PCOR.s, 0.01)
    .position(x+330, yy).style('width','200px');
  psl.input(()=>{ EH.PCOR.s = psl.value(); });
  
  mkLabel("Fluid Type", x+550, yy+4);
  const sel = createSelect().position(x+620, yy).size(100, 26);
  ["WBM","OBM","Diesel"].forEach(f=> sel.option(f));
  sel.value(EH.PCOR.fluid);
  sel.changed(()=>{ EH.PCOR.fluid = sel.value(); });
  
  // Gravity swap (row 4)
  row = 4;
  yy = y + row*46;
  
  // ✅ Now just create the button (EH.GRAV already exists globally)
  const gravBtn = createButton(`Gravity Swap: ${EH.GRAV.on ? 'ON' : 'OFF'}`)
    .position(x, yy).size(180, 26)
    .mousePressed(()=>{
      EH.GRAV.on = !EH.GRAV.on;
      gravBtn.html(`Gravity Swap: ${EH.GRAV.on ? 'ON' : 'OFF'}`);
    });
  
  mkLabel('Density-driven settling (slow)', x+190, yy+4);
}


// =========================== STATE SETTERS ============================
function setDSMW(v){
  MW_DS = clamp(Number(v)||0, MW_MIN, MW_MAX);
  dsMWSlider?.value(MW_DS); dsMWInput?.value(nf(MW_DS,1,1));
  // seed the DS grid with the new MW at the inlet
  if (dsGrid && dsGrid.length){ dsGrid[0] = MW_DS; }
}
function setBOMW(v){
  MW_BO = clamp(Number(v)||0, MW_MIN, MW_MAX);
  boMWSlider?.value(MW_BO); boMWInput?.value(nf(MW_BO,1,1));
  if (boosterGrid && boosterGrid.length){ boosterGrid[0] = MW_BO; }
}
function setDSQ(v){
  Q_DS = clamp(Number(v)||0, Q_MIN, Q_MAX);
  dsQSlider?.value(Q_DS); dsQInput?.value(nf(Q_DS,1,0));
}
function setBOQ(v){
  Q_BO = clamp(Number(v)||0, Q_MIN, Q_MAX);
  boQSlider?.value(Q_BO); boQInput?.value(nf(Q_BO,1,0));
}
function setK(v){
  K_FAC = clamp(Number(v)||0, 0.0, 0.0002);
  kSlider?.value(K_FAC); kInput?.value(nf(K_FAC,1,6));
}
function setRPM(v){
  RPM = clamp(Number(v)||0, 0, 220);
  rpmSlider?.value(RPM); rpmInput?.value(String(RPM));
}
function setFrictionMode(mode){
  FRICTION_MODE = (mode==='generic') ? 'generic' : 'hydraulics';
}
window._setFric = setFrictionMode;
window._setRPM  = setRPM;
window._EH      = EH;