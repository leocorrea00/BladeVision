// ========================== CONFIG & CONSTANTS ==========================
const MAX_DEPTH = 5000; // m
const BOP_DEPTH = 2000; // m
const SHOE_DEPTH = 4000; // m
const TD_DEPTH = 5000; // m
const PSI_COEF = 0.1704; // psi per (ppg¬∑m)
const PPG_TO_KGM3 = 119.826427; // kg/m¬≥ per ppg
const LBF100FT2_to_Pa = 0.4788025892; // Pa per (lbf/100ft^2)
// Flow limits for UI
const MW_MIN = 7.0, MW_MAX = 18.0, MW_STEP = 0.1;
const Q_MIN = 0, Q_MAX = 2000, Q_STEP = 10;
// Discretization (for fluid tracking)
const CELL_M = 25;
const CELL_HEIGHT = CELL_M; // convenience alias for legacy code paths
const N_DS = Math.ceil(TD_DEPTH / CELL_M);
const N_ABV = Math.ceil(BOP_DEPTH / CELL_M);
const N_BELOW = Math.ceil((TD_DEPTH - BOP_DEPTH) / CELL_M);
// Advection tuning (simple, frame-based)
const Q_REF = 500;
const BASE_M_PER_FRAME = CELL_M * 0.5;

// === Simulation Time Scaling ===
const REAL_TIME_DT_PER_FRAME = 1 / 30; // seconds of simulated time per rendered frame (~30 FPS)
const TIME_SCALE_PRESETS = {
  FAST:        { label: 'FAST',        factor: 1.0 },
  STANDARD:    { label: 'STANDARD',    factor: 0.35 },
  SLOW:        { label: 'SLOW',        factor: 0.12 },
  SUPER_SLOW:  { label: 'SUPER SLOW',  factor: 0.06 },
  REAL_TIME:   { label: 'REAL TIME',   targetDt: REAL_TIME_DT_PER_FRAME }
};
const TIME_SCALE_ORDER = ['FAST', 'STANDARD', 'SLOW', 'SUPER_SLOW', 'REAL_TIME'];

// === Physics-processing multipliers (extra solver passes before draw) ===
const PROCESSING_PRESETS = {
  SINGLE: { label: 'DRAW (√ó1)', iterations: 1 },
  PASS10: { label: 'STABILIZE √ó10', iterations: 10 },
  PASS30: { label: 'STABILIZE √ó30', iterations: 30 },
  PASS50: { label: 'STABILIZE √ó50', iterations: 50 }
};
const PROCESSING_ORDER = ['SINGLE', 'PASS10', 'PASS30', 'PASS50'];

let activeTimeScaleKey = 'FAST';
let activeProcessingKey = 'SINGLE';
let timeScaleSelect;
let processingSelect;
let simulationPaused = false;
let simElapsedSeconds = 0;
let playButton, pauseButton, resetButton;
let simClockDiv;
let frameDtOverride_s = null;

// Pressure-driven influx balancing (auto SBP target when sealed)
let autoKickBalancePsi = 0;

function currentTimeScaleFactor(baseDt){
  const preset = TIME_SCALE_PRESETS[activeTimeScaleKey];
  if (!preset) return 1.0;
  if (preset.targetDt && typeof baseDt === 'number' && baseDt > 1e-9) {
    return preset.targetDt / baseDt;
  }
  return preset.factor != null ? preset.factor : 1.0;
}

function setTimeScale(key){
  if (!TIME_SCALE_PRESETS[key]) return;
  if (activeTimeScaleKey === key) return;
  activeTimeScaleKey = key;
  syncTimeScaleControl();
}

function syncTimeScaleControl(){
  if (!timeScaleSelect) return;
  if (timeScaleSelect.value() !== activeTimeScaleKey){
    timeScaleSelect.value(activeTimeScaleKey);
  }
  const preset = TIME_SCALE_PRESETS[activeTimeScaleKey];
  if (preset){
    if (preset.targetDt){
      const perFrameMs = preset.targetDt * 1000;
      timeScaleSelect.elt.title = `Simulation speed ‚âà real time (${perFrameMs.toFixed(1)} ms/frame)`;
    } else {
      const factorLabel = (preset.factor != null ? preset.factor : 1).toFixed(2);
      timeScaleSelect.elt.title = `Simulation speed √ó${factorLabel}`;
    }
  }
}

function currentProcessingIterations(){
  const preset = PROCESSING_PRESETS[activeProcessingKey];
  if (!preset) return 1;
  const iters = preset.iterations;
  return (typeof iters === 'number' && isFinite(iters) && iters > 0) ? Math.round(iters) : 1;
}

function setProcessingPreset(key){
  if (!PROCESSING_PRESETS[key]) return;
  if (activeProcessingKey === key) return;
  activeProcessingKey = key;
  syncProcessingControl();
}

function syncProcessingControl(){
  if (processingSelect){
    if (processingSelect.value() !== activeProcessingKey){
      processingSelect.value(activeProcessingKey);
    }
    const preset = PROCESSING_PRESETS[activeProcessingKey];
    if (preset && processingSelect.elt){
      const iters = currentProcessingIterations();
      processingSelect.elt.title = (iters === 1)
        ? 'Single physics pass per rendered frame'
        : `Runs ${iters} physics passes before updating visuals`;
    }
  }
  if (typeof window !== 'undefined'){
    window.processingPreset = activeProcessingKey;
    window.processingIterations = currentProcessingIterations();
  }
}

function syncSimControlButtons(){
  if (playButton){
    const active = !simulationPaused;
    playButton.style('background', active ? '#4ade80' : '#1f2937');
    playButton.style('color', active ? '#0f172a' : '#f8fafc');
  }
  if (pauseButton){
    const active = simulationPaused;
    pauseButton.style('background', active ? '#fbbf24' : '#1f2937');
    pauseButton.style('color', active ? '#0f172a' : '#f8fafc');
  }
  if (resetButton){
    resetButton.style('background', '#1f2937');
    resetButton.style('color', '#f8fafc');
  }
  window.simulationPaused = simulationPaused;
}

function formatSimClock(seconds){
  const totalSeconds = Math.max(0, seconds);
  const wholeSeconds = Math.floor(totalSeconds);
  const days = Math.floor(wholeSeconds / 86400);
  const hours = Math.floor((wholeSeconds % 86400) / 3600);
  const minutes = Math.floor((wholeSeconds % 3600) / 60);
  const secs = wholeSeconds % 60;
  const hh = String(hours).padStart(2, '0');
  const mm = String(minutes).padStart(2, '0');
  const ss = String(secs).padStart(2, '0');
  return `Day ${days} ¬∑ ${hh}:${mm}:${ss}`;
}

function updateSimClockDisplay(){
  if (!simClockDiv) return;
  const label = formatSimClock(simElapsedSeconds);
  const suffix = simulationPaused ? ' (paused)' : '';
  simClockDiv.html(label + suffix);
}

function resumeSimulation(){
  simulationPaused = false;
  syncSimControlButtons();
  updateSimClockDisplay();
}

function pauseSimulation(){
  simulationPaused = true;
  syncSimControlButtons();
  updateSimClockDisplay();
}

function resetSimulation(){
  simElapsedSeconds = 0;
  simulationPaused = false;
  syncSimControlButtons();
  updateSimClockDisplay();
  if (typeof window !== 'undefined' && window.location && typeof window.location.reload === 'function'){
    window.location.reload();
  }
}
// --- Rotation coupling tunables ---
const ROT_COUPLE = 3.0; // scales how strongly rotation adds to effective shear
const TAYLOR_BOOST = { Ta_c: 1200, C0: 0.18, Cn: 0.6 }; // stronger Taylor boost
// === Flow unit conversions (m¬≥/s ‚Üî gpm) ===
const GPM_PER_M3S = 15850.323;   // 1 m¬≥/s = 15850.323 gpm
const M3_PER_GPM  = 1 / GPM_PER_M3S;  // 1 gpm = 6.309e-5 m¬≥/s


// ===== Auto-CML (anchored on ECD/pressure) tunables =====
const CML_DB_PSI = 20;            // pressure deadband around setpoint (psi)
const CML_PSI_SOFT = 50;         // psi range where gains taper toward zero
const CML_KP_GPM_PER_PSI = 1;   // proportional gain (gpm per psi)  <-- start conservative
const CML_KI_GPM_PER_PSI_S = 3;// integral gain (gpm per psi per s)
const CML_SLEW_GPM_PER_S = 80;   // max |ŒîQ_CML| per second (slew limiter)
const CML_LPF_TAU_S = 60.0;        // low-pass filter on measured pressure (s)
// --- units: must be defined once, before any friction/pressure code ---
const PSI_PER_PASCAL = 1 / 6894.757;      // psi per Pa


// ============================================================================
// STABILIZATION PATCH - Add near top of file with other constants
// ============================================================================

// === Loss Zone Stabilization Constants ===
// ‚úÖ IMPROVED: More conservative tuning to prevent oscillations
const LOSS_ACTIVATION_HYST_PSI = 25;    // Pressure must exceed Pfrac by this to START
const LOSS_DEACTIVATION_HYST_PSI = 15;  // Pressure must fall below Pfrac by this to STOP
const LOSS_MAX_ACCEL_GPM_S2 = 100;      // Max acceleration (gpm/s¬≤) - REDUCED to prevent spikes
const LOSS_GLOBAL_RATE_LIMIT = 200;     // Max TOTAL loss change (gpm/s) - REDUCED for stability
const LOSS_CMD_LPF_TAU_S = 0.9;         // Low-pass smoothing time for zone commands
const LOSS_CMD_SLEW_GPM_PER_S = 450;    // Slew limit applied to smoothed commands

// === Level Change Rate Limits ===
const LEVEL_MAX_RISE_RATE_M_S = 5.0;    // Max level rise (m/s)
const LEVEL_MAX_DROP_RATE_M_S = 8.0;    // Max level drop (m/s)
const LINE_LEVEL_EQ_TAU_S = 0.6;        // Time constant for U-tube line level equalization

// === Flow Out Stabilization ===
// ‚úÖ IMPROVED: More filtering to prevent oscillations from loss zones
const FLOWOUT_DEADBAND_GPM = 15;        // Ignore tiny changes - INCREASED
const FLOWOUT_LPF_TAU = 2.5;            // Smooth over 2.5 seconds - INCREASED for more damping
const FLOWOUT_MAX_ACCEL = 200;          // Max dQ/dt change (gpm/s¬≤) - REDUCED

// Add these state variables near other globals:
let FLOWOUT_VELOCITY_gpm_s = 0;  // dFO/dt
let cmlCtrl = { I_gpm: 0, P_lpf_psi: 0 };

// ========================================================================
// DIAGNOSTIC LOGGING SYSTEM
// ========================================================================
let diagnosticLog = {
  recording: false,
  data: [],
  startTime: 0,
  lastLogFrame: 0,
  LOG_INTERVAL: 30  // Log every 30 frames (1 second at 30fps, 0.5s at 60fps)
};
let logStartBtn, logStopBtn, logDownloadBtn;

// --- Safe, non-p5 helpers (no name collisions) ---
function clamp(val, min, max){ return Math.max(min, Math.min(max, val)); }
function remap(x, inMin, inMax, outMin, outMax, withinBounds=false){ if (inMax === inMin) return outMin; // avoid /0
  const t = (x - inMin) / (inMax - inMin);
  let y = outMin + t * (outMax - outMin);
  if (withinBounds){ const lo = Math.min(outMin, outMax); const hi = Math.max(outMin, outMax); y = Math.max(lo, Math.min(hi, y)); }
  return y;
}
// Graphics (some defaults; refined in setup)
let W = 2100, H = 980;
let well = { x: 140, y: 130, w: 160, h: 420 };
let dp = { w: 60 };
const GAUGE_SCALE = 0.70, R_BASE = 65;
const R = Math.round(R_BASE * GAUGE_SCALE);
// Reference marks to annotate
const MARKS = [ { d: BOP_DEPTH, name: "BOP" }, { d: SHOE_DEPTH, name: "Casing Shoe" }, { d: TD_DEPTH, name: "TD" } ];

// ========================================================================
// FORMATION FLUIDS (KICKS)
// ========================================================================
const FORMATION_FLUID_TYPES = {
  WATER: { name: 'Water', density_ppg: 8.33, density_kgm3: 997, viscosity_cp: 1.0, color: [200, 80, 60] },
  OIL: { name: 'Oil', density_ppg: 7.0, density_kgm3: 838, viscosity_cp: 5.0, color: [30, 70, 40] },
  GAS: { name: 'Gas', density_ppg: 0.7, density_kgm3: 84, viscosity_cp: 0.02, color: [0, 80, 90] },
  BLACKOIL: { name: 'Black Oil', density_ppg: 7.5, density_kgm3: 898, viscosity_cp: 10.0, bubblePoint_psi: 2000, color: [270, 60, 30] }
};

let formationFluidEnabled = false;
let formationFluidType = 'WATER';
let formationFluidDepth_m = 4500; // Depth where kick enters
let formationFluidRate_gpm = 0; // Influx rate (manual mode)
let formationFluidVolume_bbl = 0; // Total volume entered
let formationFluidFront_m = TD_DEPTH; // Current front position
let formationFluidMigrationModel = 'SHUTIN'; // 'SHUTIN', 'HARMATHY', 'MODIFIED_HARMATHY'
let formationFluidOverflow_m3 = 0; // Volume that could not be accommodated this frame
let kickMode = 'MANUAL'; // 'MANUAL' or 'PRESSURE_DRIVEN'
let porePressure_psi = 7000; // Formation pore pressure
let permeability_mD = 100; // Formation permeability (millidarcys)
let productivityIndex_gpm_psi = 0.5; // Productivity index (gpm/psi)

// Track formation fluid in cells (parallel to annulus grids)
let formationFluidCells_below = []; // Formation fluid fraction in each cell below BOP
let formationFluidCells_above = []; // Formation fluid fraction in each cell above BOP
let gasPhaseFrom_below = []; // For black oil dissociation tracking
let gasPhaseFrom_above = [];
let oilPhaseFrom_below = []; // Oil phase tracking
let oilPhaseFrom_above = [];
let waterPhaseFrom_below = []; // Water phase tracking
let waterPhaseFrom_above = [];

// Track current influx rate for flow routing
let current_influx_m3s = 0; // Current influx rate in m¬≥/s (updated each frame)

// Gas Expansion Model (for when formationFluidType === 'GAS')
let GAS_EXPANSION_MODE = 'IDEAL'; // 'IDEAL' or 'REAL'
let GAS_ENABLED = false; // Enable gas expansion calculations

// Gas properties (for Methane CH4 as default)
let GAS_Pc_psi = 667.8; // Critical pressure (psia) - Methane
let GAS_Tc_R = 343.9; // Critical temperature (Rankine) - Methane
let GAS_SPECIFIC_GRAVITY = 0.554; // Relative to air (Methane ‚âà 0.554)

// Reference conditions for gas (at entry point)
let GAS_REFERENCE_P_psi = 7000; // Reference pressure (typically = pore pressure)
let GAS_REFERENCE_T_R = 600; // Reference temperature (Rankine) at depth

// Temperature profile (simplified - could be gradient later)
let SURFACE_TEMP_R = 530; // 70¬∞F in Rankine
let BOTTOM_TEMP_R = 600; // Temperature at TD

// ============================ GLOBAL STATE =============================
let HYDRAULICS_MODEL = "Refined"; // "API" | "Refined"
let FRICTION_MODE = "hydraulics"; // keep hydraulics by default
let ACTIVE_RHEO_MODEL = "HB"; // "HB" | "PowerLaw" | "Bingham"
let fitParams = { mu_p_Pa_s: null, tau_y_Pa: null, K_PL_Pa_s_n: null, n_PL: null, K_HB_Pa_s_n: null, n_HB: null, tau_y_HB_Pa: null };

// ============================ BOP & WELL CONTROL =============================
let BOP_CLOSED = false; // BOP state (open/closed)
let closedWellPressureBoost_psi = 0; // Pressure increase from pumping to closed well
let trappedAnnulusBasePressure_psi = null; // Remembers BOP pressure at moment of isolation
let lastOpenAnnulusPressure_psi = 14.7;    // Latest open-well annulus pressure at BOP
const CLOSED_WELL_WARNING_PSI = 12000;
const CLOSED_WELL_MAX_PSI = 15000;
const CLOSED_WELL_PSI_PER_BBL = 15; // Approximate psi gain per trapped barrel

let RCD_CLOSED = false;
let MPD_CHOKE_LOCKED_CLOSED = false;
let mpdChokeBtn, rcdBtn;

// Choke Line (runs from BOP to surface, parallel to riser)
let CHOKE_LINE_ID_in = 3.0; // Inner diameter (inches)
let CHOKE_LINE_ID_m = 0; // Converted to meters in setup
let Q_CHOKE = 0; // gpm
let CHOKE_DIRECTION = "UP"; // "UP" or "DOWN"
let CHOKE_PRESSURE_psi = 0; // Actual pressure applied at choke line surface
let CHOKE_PRESSURE_TARGET_psi = CHOKE_PRESSURE_psi; // User-set target stored when control transferred
let MW_CHOKE = 9.5; // ppg, choke line fluid (starts with same as DS)
let CHOKE_LINE_OPEN = false; // Open/Closed state - must be OPEN to flow
let chokeGrid = []; // Fluid tracking grid (BOP to surface)
let accChoke = 0; // Advection accumulator
let levelDeficit_choke_m = 0; // Level deficit in choke line

// Kill Line (runs from BOP to surface, parallel to riser)
let KILL_LINE_ID_in = 3.0; // Inner diameter (inches)
let KILL_LINE_ID_m = 0; // Converted to meters in setup
let Q_KILL = 0; // gpm
let KILL_DIRECTION = "UP"; // "UP" or "DOWN"
let KILL_PRESSURE_psi = 0; // Actual pressure applied at kill line surface
let KILL_PRESSURE_TARGET_psi = KILL_PRESSURE_psi;
let MW_KILL = 9.5; // ppg, kill line fluid (starts with same as DS)
let KILL_LINE_OPEN = false; // Open/Closed state - must be OPEN to flow
let killGrid = []; // Fluid tracking grid (BOP to surface)
let accKill = 0; // Advection accumulator
let levelDeficit_kill_m = 0; // Level deficit in kill line
let chokeSurfacePressure_calc_psi = null;
let killSurfacePressure_calc_psi = null;
let bopPressureMaster = null; // 'choke' | 'kill' | null
let chokeUpWasActive = false;
let killUpWasActive = false;
let chokeUpActivationSeq = 0;
let killUpActivationSeq = 0;
let bopPressureActivationCounter = 0;

// Fluids / flows
let MW_DS = 9.5; // ppg, drillstring
let MW_BO = 9.5; // ppg, booster line (starts with same as DS)
let Q_DS = 500; // gpm
let Q_BO = 100; // gpm
// Rotational speed (affects shear)
let RPM = 80;
// Generic friction fallback (when FRICTION_MODE === "generic")
let K_FAC = 0.00005;
// Level deficits (U-tube), meters from surface
let levelDeficit_m = 0; // DS
let levelDeficit_bo_m = 0; // Booster
// Rheology / gel
let gel_Pa = 5.0;
let use_gel = true;
// Geometry (inches ‚Üí meters in setup)
let riser_ID_in = 21.0;
let casing_ID_in = 9.625;
let openhole_OD_in = 8.5;
let ds_OD_in = 5.0;
let ds_ID_in = 3.75;
let booster_ID_in = 4.5;
let riser_ID_m = 0, casing_ID_m = 0, openhole_ODm = 0, ds_OD_m = 0, ds_ID_m = 0, booster_ID_m = 0;
// Segmented tracking grids
let dsGrid = new Array(N_DS).fill(MW_DS); // downwards
let annBelowGrid = new Array(N_BELOW).fill(MW_DS); // upwards (BOP‚ÜíTD)
let annAboveGrid = new Array(N_ABV).fill(MW_DS); // upwards (Surf‚ÜíBOP)
let boosterGrid = new Array(N_ABV).fill(MW_BO); // downwards (Surf‚ÜíBOP)
// fractional advection accumulators
let accDS = 0, accBelow = 0, accAbove = 0, accBo = 0;
// MPD / SBP
let MPD_ON = false;
let SBP_MODE = "manual"; // "manual" | "anchor"
let SBP_MANUAL = 0;
let CURRENT_SBP = 0;
const SBP_LEVEL_ENABLE_DEPTH_M = 0.25;
const SBP_LEVEL_DISABLE_DEPTH_M = 1.0;
const SBP_LEVEL_RISE_EPS_M = 0.05;
const LINE_PRESSURE_ENABLE_DEFICIT_M = 0.25;
const LINE_PRESSURE_DISABLE_DEFICIT_M = 1.0;
const LINE_PRESSURE_RISE_EPS_M = 0.05;
let sbpLevelArmed = false;
let lastAnnulusTopDepth_m = 0;
const linePressureAnchors = {
  choke: { armed: false, lastDeficit: 0 },
  kill:  { armed: false, lastDeficit: 0 }
};

function riserFullEnoughForSBP(){
  const topDepth = (typeof surfaceColumnTopDepth === 'function')
    ? surfaceColumnTopDepth()
    : 0;
  if (!Number.isFinite(topDepth)) return false;

  const rising = (typeof lastAnnulusTopDepth_m === 'number')
    ? (topDepth < lastAnnulusTopDepth_m - SBP_LEVEL_RISE_EPS_M)
    : false;

  if (rising) {
    sbpLevelArmed = false;
  } else if (topDepth <= SBP_LEVEL_ENABLE_DEPTH_M) {
    sbpLevelArmed = true;
  } else if (topDepth >= SBP_LEVEL_DISABLE_DEPTH_M) {
    sbpLevelArmed = false;
  }

  lastAnnulusTopDepth_m = topDepth;
  return sbpLevelArmed;
}

function sbpCanPressurizeAnnulus(){
  if (!MPD_ON) return false;
  if (BOP_CLOSED) return true;
  if (!RCD_CLOSED) return false;
  return riserFullEnoughForSBP();
}

function updateLinePressureAnchors(){
  updateSingleLinePressureAnchor('choke', levelDeficit_choke_m || 0);
  updateSingleLinePressureAnchor('kill', levelDeficit_kill_m || 0);
}

function updateSingleLinePressureAnchor(which, rawDeficit){
  const anchor = linePressureAnchors[which];
  if (!anchor) return;
  const capped = clamp(rawDeficit || 0, 0, BOP_DEPTH);
  const refilling = capped < anchor.lastDeficit - LINE_PRESSURE_RISE_EPS_M;
  if (refilling) {
    anchor.armed = false;
  } else if (capped <= LINE_PRESSURE_ENABLE_DEFICIT_M) {
    anchor.armed = true;
  } else if (capped >= LINE_PRESSURE_DISABLE_DEFICIT_M) {
    anchor.armed = false;
  }
  anchor.lastDeficit = capped;
}

function linePressureAnchorArmed(which){
  const anchor = linePressureAnchors[which];
  return !!(anchor && anchor.armed);
}

function effectiveLineDryLength(which){
  const raw = clamp(
    which === 'choke' ? (levelDeficit_choke_m || 0) : (levelDeficit_kill_m || 0),
    0,
    BOP_DEPTH
  );
  return linePressureAnchorArmed(which) ? 0 : raw;
}

function effectiveSurfaceSealActive(){
  if (isWellShutInByValves()) return true;
  if (mpdSealActive()) return true;

  // If the riser is vented to atmosphere (BOP open and RCD open), treat the
  // system as unsealed even if FlowOut is low because there is still a free
  // path to surface. This avoids mistakenly applying auto surface pressure
  // during loss-driven low-flow conditions.
  const riserVented = (!BOP_CLOSED) && !RCD_CLOSED;
  if (riserVented) return false;

  // If the stack is closed and an up-line is selected but surface flow is
  // effectively zero, treat it as a trapped column so pressure can build.
  if (BOP_CLOSED){
    const chokeUp = CHOKE_LINE_OPEN && CHOKE_DIRECTION === 'UP';
    const killUp  = KILL_LINE_OPEN && KILL_DIRECTION === 'UP';
    const fo = (typeof FLOW_OUT_gpm === 'number') ? FLOW_OUT_gpm : 0;
    if ((chokeUp || killUp) && fo < 0.5) return true;
  }

  // If the BOP is open but an up-line (choke or kill) is closed at surface
  // such that there is essentially no return flow, the riser/line system is
  // still sealed and trapped pressure can build. Treat very low surface flow
  // as a seal so pressure-driven influx can hand off to surface pressure
  // rather than continuing to admit new kick volume.
  const chokeUpOpen = CHOKE_LINE_OPEN && CHOKE_DIRECTION === 'UP';
  const killUpOpen  = KILL_LINE_OPEN && KILL_DIRECTION === 'UP';
  const flowOut = (typeof FLOW_OUT_gpm === 'number') ? FLOW_OUT_gpm : 0;
  if (!BOP_CLOSED && flowOut < 0.5 && (chokeUpOpen || killUpOpen)) {
    return true;
  }
  return false;
}

function sbpAppliedPsi(){
  const baseEnabled = sbpCanPressurizeAnnulus();
  const base = baseEnabled ? Math.max(0, CURRENT_SBP || 0) : 0;
  const extraFromCompression = (!BOP_CLOSED && mpdSealActive())
    ? Math.max(0, closedWellPressureBoost_psi || 0)
    : 0;
  const allowAutoKick = effectiveSurfaceSealActive();
  const autoKick = (kickMode === 'PRESSURE_DRIVEN' && allowAutoKick && autoKickBalancePsi > 0)
    ? autoKickBalancePsi
    : 0;
  return base + extraFromCompression + autoKick;
}
let ANCHOR_DEPTH = 0;
let ANCHOR_ECD = 0;
// Time series
const TS_MAX = 600, TS_STRIDE = 5;

let GRAVITY_SWAP_ON = false;
const GRAVITY_SWAP_RATE = 0.02; // Cells per second (slow settling)
// UI refs (created in setup)
let apDepthInput, apEcdInput;
let cmlApDepthInput, cmlApEcdInput; // Separate CML anchor inputs
let dsMWSlider, dsMWInput, dsQSlider, dsQInput;
let boMWSlider, boMWInput, boQSlider, boQInput;
let kSlider, kInput;
let rpmSlider, rpmInput;
let sbpSlider, sbpInput;
let mpdBtn, sbpModeBtn, captureBtn, displayBtn, fricBtn, hydBtn;
let rheoPanel = {};
let frameWidth;
// Captured overlays
let capturedP = null;
let capturedECD = null;
let showCaptured = false;
// Advection coupling FIFOs (ensure arrival order)
let bitOutQ = []; // DS ‚Üí TD (bit exit) ‚Üí feeds annBelow bottom
let belowOutQ = []; // annBelow top ‚Üí BOP ‚Üí feeds annAbove
let boosterOutQ = []; // Booster bottom ‚Üí BOP ‚Üí feeds annAbove
// --- bottom frames (for Rheology/Gels/Geometry) ---
let frameY, frameHeight, frameY2;
let bottomPanelW, bopPanelW, bottomPanelPadding, bottomPanelSpacing, bottomPanelRowSpacing;
let rheoFrameX, rheoFrameW, gelFrameX, gelFrameW, configFrameX, configFrameW;
let enhFrameX, enhFrameW, lossFrameX, lossFrameW, kickFrameX, kickFrameW;
let bopFrameX, bopFrameW, diagFrameX, diagFrameW;
let cmlQSlider, cmlQInput, cmlDepthInput, cmlBtn, cmlAutoBtn;
let tsFrame = 0;
// Booster SPP smoothing (top-level)
let BoosterSPP_smooth = 0;
function updateBoosterSPP(target){
  BoosterSPP_smooth = BoosterSPP_smooth + SPP_ALPHA * (target - BoosterSPP_smooth);
  return BoosterSPP_smooth;
}

// Choke/Kill Line SPP smoothing (when flowing DOWN)
let ChokeSPP_smooth = 0;
function updateChokeSPP(target){
  ChokeSPP_smooth = ChokeSPP_smooth + SPP_ALPHA * (target - ChokeSPP_smooth);
  return ChokeSPP_smooth;
}

let KillSPP_smooth = 0;
function updateKillSPP(target){
  KillSPP_smooth = KillSPP_smooth + SPP_ALPHA * (target - KillSPP_smooth);
  return KillSPP_smooth;
}
// Add this with your other global variable declarations
let tsData = {
  totalFlowIn: [],
  dsFlow: [],
  cmlFlow: [],
  spp: [],
  sbpSetpoint: [],
  sbpApplied: [],
  cmlAnchorSet: [],
  cmlAnchorActual: [],
  sbpAPSet: [],
  sbpAPActual: []
};
//let capturedP = null;
///let capturedECD = null;
//let showCaptured = false;
// Add near other globals (around line 50):
let TOPFILL_ON = false;
let Q_TOPFILL = 0; // gpm
let MW_TOPFILL = 9.5; // ppg


// === Time series for Flow Out & Choke Position ===
let tsFlowOut_gpm = [];      // newest at index 0
let tsChoke_pct   = [];      // newest at index 0


//let bitOutQ = [];
//let belowOutQ = [];
// Defaults for rheology inputs
let rheoDefaults = { fv: 72, T: 49, R600: 69.4, R300: 46.3, R200: 36.3, R100: 27.6, R6: 12.0, R3: 11.9, R1: 9.5, PV: 40, YP: 22, G10s: 18.5, G10m: 26.9, G30m: 27.2 };
// SPP smoothing
const SPP_ALPHA = 0.15; // 0‚Äì1 (higher = faster response)
let SPP_smooth = 0;
function updateSPP(targetSPP){
  SPP_smooth = SPP_smooth + SPP_ALPHA*(targetSPP - SPP_smooth);
  return SPP_smooth;
}

// --- Friction smoothing helpers (prevents laminar‚Üîturbulent ping-pong) ---
const FRICTION_SMOOTH_ALPHA = 0.35;
const frictionSmoothState = {};
function smoothFrictionPsi(key, targetPsi){
  if (!isFinite(targetPsi)) return 0;
  const prev = (key in frictionSmoothState) ? frictionSmoothState[key] : targetPsi;
  const next = prev + FRICTION_SMOOTH_ALPHA * (targetPsi - prev);
  frictionSmoothState[key] = next;
  return next;
}

// Prevent friction from decreasing while the corresponding flow is rising
const monotonicFrictionState = {};
function enforceMonotonicFriction(key, flow_m3s, rawPsi){
  if (!isFinite(rawPsi)) return 0;
  const flow = Math.max(0, flow_m3s || 0);
  const prev = monotonicFrictionState[key];
  if (!prev || flow < 1e-6) {
    monotonicFrictionState[key] = { flow, psi: rawPsi };
    return rawPsi;
  }

  let psi = rawPsi;
  if (flow >= prev.flow && rawPsi < prev.psi) {
    psi = prev.psi;
  }

  monotonicFrictionState[key] = { flow, psi };
  return psi;
}

// Add near top with other globals (around line 50):
let frictionCache = {};
let frictionCacheFrame = -1;

// Replace frictionPsi_withCML_rheo with cached version:
// NOTE: frictionPsi_withCML_rheo() is defined later at line ~1477
// (removed duplicate definition here)

// --- Auto-CML control tunables (smooth tracking of inflow) ---
//const CML_LPF_TAU_S = 5.0;          // low-pass time constant on inflow (s)
//const CML_SLEW_GPM_PER_S = 150;     // max change rate for Q_CML (gpm/s)
const CML_TRIM_KI = 0.02;           // small I trim (gpm per (gpm¬∑s))
//let cmlCtrl = { qInLP_m3s: 0, trim_gpm: 0 };

// -------- Enhanced Hydraulics (flags + sliders) --------
// in your lossZones init, add:
PI_gpm_per_psiN: 0  // optional direct PI (gpm / psi^n)

let EH_ON = true; // master section is visible
// Each feature has: ON/OFF + slider in [-1, +1] where 0 = nominal
let EH = {
  ECC: { on: false, s: 0.0 }, // Eccentric annulus effect
  ROUGH: { on: false, s: 0.0 }, // Roughness effect (turbulent primarily)
  KLOSS: { on: false, s: 0.0 }, // Local K-losses (bit, tools) into SPP/Booster SPP
  PCOR: { on: false, s: 1.0, fluid: "WBM" }, // P-only corrections (œÅ & Œº) with strength scalar
  GRAV:  { on: false } 
};
// --- Imbalance globals (small & smoothed) ---
let QIMB_DS2ANN_m3s = 0;   // DS ‚Üí Annulus (m¬≥/s)
let QIMB_BO2RIS_m3s = 0;   // Booster ‚Üí Riser (m¬≥/s)
const IMB_ALPHA = 0.25;    // smoothing 0..1
const IMB_DEADBAND_PSI = 0.5; // minimum ŒîP to move

// UI refs
let ehPanel = {};
// Optional baselines you can tune
const EH_TUNE = {
  ecc_max_gain: 0.40, // up to ¬±40% dp change in tight annuli due to eccentricity
  rough_max_gain: 0.60, // up to ¬±60% on turbulent f (stronger at high Re)
  kloss_spp_base: 250, // psi baseline extra when s=+1 (and -250 psi at s=-1)
};
// --- P-only correction knobs ---
const PSI_TO_PA = 6894.757;
// Compressibility Œ≤ (1/Pa) at surface pressure (simplified constant value)
function betaCompressibility(fluid) {
  if (fluid === "WBM") return 4.5e-10; // Water-based mud
  if (fluid === "OBM") return 1.0e-9; // Oil-based mud
  if (fluid === "Diesel") return 1.4e-9; // Diesel
  return 8e-10; // Default
}
// Pressure-viscosity coefficient Œ± (1/Pa) (simplified constant)
function alphaPV(fluid) {
  if (fluid === "WBM") return 2e-10; // Negligible for WBM
  if (fluid === "OBM") return 1.0e-8; // Moderate for OBM
  if (fluid === "Diesel") return 1.4e-8; // Higher for Diesel
  return 1e-9; // Default
}
// Hydrostatic + SBP only (NO friction) ‚Üí safe for P-only rheology scaling
function pressureForPCOR(d){
  const depth = Math.max(0, d);
  const ecd = ecdAtDepth(depth); // uses only the grids, no hydraulics
  const P_hyd = PSI_COEF * ecd * depth; // psi
  const P_sbp = sbpAppliedPsi(); // psi
  return P_hyd + P_sbp; // psi
}
// Apply pressure-only correction at a representative depth
function applyPressureOnly(d, rho0, K0, n0, tauY0) {
  if (!EH.PCOR.on) return { rho: rho0, K: K0, n: n0, tauY: tauY0 };
  // IMPORTANT: use friction-free pressure to avoid recursion
  const P_pa = Math.max(pressureForPCOR(d), 0) * PSI_TO_PA;
  const beta = betaCompressibility(EH.PCOR.fluid) * EH.PCOR.s; // density vs P
  const alpha = alphaPV(EH.PCOR.fluid) * EH.PCOR.s; // viscosity vs P
  const deltaP = P_pa - 101325; // vs surface (Pa)
  const rhoP = rho0 * Math.exp(beta * deltaP); // corrected density
  const KP = Math.max(K0,1e-9) * Math.exp(alpha * deltaP); // corrected K
  return { rho: rhoP, K: KP, n: n0, tauY: tauY0 };
}
// ======== CML (Controlled Mud Level) ========
let CML_ON = false; // master toggle
let CML_DEPTH = 0; // m (0..BOP_DEPTH)
let Q_CML = 0; // gpm (manual command)
let AUTO_CML_ON = false; // anchor controller
let CML_AP_DEPTH = 0; // m (anchor depth for AUTO-CML)
let CML_AP_ECD = 0; // ppg (anchor ECD for AUTO-CML)
let CML_Q_MAX = 0; // dynamic: max allowed (DS+Booster)
// riser top exposed to atmosphere due to CML pump (depth from surface)
let CML_TOP_DEPTH = 0; // m (0 = riser full)
// CML pipe (visual-only) fluid tracking (upwards to surface)
let cmlPipeGrid = new Array(N_ABV).fill(MW_DS);
let accCML = 0; // advection accumulator for CML pipe
// ============================== UTILITIES ==============================

// ===== Loss-driven free surface (independent of CML) =====
let LOSS_TOP_DEPTH_m = 0;

// ===== Section tops =====
let levelRiserTop_m   = 0;
let levelBoosterTop_m = 0;
let levelDSTop_m      = 0;
let levelCMLTop_m     = 0;

// ===== Flow-Out (surface returns) =====
let FLOW_OUT_gpm = 0;
let FLOW_OUT_smooth = 0;
const FLOW_OUT_ALPHA = 0.20;

function mpdChokeIsFullyClosed(){
  if (!MPD_ON) return false;
  if (MPD_CHOKE_LOCKED_CLOSED) return true;
  const chokeNearlyShut = (typeof CHOKE_POS_pct === 'number') ? (CHOKE_POS_pct <= 0.1) : true;
  const flowVal = (typeof FLOW_OUT_gpm === 'number') ? FLOW_OUT_gpm : 0;
  return chokeNearlyShut && flowVal < 0.5;
}

function mpdSealActive(){
  return MPD_ON && RCD_CLOSED && mpdChokeIsFullyClosed();
}

function chokeLineProvidesSurfaceVent(){
  if (typeof chokeLineIsFlowingUp === 'function') {
    return chokeLineIsFlowingUp();
  }
  return CHOKE_LINE_OPEN && CHOKE_DIRECTION === 'UP';
}

function killLineProvidesSurfaceVent(){
  if (typeof killLineIsFlowingUp === 'function') {
    return killLineIsFlowingUp();
  }
  return KILL_LINE_OPEN && KILL_DIRECTION === 'UP';
}

function closedWellCompressionActive(){
  const mpdSealed = (typeof mpdSealActive === 'function') ? mpdSealActive() : false;
  if (mpdSealed) return true;
  if (!BOP_CLOSED) return false;
  const chokeVent = chokeLineProvidesSurfaceVent();
  const killVent  = killLineProvidesSurfaceVent();
  return !(chokeVent || killVent);
}

function isWellShutInByValves(){
  const bopSealedByValves = BOP_CLOSED && !CHOKE_LINE_OPEN && !KILL_LINE_OPEN;
  const mpdSurfaceSeal = (!BOP_CLOSED) && mpdSealActive();
  return bopSealedByValves || mpdSurfaceSeal;
}

// ===== Loss zones (up to 3) =====
let LOSSES_ON = false;
const MAX_LOSS_ZONES = 3;
let lossZones = Array.from({length: MAX_LOSS_ZONES}, () => ({
  enabled: false,
  depth_m: 0,
  fracPressure_psi: 0,
  Qref_gpm: 0,
  DPref_psi: 0,
  n: 1.0,
  CL: 0,
  Qloss_gpm: 0,
  section: '',
  cellIdx: -1
}));

// ===== Choke (equal-percentage Cv) =====
let CHOKE_POS_pct = 0;
let CHOKE_CV_MAX = 50;
let CHOKE_K = 4.0;

// ===== Compressibility (distributed) =====
let prevPavg_psi = 0;

// ===================== LOSSES UI + DIAGNOSTICS (UI refs) =====================
let uiLosses = {
  root: null, title: null, toggleBtn: null,
  rows: [
    { depth:null, fracP:null, qref:null, dpref:null, n:null },
    { depth:null, fracP:null, qref:null, dpref:null, n:null },
    { depth:null, fracP:null, qref:null, dpref:null, n:null },
  ],
  help: null
};
let uiDiag = { root:null, text:null };
let uiKicks = {
  root: null, title: null, toggleBtn: null, modeBtn: null,
  fluidTypeSelect: null, migrationModelSelect: null,
  manualRateInput: null, manualRateSlider: null, depthInput: null,
  porePressureInput: null, permeabilityInput: null, piInput: null
};



// ---- Global free-surface for the WHOLE annulus (can sink below BOP) ----
// 0 = full to surface; up to TD_DEPTH when totally drained.
let ANN_TOP_DEPTH_m = 0; // master top of wet annulus (riser + below BOP)

// Clamp + expose a single function to get it
function annulusTopDepthGlobal(){
  return Math.max(0, Math.min(ANN_TOP_DEPTH_m, TD_DEPTH));
}

// Surface-connected column top (riser when open, active choke/kill leg when shut in)
function surfaceColumnTopDepth(){
  if (!BOP_CLOSED) {
    return annulusTopDepthGlobal();
  }

  const seg = (typeof dominantBopLineSegment === 'function')
    ? dominantBopLineSegment()
    : null;
  if (seg && seg.wetLen > 1e-3) {
    return Math.max(0, BOP_DEPTH - seg.wetLen);
  }

  const hasLossTop = LOSSES_ON && typeof LOSS_TOP_DEPTH_m === 'number';
  const fallback = hasLossTop
    ? Math.min(Math.max(LOSS_TOP_DEPTH_m, 0), BOP_DEPTH)
    : BOP_DEPTH;
  return fallback;
}

// Section area at a given depth (annulus)
function annulusAreaAtDepth(d){
  if (d < BOP_DEPTH) return area_annulus(riser_ID_m,  ds_OD_m);          // riser annulus
  if (d < SHOE_DEPTH) return area_annulus(casing_ID_m, ds_OD_m);         // casing annulus
  return area_annulus(openhole_ODm, ds_OD_m);                             // open hole annulus
}



// Helper to place Losses UI under Rheology pane (fallback to bottom-left)
function lossesUIPosition() {
  const x = (typeof lossFrameX === 'number') ? lossFrameX + 18 : 40;
  const yBase = (typeof frameY2 === 'number') ? frameY2 + 40 : (height - 200);
  const y = Math.min(height - 200, Math.max(20, yBase));
  return { x, y };
}

// Helper to place Kicks UI inside the kick frame
function kicksUIPosition() {
  const x = (typeof kickFrameX === 'number') ? kickFrameX + 18 : 460;
  const yBase = (typeof frameY2 === 'number') ? frameY2 + 40 : (height - 200);
  const y = Math.min(height - 200, Math.max(20, yBase));
  return { x, y };
}

function enhancedHydraulicsUIPosition() {
  const x = (typeof enhFrameX === 'number') ? enhFrameX + 18 : (width - 420);
  const y = (typeof frameY === 'number') ? frameY + 40 : (height - 360);
  return { x, y };
}

function diagnosticsUIPosition() {
  const x = (typeof diagFrameX === 'number') ? diagFrameX + 18 : (width - 320);
  const yBase = (typeof frameY2 === 'number') ? frameY2 + 40 : (height - 200);
  const y = Math.min(height - 200, Math.max(20, yBase));
  return { x, y };
}


function deadband(x, db){ return (Math.abs(x) <= db) ? 0 : (x > 0 ? x - db : x + db); }

// --- global, re-usable helpers (moved out of setup) ---
function smoothDeadbandPsi(dp_psi, db = IMB_DEADBAND_PSI){
  // tanh soft-threshold so small |ŒîP| produce ~0 flow
  const s = Math.tanh(Math.abs(dp_psi)/Math.max(db,1e-6));
  return Math.sign(dp_psi) * Math.max(0, Math.abs(dp_psi) - db) * s;
}


function num(v){ if (v==null) return 0; const s=String(v).trim().replace(',','.'); const x=parseFloat(s); return isFinite(x)?x:0; }
function average(arr){ if (!arr.length) return 0; return arr.reduce((a,b)=>a+b,0)/arr.length; }
function sumCells(arr,i0,i1){ if (i1<i0) return 0; i0=Math.max(0,i0); i1=Math.min(arr.length-1,i1); let s=0; for(let i=i0;i<=i1;i++) s+=arr[i]; return s; }
function area_circ(D){ return Math.PI * (D*D) / 4; }
function area_annulus(Do, Di){ return Math.max(Math.PI * (Do*Do - Di*Di) / 4, 1e-12); }
function Dh_annulus(Do, Di){ return Math.max(Do - Di, 1e-6); }
function smooth01(x){ return 1/(1+Math.exp(-8*(x-0.5))); }
function mapDepthToY(d){ return remap(d, 0, MAX_DEPTH, well.y, well.y + well.h); }

// Riser free-surface depth: max(CML-driven top, Loss-driven top), capped at BOP

function riserTopDepth(){
  // Riser visual top follows whichever column currently vents to surface
  const surfTop = (typeof surfaceColumnTopDepth === 'function')
    ? surfaceColumnTopDepth()
    : annulusTopDepthGlobal();
  levelRiserTop_m = Math.min(surfTop, BOP_DEPTH);
  return levelRiserTop_m;
}


// -------- Wet lengths for compliance (only wet sections contribute) --------
function wetLength_riser_m() {
  const top = Math.min(riserTopDepth(), BOP_DEPTH);
  return Math.max(0, BOP_DEPTH - top);
}
function wetLength_booster_m() {
  return Math.max(0, BOP_DEPTH - Math.min(levelBoosterTop_m, BOP_DEPTH));
}
function wetLength_DS_m() {
  return Math.max(0, TD_DEPTH - Math.min(levelDSTop_m, TD_DEPTH));
}
function wetLength_casing_m(){
  const topBelow = Math.max(BOP_DEPTH, annulusTopDepthGlobal());
  return Math.max(0, SHOE_DEPTH - topBelow);
}
function wetLength_openhole_m(){
  const topOH = Math.max(SHOE_DEPTH, annulusTopDepthGlobal());
  return Math.max(0, TD_DEPTH - topOH);
}


const A_riserAnn = () => area_annulus(riser_ID_m,  ds_OD_m);
const A_casingAnn= () => area_annulus(casing_ID_m, ds_OD_m);
const A_openAnn  = () => area_annulus(openhole_ODm,ds_OD_m);
const A_DS       = () => Math.PI * ds_ID_m * ds_ID_m / 4;
const A_booster  = () => Math.PI * booster_ID_m * booster_ID_m / 4;

function averageAnnulusAreaBelowBOP(){
  const L_csg = Math.max(SHOE_DEPTH - BOP_DEPTH, 0);
  const L_oh  = Math.max(TD_DEPTH - SHOE_DEPTH, 0);
  const total = L_csg + L_oh;
  if (total <= 1e-9) return Math.max(A_casingAnn(), 1e-9);
  return ((L_csg * A_casingAnn()) + (L_oh * A_openAnn())) / total;
}

function estimateTransitMinutes(length_m, q_m3s, area_m2){
  if (q_m3s <= 1e-9 || area_m2 <= 1e-9) return Infinity;
  const velocity = q_m3s / area_m2;
  if (velocity <= 1e-9) return Infinity;
  return (length_m / velocity) / 60;
}

function betaFluid(fl) {
  if (fl === 'OBM')   return 3.5e-10;   // 1/Pa
  if (fl === 'Diesel')return 8.0e-10;
  return 5.0e-10; // WBM default
}
const FLUID_TAG = () => (EH && EH.PCOR && EH.PCOR.fluid) ? EH.PCOR.fluid : 'WBM';

function systemWetVolumes_m3() {
  return {
    Vriser:   A_riserAnn() * wetLength_riser_m(),
    Vcasing:  A_casingAnn()* wetLength_casing_m(),
    Vopen:    A_openAnn()  * wetLength_openhole_m(),
    Vds:      A_DS()       * wetLength_DS_m(),
    Vbooster: A_booster()  * wetLength_booster_m(),
  };
}
function systemCompliance_m3_per_Pa() {
  const fl = FLUID_TAG();
  const {Vriser,Vcasing,Vopen,Vds,Vbooster} = systemWetVolumes_m3();
  return betaFluid(fl)*Vriser + betaFluid(fl)*Vcasing + betaFluid(fl)*Vopen
       + betaFluid(fl)*Vds   + betaFluid(fl)*Vbooster;
}
function averageSystemPressure_psi() {
  const P0 = sbpAppliedPsi();
  const P1 = pressureAtDepth(BOP_DEPTH);
  const P2 = pressureAtDepth(SHOE_DEPTH);
  const P3 = pressureAtDepth(TD_DEPTH);
  return (P0+P1+P2+P3)/4;
}
function compressionEquivalentFlow_gpm(dt_s) {
  if (dt_s <= 0) return 0;
  const C_m3_per_Pa = systemCompliance_m3_per_Pa();
  const Pavg_now = averageSystemPressure_psi();
  const dP_psi = Pavg_now - prevPavg_psi; prevPavg_psi = Pavg_now;
  if (Math.abs(dP_psi) < 0.05) return 0;

  const q_m3s = C_m3_per_Pa * ((dP_psi * 6894.757)/dt_s);
  const q_gpm = q_m3s * 15850.323;
  return 0.20 * q_gpm; // gentle under-relaxation
}

function applyClosedWellCompression(netVolumeChange_m3s, dt_s, contextLabel){
  if (!isFinite(netVolumeChange_m3s) || Math.abs(netVolumeChange_m3s) < 1e-9) return;
  const dt = Math.max(dt_s || (typeof window !== 'undefined' ? window.dt_s : 0) || 1/60, 1/120);
  const deltaPsi = netVolumeChange_m3s * 6.28981 * dt * CLOSED_WELL_PSI_PER_BBL;
  const prev = closedWellPressureBoost_psi || 0;
  closedWellPressureBoost_psi = clamp(prev + deltaPsi, 0, CLOSED_WELL_MAX_PSI);

  const warnLabel = contextLabel || 'SHUT IN';
  if (typeof window !== 'undefined') {
    if (closedWellPressureBoost_psi >= CLOSED_WELL_MAX_PSI) {
      window.__PRESSURE_COMPRESSION_WARNING = `üõë CRITICAL: Pressure limited at ${CLOSED_WELL_MAX_PSI} psi - ${warnLabel}!`;
    } else if (closedWellPressureBoost_psi > CLOSED_WELL_WARNING_PSI) {
      window.__PRESSURE_COMPRESSION_WARNING = `‚ö†Ô∏è CLOSED WELL PRESSURE: ${closedWellPressureBoost_psi.toFixed(0)} psi - ${warnLabel}`;
    } else if ((typeof isWellShutInByValves === 'function' ? !isWellShutInByValves() : true)
        && !(typeof mpdSealActive === 'function' && mpdSealActive())) {
      window.__PRESSURE_COMPRESSION_WARNING = null;
    }
  }
}

function bleedClosedWellPressure(dt_s){
  const dt = Math.max(dt_s || (typeof window !== 'undefined' ? window.dt_s : 0) || 1/60, 1/120);
  const tau = 4.0;
  const decay = Math.exp(-dt / tau);
  closedWellPressureBoost_psi *= decay;
  if (closedWellPressureBoost_psi < 1) {
    closedWellPressureBoost_psi = 0;
  }
  if (typeof window !== 'undefined') {
    if (closedWellPressureBoost_psi < CLOSED_WELL_WARNING_PSI * 0.8) {
      window.__PRESSURE_COMPRESSION_WARNING = null;
    }
  }
}

// --------------------- Loss zones: mapping & calibration ---------------------
function mapLossZonesToGrid(){
  for (const z of lossZones){
    if (!z.enabled || z.depth_m <= 0){ z.cellIdx=-1; z.section=''; z.CL=0; continue; }
    if (z.depth_m <= BOP_DEPTH){ z.section='riser';    z.cellIdx=Math.floor(z.depth_m / CELL_M); }
    else if (z.depth_m <= SHOE_DEPTH){ z.section='casing'; z.cellIdx=Math.floor((z.depth_m - BOP_DEPTH)/CELL_M); }
    else { z.section='openhole'; z.cellIdx=Math.floor((z.depth_m - SHOE_DEPTH)/CELL_M); }

        const n = (z.n || 1.0);
    // Prefer direct PI if provided (units gpm/psi^n)
    if (z.PI_gpm_per_psiN && z.PI_gpm_per_psiN > 0) {
      z.CL = z.PI_gpm_per_psiN;
    } else if (z.Qref_gpm > 0 && z.DPref_psi > 0) {
      // Backward compatible path: C_L = Qref / (ŒîPref)^n
      z.CL = z.Qref_gpm / Math.pow(z.DPref_psi, n);
    } else {
      z.CL = 0;
    }
//Why your Qref/DPref isn't working:
// Your current setup: Qref=2200 gpm, DPref=100 psi means the zone takes 2200 gpm at only 100 psi over fracture

  }
}

/* ===================== LOSS-ZONE MARKERS (helpers) ===================== */
/* =================== END LOSS-ZONE MARKERS (helpers) =================== */

// =========================== HYDRAULICS CORE ===========================
// Rotation shear rates
function rotShearRateAnnulus(rpm, Di, Do){
  if (rpm <= 0) return 0;
  const omega = TWO_PI * rpm / 60;
  const Ri = Math.max(Di,1e-6) / 2;
  const gap = Math.max(Do - Di, 1e-6);
  return (omega * Ri) / gap; // s^-1
}
function rotShearRatePipe(rpm, ID){
  if (rpm <= 0) return 0;
  // near-wall added shear ~ O(œâ)
  return TWO_PI * rpm / 60;
}
// Taylor-number helpers (physics-based rotation boost)
function taylorNumber(rpm, Di, Do, nu){
  const omega = TWO_PI * Math.max(rpm,0) / 60;
  const Ri = Math.max(Di,1e-6) / 2;
  const gap = Math.max(Do - Di, 1e-6);
  return (omega * Ri * gap) / Math.max(nu, 1e-12);
}
function applyTaylorBoost(base, rpm, Di, Do, mu_app, rho, n){
  const nu = Math.max(mu_app,1e-9)/Math.max(rho,1e-9);
  const omega = TWO_PI * Math.max(rpm,0) / 60;
  const Ri = Math.max(Di,1e-6) / 2;
  const gap = Math.max(Do - Di, 1e-6);
  const Ta = (omega * Ri * gap) / Math.max(nu, 1e-12);
  const { Ta_c, C0, Cn } = TAYLOR_BOOST;
  // stronger boost; increased sensitivity for shear-thinning (n<1)
  const C = C0 * (1 + Cn * Math.max(0, 1 - (n ?? 1)));
  const ratio = Math.max(Ta / Math.max(Ta_c, 1e-6), 0);
  return base * (1 + C * Math.sqrt(ratio));
}
// HB laminar formulas (slot annulus + pipe)
function mu_app_HB(gdot, K, n, tauY){
  gdot = Math.max(gdot, 1e-6);
  return tauY/gdot + K*Math.pow(gdot, n-1);
}
// Annulus laminar as slot (captures yield offset)
function dpPerM_annulusLaminar_HB(Q, rho, Do, Di, K, n, tauY, rpm){
  const A = area_annulus(Do, Di);
  const b = Math.max((Do - Di)/2, 1e-6); // half-gap
  const V = Q / Math.max(A,1e-12);
  // axial + rotational shear blended in quadrature (stronger coupling)
  const g_ax = 6 * Math.abs(V) / b;
  const g_rot = rotShearRateAnnulus(rpm, Di, Do);
  const g_eff = Math.sqrt(g_ax*g_ax + (ROT_COUPLE*g_rot)*(ROT_COUPLE*g_rot));
  const g_w = ((2*n+1)/(3*n)) * Math.max(g_eff,1e-6);
  const tau_w = tauY + K*Math.pow(g_w,n);
  let dpdl = 2*tau_w / b; // Pa/m
  const muApp = mu_app_HB(g_w, K, n, tauY);
  dpdl = applyTaylorBoost(dpdl, rpm, Di, Do, muApp, rho, n);
  dpdl *= eccMultiplier(Do, Di);
  return dpdl;
}
// Pipe laminar HB (Rabinowitsch)
function dpPerM_pipeLaminar_HB(Q, rho, ID, K, n, tauY, rpm){
  const A = Math.PI*Math.max(ID*ID,1e-12)/4;
  const V = Q / A;
  const Dh = Math.max(ID,1e-6);
  const g_ax = 8 * Math.abs(V) / Dh;
  const g_rot = rotShearRatePipe(rpm, ID);
  const g_eff = Math.sqrt(g_ax*g_ax + (ROT_COUPLE*g_rot)*(ROT_COUPLE*g_rot));
  const g_w = ((3*n+1)/(4*n)) * Math.max(g_eff,1e-6);
  const tau_w = tauY + K*Math.pow(g_w,n);
  return (4*tau_w) / Dh; // Pa/m
}
// Baseline friction models
function dpPerM_API_withRot(rho, V, Dh, K, n, tauY, gdotExtra){
  const gdot = Math.max(8*V/Math.max(Dh,1e-6) + (gdotExtra||0), 1e-6);
  const muApp = tauY/gdot + K*Math.pow(gdot, n-1);
  const Re = (rho * V * Dh) / Math.max(muApp, 1e-9);
  const f = (Re < 2100) ? 16/Math.max(Re,1e-6) : 0.079/Math.pow(Math.max(Re,1e-6),0.25);
  let dp = f * (rho*V*V/2) / Math.max(Dh,1e-6);

  // ‚úÖ FIX: Add yield stress contribution for turbulent flow
  // For Herschel-Bulkley fluids, yield stress contributes to wall shear even in turbulent regime
  // Add direct yield stress term: dp_yield = 2*tau_y / (Dh/2) for annulus geometry
  if (Re >= 2100 && tauY > 0) {
    const dp_yield = (4 * tauY) / Math.max(Dh, 1e-6);  // Yield stress pressure drop
    dp += dp_yield;  // Add to turbulent friction
  }

  return dp;
}
function dpPerM_Refined_withRot(rho, V, Dh, K, n, tauY, gdotExtra){
  // Blended laminar/turbulent with mild non-Newtonian adjustments
  const gdot = Math.max(8*V/Math.max(Dh,1e-6) + (gdotExtra||0), 1e-6);
  const muApp = tauY/gdot + K*Math.pow(gdot, n-1);
  const Re = (rho * V * Dh) / Math.max(muApp, 1e-9);
  const fLam = (16/Math.max(Re,1e-6))*(1 + Math.min(0.25, tauY/(K*1e-3 + 1e-6)));
  const alpha = 0.0665 + 0.0175*n, beta = 0.365 - 0.0620*n;
  const fTur = alpha/Math.pow(Math.max(Re,1e-6), beta);
  const blend = 1/(1+Math.exp(-(Re-2500)/400));
  let f = (1-blend)*fLam + blend*fTur;
  f *= (1 - 0.05*Math.max(0,1-n)); // slight shear-thinning easing
  let dp = f * (rho*V*V/2) / Math.max(Dh,1e-6);

  // ‚úÖ FIX: Add yield stress contribution for turbulent flow
  // For Herschel-Bulkley fluids, yield stress contributes to wall shear even in turbulent regime
  // Blend this contribution based on how turbulent we are (same blend as friction factor)
  const dp_before = dp;  // Store before adding yield boost
  let dp_yield = 0;
  if (tauY > 0) {
    dp_yield = (4 * tauY) / Math.max(Dh, 1e-6);  // Yield stress pressure drop
    dp += blend * dp_yield;  // Add proportionally to turbulent fraction
  }
  const dp_after = dp;  // Store after adding yield boost

  // Debug: Store yield stress boost for logging (attach to window for access)
  if (typeof window !== 'undefined') {
    window.__lastYieldBoost = {
      tauY, dp_yield, blend, boost: blend * dp_yield, Dh, Re,
      dp_before, dp_after, actual_boost: dp_after - dp_before
    };
  }

  return dp;
}
// Yield thresholds to avoid crazy low-flow spikes
function dpMin_pipe_per_m(tauY, Dh){ return 4*Math.max(tauY, use_gel ? gel_Pa : 0)/Math.max(Dh,1e-6); }
function dpMin_ann_per_m(tauY, Do, Di){ return 2*Math.max(tauY, use_gel ? gel_Pa : 0)/Math.max(Do-Di,1e-6); }
// Unified section pressure gradient
function dP_per_m_annulus_withRPM(Q, rho, Do, Di, K, n, tauY, rpm){
  if (Q <= 0) return 0;
  const A = area_annulus(Do, Di);
  const Dh = Math.max(Do - Di, 1e-6);
  const V = Q / Math.max(A,1e-12);
  const b = Dh/2;
  const g_ax = 6 * Math.abs(V) / Math.max(b,1e-6);
  const g_rot = rotShearRateAnnulus(rpm, Di, Do);
  const g_eff = Math.sqrt(g_ax*g_ax + (ROT_COUPLE*g_rot)*(ROT_COUPLE*g_rot));
  const g_w = ((2*n+1)/(3*n)) * Math.max(g_eff,1e-6);
  const muAw = mu_app_HB(g_w, K, n, tauY);
  const Re_g = (rho * Math.max(Math.abs(V),1e-12) * Dh) / Math.max(muAw,1e-9);

  // ‚úÖ SMOOTH TRANSITION: Blend laminar and turbulent between Re=2000-4000
  // Wider zone for non-Newtonian fluids + monotonicity enforcement
  const RE_LAM = 2000;   // Fully laminar below this
  const RE_TURB = 4000;  // Fully turbulent above this (widened from 2300)

  // No-op function for production (debug removed)
  const logFlowRegime = (regime, Re_g, dp_lam, dp_turb, dp_result, blend_pct, rough, ecc, dp_base) => {};

  if (Re_g < RE_LAM){
    // Fully laminar
    const dp_lam = dpPerM_annulusLaminar_HB(Q, rho, Do, Di, K, n, tauY, rpm);
    logFlowRegime('LAMINAR', Re_g, dp_lam, null, dp_lam, null, null, null, null);
    return dp_lam;
  } else if (Re_g > RE_TURB){
    // Fully turbulent
    const dp_base = (HYDRAULICS_MODEL==="API")
      ? dpPerM_API_withRot(rho, V, Dh, K, n, tauY, g_rot)
      : dpPerM_Refined_withRot(rho, V, Dh, K, n, tauY, g_rot);
    let dp_turb = applyTaylorBoost(dp_base, rpm, Di, Do, muAw, rho, n);
    const rough = roughMultiplier(true);
    const ecc = eccMultiplier(Do, Di);
    dp_turb *= rough;
    dp_turb *= ecc;
    logFlowRegime('TURBULENT', Re_g, null, dp_turb, dp_turb, 100, rough, ecc, dp_base);
    return dp_turb;
  } else {
    // TRANSITION ZONE: Blend between laminar and turbulent
    const dp_lam = dpPerM_annulusLaminar_HB(Q, rho, Do, Di, K, n, tauY, rpm);
    const dp_base = (HYDRAULICS_MODEL==="API")
      ? dpPerM_API_withRot(rho, V, Dh, K, n, tauY, g_rot)
      : dpPerM_Refined_withRot(rho, V, Dh, K, n, tauY, g_rot);
    let dp_turb = applyTaylorBoost(dp_base, rpm, Di, Do, muAw, rho, n);
    const rough = roughMultiplier(true);
    const ecc = eccMultiplier(Do, Di);
    dp_turb *= rough;
    dp_turb *= ecc;

    // ‚úÖ MONOTONICITY FIX: Turbulent must never be less than laminar
    // This ensures friction increases monotonically with flow rate
    const dp_turb_corrected = Math.max(dp_turb, dp_lam);

    // Smooth cubic blend: f(Re) = 3t¬≤ - 2t¬≥ where t = (Re - RE_LAM)/(RE_TURB - RE_LAM)
    const t = (Re_g - RE_LAM) / (RE_TURB - RE_LAM);
    const blend = t * t * (3 - 2 * t);  // Smoothstep function
    let result = dp_lam * (1 - blend) + dp_turb_corrected * blend;

    // ‚úÖ FINAL SAFETY: Result must NEVER be less than laminar
    // This GUARANTEES monotonicity because laminar dp increases with Q
    result = Math.max(result, dp_lam);

    logFlowRegime('TRANSITION', Re_g, dp_lam, dp_turb_corrected, result, blend*100, rough, ecc, dp_base);

    return result;
  }
}
function dP_per_m_pipe_withRPM(Q, rho, ID, K, n, tauY, rpm){
  if (Q <= 0) return 0;
  const A = Math.PI*Math.max(ID*ID,1e-12)/4;
  const V = Q / A;
  const Dh = Math.max(ID,1e-6);
  const g_ax = 8 * Math.abs(V) / Dh;
  const g_rot = rotShearRatePipe(rpm, ID);
  const g_eff = Math.sqrt(g_ax*g_ax + (ROT_COUPLE*g_rot)*(ROT_COUPLE*g_rot));
  const g_w = ((3*n+1)/(4*n)) * Math.max(g_eff,1e-6);
  const muAw = mu_app_HB(g_w, K, n, tauY);
  const Re_g = (rho * Math.max(Math.abs(V),1e-12) * Dh) / Math.max(muAw,1e-9);

  // ‚úÖ SMOOTH TRANSITION: Blend laminar and turbulent between Re=2000-4000
  // Wider zone for non-Newtonian fluids + monotonicity enforcement
  const RE_LAM = 2000;
  const RE_TURB = 4000;  // Widened from 2300

  if (Re_g < RE_LAM){
    return dpPerM_pipeLaminar_HB(Q, rho, ID, K, n, tauY, rpm);
  } else if (Re_g > RE_TURB){
    let dp_turb = (HYDRAULICS_MODEL==="API")
      ? dpPerM_API_withRot(rho, V, Dh, K, n, tauY, g_rot)
      : dpPerM_Refined_withRot(rho, V, Dh, K, n, tauY, g_rot);
    dp_turb *= roughMultiplier(true);
    return dp_turb;
  } else {
    // TRANSITION ZONE: Smooth blend
    const dp_lam = dpPerM_pipeLaminar_HB(Q, rho, ID, K, n, tauY, rpm);
    let dp_turb = (HYDRAULICS_MODEL==="API")
      ? dpPerM_API_withRot(rho, V, Dh, K, n, tauY, g_rot)
      : dpPerM_Refined_withRot(rho, V, Dh, K, n, tauY, g_rot);
    dp_turb *= roughMultiplier(true);

    const t = (Re_g - RE_LAM) / (RE_TURB - RE_LAM);
    const blend = t * t * (3 - 2 * t);
    let result = dp_lam * (1 - blend) + dp_turb * blend;

    // ‚úÖ PHYSICS ENFORCEMENT: Ensure monotonicity
    const dp_min = dp_lam * 0.8;
    if (result < dp_min) result = dp_min;

    return result;
  }
}
function eccMultiplier(Do, Di){
  // baseline: no change
  if (!EH.ECC.on) return 1.0;
  // sensitivity: tighter annulus ‚Üí stronger effect
  const gap = Math.max(Do - Di, 1e-6);
  const tight = clamp((0.25 - gap)/0.25, 0, 1); // strong when gap <~ 0.25 m
  // map slider s‚àà[-1,1] to gain 1 ¬± (gain_max * tight)
  const gmax = EH_TUNE.ecc_max_gain * tight;
  return 1 + EH.ECC.s * gmax;
}
function roughMultiplier(isTurb){
  if (!isTurb || !EH.ROUGH.on) return 1.0;
  // slider s‚àà[-1,1] ‚Üí 1 ¬± rough_max_gain
  return 1 + EH.ROUGH.s * EH_TUNE.rough_max_gain;
}
function localKLossPsi(){
  if (!EH.KLOSS.on) return 0;
  // slider s‚àà[-1,1] maps to ¬± kloss_spp_base psi
  return EH_TUNE.kloss_spp_base * EH.KLOSS.s;
}
// reference velocity at Q_REF in the riser annulus
function A_riser() { return area_annulus(riser_ID_m, ds_OD_m); }
const V_REF = () => (Q_REF/15850.323) / Math.max(A_riser(), 1e-12);
// Time acceleration for visualization
const TIME_ACCEL = 3.0; // Speed up simulation for better visibility
const CML_TIME_ACCEL = 5.0; // Additional boost for CML level changes
// ========================== SEGMENTED ADVECTION ==========================

// Add this NEW function before stepAdvection():
// Modify computeFlowProfile() - change the reversal condition:
// Replace your entire computeFlowProfile() function with this:
function computeFlowProfile() {
  // Returns flow rates (m¬≥/s) at each section, accounting for losses
  // Positive = upward, Negative = downward
  
  const qDS_in = (Q_DS || 0) / 15850.323;
  const qBO_in = (Q_BO || 0) / 15850.323;
  const qCML = (effective_Q_CML_gpm() || 0) / 15850.323;
  const qTF = (TOPFILL_ON && Q_TOPFILL > 0) ? (Q_TOPFILL / 15850.323) : 0;
  
  // ‚úÖ DEFINE activeLosses here
  const activeLosses = (lossZones || [])
    .filter(z => z && z.enabled && z.depth_m > 0 && z.Qloss_gpm > 0)
    .map(z => ({depth: z.depth_m, q_m3s: z.Qloss_gpm / 15850.323}))
    .sort((a,b) => b.depth - a.depth); // Deepest first
  
  // Build flow profile
  let profile = {
    ds: qDS_in,
    openhole: 0,
    casing: 0,
    riser: 0,
    booster: 0,
    boosterDirection: 'down',
    topfill: qTF,
    topfillDirection: 'down'
  };
  
  // Calculate annulus flow going UP from bit (subtracting losses)
  let qAnn = qDS_in;
  
  for (const loss of activeLosses) {
    qAnn = Math.max(0, qAnn - loss.q_m3s);
    if (loss.depth > SHOE_DEPTH) {
      profile.openhole = qAnn;
    } else if (loss.depth > BOP_DEPTH) {
      profile.casing = qAnn;
    } else {
      profile.riser = qAnn;
    }
  }
  
  // Fill in sections without explicit losses
  if (!activeLosses.some(l => l.depth > SHOE_DEPTH)) {
    profile.openhole = qAnn;
  }
  if (!activeLosses.some(l => l.depth > BOP_DEPTH && l.depth <= SHOE_DEPTH)) {
    profile.casing = profile.openhole;
  }
  
  // Determine booster direction
  const annulusTop = annulusTopDepthGlobal();
  const riserNotFull = annulusTop > 0.5; // Any headspace = booster can't go up
  
  if (riserNotFull) {
    // ‚úÖ Booster has nowhere to go UP ‚Üí flows DOWN
    profile.booster = qBO_in;
    profile.boosterDirection = 'down';
    profile.riser = -qTF; // Only Top Fill (negative = flowing down)
    
    // ‚úÖ Below BOP gets DS + Booster + TopFill flowing DOWN from fluid level
    const qBelowTotal = qDS_in + qBO_in + qTF;
    
    // Subtract losses below the current fluid level
    let qRemaining = qBelowTotal;
    for (const loss of activeLosses.filter(l => l.depth >= annulusTop)) {
      qRemaining = Math.max(0, qRemaining - loss.q_m3s);
    }
    
    profile.casing = qRemaining;
    profile.openhole = qRemaining;
    
  } else {
    // Normal: Riser full, booster flows UP
    profile.booster = qBO_in;
    profile.boosterDirection = 'up';
    
    profile.riser = profile.casing + qBO_in - qCML - qTF;
    
    // Subtract riser losses
    for (const loss of activeLosses.filter(l => l.depth <= BOP_DEPTH)) {
      profile.riser = Math.max(0, profile.riser - loss.q_m3s);
    }
  }
  
  return profile;
}


// NEW FUNCTION: Calculate flow rate at any depth accounting for losses
function flowRateAtDepth(depth_m, baseFlow_m3s) {
  // Start with base flow and subtract all losses BELOW this depth
  let qRemaining = baseFlow_m3s;
  
  if (LOSSES_ON && lossZones) {
    for (const z of lossZones) {
      if (z && z.enabled && z.depth_m > depth_m && z.Qloss_gpm > 0) {
        const qLoss = z.Qloss_gpm / 15850.323;
        qRemaining = Math.max(0, qRemaining - qLoss);
      }
    }
  }
  
  return qRemaining;
}
// === Loss demand (sum of all zone demands; do NOT cap by flow) ===
function totalLossDemand_m3s(){
  if (!LOSSES_ON || !Array.isArray(lossZones)) return 0;
  let sum_gpm = 0;
  for (const z of lossZones){
    if (!z || !z.enabled) continue;
    sum_gpm += Math.max(0, z.Qdem_filt_gpm || 0);
  }
  // (optional global cap you may have added‚Ä¶)
  return sum_gpm / 15850.323;
}


// === Cross-sectional area at the current free surface (riser/casing/openhole) ===
function annulusAreaAtTop() {
  const top = annulusTopDepthGlobal();
  if (top < BOP_DEPTH)    return area_annulus(riser_ID_m,  ds_OD_m);
  if (top < SHOE_DEPTH)   return area_annulus(casing_ID_m, ds_OD_m);
  return                      area_annulus(openhole_ODm,   ds_OD_m);
}

// NEW HELPER: Find where fluid exits (loss zone or surface)
function findFluidExitPoint(startDepth_m, flowRate_m3s, flowDirection) {
  // Returns: {depth: exit_depth_m, reason: 'loss'|'surface'|'static'}
  
  if (!LOSSES_ON || !lossZones || flowRate_m3s < 1e-6) {
    return flowDirection === 'up' 
      ? {depth: 0, reason: 'surface'}
      : {depth: TD_DEPTH, reason: 'static'};
  }
  
  let qRemaining = Math.abs(flowRate_m3s);
  const sortedLosses = lossZones
    .filter(z => z && z.enabled && z.depth_m > 0 && z.Qloss_gpm > 0)
    .sort((a, b) => flowDirection === 'up' ? (a.depth_m - b.depth_m) : (b.depth_m - a.depth_m));
  
  for (const z of sortedLosses) {
    // Check if this loss is in the flow path
    const inPath = flowDirection === 'up' 
      ? (z.depth_m > startDepth_m)
      : (z.depth_m < startDepth_m);
    
    if (inPath) {
      const qLoss = z.Qloss_gpm / 15850.323;
      qRemaining -= qLoss;
      if (qRemaining <= 1e-6) {
        return {depth: z.depth_m, reason: 'loss'};
      }
    }
  }
  
  // Flow reaches the end
  return flowDirection === 'up'
    ? {depth: 0, reason: 'surface'}
    : {depth: TD_DEPTH, reason: 'static'};
}

// ========================================================================
// FORMATION FLUID PHYSICS
// ========================================================================

function initializeFormationFluidCells() {
  // Initialize arrays to track formation fluid in each cell
  formationFluidCells_below = new Array(N_BELOW).fill(0);
  formationFluidCells_above = new Array(N_ABV).fill(0);
  gasPhaseFrom_below = new Array(N_BELOW).fill(0);
  gasPhaseFrom_above = new Array(N_ABV).fill(0);
  oilPhaseFrom_below = new Array(N_BELOW).fill(0);
  oilPhaseFrom_above = new Array(N_ABV).fill(0);
  waterPhaseFrom_below = new Array(N_BELOW).fill(0);
  waterPhaseFrom_above = new Array(N_ABV).fill(0);
  formationFluidOverflow_m3 = 0;
}

function calculateMigrationVelocity_m_s(fluidType, pressure_psi, mudWeight_ppg) {
  // Migration velocity calculations based on literature
  const fluidProps = FORMATION_FLUID_TYPES[fluidType];
  if (!fluidProps) return 0;

  const rho_mud_kgm3 = mudWeight_ppg * PPG_TO_KGM3;
  const rho_fluid_kgm3 = fluidProps.density_kgm3;
  const drho = rho_mud_kgm3 - rho_fluid_kgm3; // Density difference

  if (drho <= 0) return 0; // Fluid heavier than mud, doesn't migrate

  const g = 9.81; // m/s¬≤

  switch (formationFluidMigrationModel) {
    case 'SHUTIN':
      // Shut-in formula: v = 0 (no migration when shut in)
      return 0;

    case 'HARMATHY':
      // Harmathy correlation for gas rise in stagnant fluid
      // v = 0.35 * sqrt(g * D * ŒîœÅ / œÅ_mud)
      // Assuming annulus hydraulic diameter
      const D_h = 0.1; // Approximate annulus Dh in meters
      return 0.35 * Math.sqrt(g * D_h * drho / rho_mud_kgm3);

    case 'MODIFIED_HARMATHY':
      // Modified for wellbore conditions with adjustments for viscosity
      const mu_mud_cp = 30; // Assumed mud viscosity
      const mu_ratio = mu_mud_cp / Math.max(fluidProps.viscosity_cp, 0.1);
      const D_h2 = 0.1;
      const v_base = 0.35 * Math.sqrt(g * D_h2 * drho / rho_mud_kgm3);
      return v_base / Math.sqrt(mu_ratio); // Slower rise in viscous mud

    default:
      return 0;
  }
}

// Migrate kick fluids upward through cells (independent of new influx)
// Works even in static annulus conditions (no flow)
function migrateKickFluids(dt_s) {
  if (formationFluidMigrationModel === 'SHUTIN') return;

  // Calculate migration velocity based on fluid type and conditions
  const avgMW = (MW_DS + MW_BO) / 2; // Simplified average mud weight

  // Migrate fluids in each section independently
  // BELOW BOP (annulus below BOP)
  for (let i = 0; i < N_BELOW; i++) {
    const depth_m = BOP_DEPTH + i * CELL_M;
    const avgPressure = pressureAtDepth(depth_m);

    // Gas migration (if present)
    if (gasPhaseFrom_below[i] > 0.001) {
      const migVel_gas = calculateMigrationVelocity_m_s('GAS', avgPressure, avgMW);
      if (migVel_gas > 0.01) {
        const migrationDist_m = migVel_gas * dt_s;
        const cellsMoved = migrationDist_m / CELL_M;

        // Move fraction of gas to cell above
        if (i > 0 && cellsMoved > 0) {
          const moveFraction = Math.min(cellsMoved, gasPhaseFrom_below[i]);
          gasPhaseFrom_below[i] -= moveFraction;
          gasPhaseFrom_below[i - 1] = Math.min(1.0, (gasPhaseFrom_below[i - 1] || 0) + moveFraction);
        }
      }
    }

    // Oil migration (if present)
    if (oilPhaseFrom_below[i] > 0.001) {
      const migVel_oil = calculateMigrationVelocity_m_s('OIL', avgPressure, avgMW);
      if (migVel_oil > 0.01) {
        const migrationDist_m = migVel_oil * dt_s;
        const cellsMoved = migrationDist_m / CELL_M;

        if (i > 0 && cellsMoved > 0) {
          const moveFraction = Math.min(cellsMoved * 0.7, oilPhaseFrom_below[i]); // Oil slower than gas
          oilPhaseFrom_below[i] -= moveFraction;
          oilPhaseFrom_below[i - 1] = Math.min(1.0, (oilPhaseFrom_below[i - 1] || 0) + moveFraction);
        }
      }
    }

    // Water migration (if present)
    if (waterPhaseFrom_below[i] > 0.001) {
      const migVel_water = calculateMigrationVelocity_m_s('WATER', avgPressure, avgMW);
      if (migVel_water > 0.01) {
        const migrationDist_m = migVel_water * dt_s;
        const cellsMoved = migrationDist_m / CELL_M;

        if (i > 0 && cellsMoved > 0) {
          const moveFraction = Math.min(cellsMoved * 0.4, waterPhaseFrom_below[i]); // Water slower than oil
          waterPhaseFrom_below[i] -= moveFraction;
          waterPhaseFrom_below[i - 1] = Math.min(1.0, (waterPhaseFrom_below[i - 1] || 0) + moveFraction);
        }
      }
    }
  }

  // ABOVE BOP (riser section)
  for (let i = N_ABV - 1; i >= 0; i--) {
    const depth_m = i * CELL_M;
    const avgPressure = pressureAtDepth(depth_m);

    // Gas migration
    if (gasPhaseFrom_above[i] > 0.001) {
      const migVel_gas = calculateMigrationVelocity_m_s('GAS', avgPressure, avgMW);
      if (migVel_gas > 0.01) {
        const migrationDist_m = migVel_gas * dt_s;
        const cellsMoved = migrationDist_m / CELL_M;

        if (i > 0 && cellsMoved > 0) {
          const moveFraction = Math.min(cellsMoved, gasPhaseFrom_above[i]);
          gasPhaseFrom_above[i] -= moveFraction;
          gasPhaseFrom_above[i - 1] = Math.min(1.0, (gasPhaseFrom_above[i - 1] || 0) + moveFraction);
        }
      }
    }

    // Oil migration
    if (oilPhaseFrom_above[i] > 0.001) {
      const migVel_oil = calculateMigrationVelocity_m_s('OIL', avgPressure, avgMW);
      if (migVel_oil > 0.01) {
        const migrationDist_m = migVel_oil * dt_s;
        const cellsMoved = migrationDist_m / CELL_M;

        if (i > 0 && cellsMoved > 0) {
          const moveFraction = Math.min(cellsMoved * 0.7, oilPhaseFrom_above[i]);
          oilPhaseFrom_above[i] -= moveFraction;
          oilPhaseFrom_above[i - 1] = Math.min(1.0, (oilPhaseFrom_above[i - 1] || 0) + moveFraction);
        }
      }
    }

    // Water migration
    if (waterPhaseFrom_above[i] > 0.001) {
      const migVel_water = calculateMigrationVelocity_m_s('WATER', avgPressure, avgMW);
      if (migVel_water > 0.01) {
        const migrationDist_m = migVel_water * dt_s;
        const cellsMoved = migrationDist_m / CELL_M;

        if (i > 0 && cellsMoved > 0) {
          const moveFraction = Math.min(cellsMoved * 0.4, waterPhaseFrom_above[i]);
          waterPhaseFrom_above[i] -= moveFraction;
          waterPhaseFrom_above[i - 1] = Math.min(1.0, (waterPhaseFrom_above[i - 1] || 0) + moveFraction);
        }
      }
    }
  }
}

function mixFormationFluidIntoGrid(grid, index, fluidDensity_ppg, fraction){
  if (!Array.isArray(grid) || index < 0 || index >= grid.length) return;
  const f = clamp(fraction, 0, 1);
  if (f <= 0) return;
  const base = isFinite(grid[index]) ? grid[index] : MW_DS;
  grid[index] = base * (1 - f) + fluidDensity_ppg * f;
}

function formationSectionConfig(section){
  if (section === 'below') {
    return {
      gas: gasPhaseFrom_below,
      oil: oilPhaseFrom_below,
      water: waterPhaseFrom_below,
      grid: annBelowGrid,
      depthOffset: BOP_DEPTH
    };
  }
  if (section === 'above') {
    return {
      gas: gasPhaseFrom_above,
      oil: oilPhaseFrom_above,
      water: waterPhaseFrom_above,
      grid: annAboveGrid,
      depthOffset: 0
    };
  }
  return null;
}

function formationCellVolume_m3(section, idx){
  const cfg = formationSectionConfig(section);
  if (!cfg || idx < 0 || idx >= cfg.gas.length) return 0;
  const depthTop = cfg.depthOffset + idx * CELL_M;
  const depthMid = depthTop + CELL_M * 0.5;
  const area = areaAtDepthTop_(depthMid);
  return Math.max(area * CELL_M, 1e-9);
}

function formationCellCapacity(section, idx){
  const cfg = formationSectionConfig(section);
  if (!cfg || idx < 0 || idx >= cfg.gas.length) return 0;
  const occupied = (cfg.gas[idx] || 0) + (cfg.oil[idx] || 0) + (cfg.water[idx] || 0);
  return clamp(1 - occupied, 0, 1);
}

function addFormationFluidFraction(section, idx, addFrac){
  const cfg = formationSectionConfig(section);
  if (!cfg || idx < 0 || idx >= cfg.gas.length) return;
  const target = formationFluidType;
  if (target === 'GAS') {
    cfg.gas[idx] = Math.min(1.0, (cfg.gas[idx] || 0) + addFrac);
  } else if (target === 'OIL' || target === 'BLACKOIL') {
    cfg.oil[idx] = Math.min(1.0, (cfg.oil[idx] || 0) + addFrac);
  } else {
    cfg.water[idx] = Math.min(1.0, (cfg.water[idx] || 0) + addFrac);
  }
}

function distributeFormationFluidVolume(section, startIdx, volume_m3, density_ppg){
  const cfg = formationSectionConfig(section);
  if (!cfg) return volume_m3;
  const len = cfg.gas.length;
  if (!len || volume_m3 <= 1e-12) return volume_m3;
  let idx = clamp(startIdx, 0, len - 1);
  let remaining = volume_m3;
  while (remaining > 1e-9 && idx >= 0) {
    const capacity = formationCellCapacity(section, idx);
    if (capacity <= 1e-6) {
      idx -= 1;
      continue;
    }
    const cellVol = formationCellVolume_m3(section, idx);
    const maxVolHere = capacity * cellVol;
    const usedVol = Math.min(maxVolHere, remaining);
    if (usedVol <= 0) {
      idx -= 1;
      continue;
    }
    const addFrac = usedVol / cellVol;
    addFormationFluidFraction(section, idx, addFrac);
    mixFormationFluidIntoGrid(cfg.grid, idx, density_ppg, addFrac);
    remaining -= usedVol;
    idx -= 1; // march toward surface/BOP
  }
  return remaining;
}

function currentFormationFluidInventory_m3(){
  const cellH = CELL_M;
  let total = 0;

  for (let i = 0; i < N_BELOW; i++) {
    const frac = (gasPhaseFrom_below[i] || 0) + (oilPhaseFrom_below[i] || 0) + (waterPhaseFrom_below[i] || 0);
    if (frac > 1e-4) {
      const depthMid = BOP_DEPTH + i * CELL_M + CELL_M * 0.5;
      const area = areaAtDepthTop_(depthMid);
      total += frac * Math.max(area, 1e-9) * cellH;
    }
  }

  for (let i = 0; i < N_ABV; i++) {
    const frac = (gasPhaseFrom_above[i] || 0) + (oilPhaseFrom_above[i] || 0) + (waterPhaseFrom_above[i] || 0);
    if (frac > 1e-4) {
      const depthMid = i * CELL_M + CELL_M * 0.5;
      const area = areaAtDepthTop_(depthMid);
      total += frac * Math.max(area, 1e-9) * cellH;
    }
  }

  return total;
}

function currentFormationFluidInventory_bbl(){
  return currentFormationFluidInventory_m3() * 6.28981;
}

function updateFormationFluidMigration(dt_s) {
  // Reset influx rate
  current_influx_m3s = 0;
  autoKickBalancePsi = 0;

  if (!formationFluidEnabled) {
    if (typeof window !== 'undefined') {
      window.__influxRate_gpm = 0;
      window.__influxInventory_bbl = 0;
    }
    return;
  }

  const fluidProps = FORMATION_FLUID_TYPES[formationFluidType];
  if (!fluidProps) return;

  const expansion_m3s = Math.max(0, window.__gasExpansion_m3s || 0);
  window.__gasExpansion_m3s = 0;

  const sealedByValves = isWellShutInByValves();
  const mpdSealed = (typeof mpdSealActive === 'function') ? mpdSealActive() : false;
  const surfaceSealed = effectiveSurfaceSealActive();

  // Calculate influx rate based on mode
  let influxRate_gpm = 0;
  const BHP_psi = pressureAtDepth(formationFluidDepth_m);
  const bhpNoSBP_psi = pressureAtDepth_noSBP_withCML(formationFluidDepth_m);
  let effectiveBhp_psi = BHP_psi;

  if (surfaceSealed) {
    const neededPsi = Math.max(0, porePressure_psi - bhpNoSBP_psi);
    autoKickBalancePsi = isFinite(autoKickBalancePsi) ? autoKickBalancePsi : 0;
    const alpha = 0.25;
    autoKickBalancePsi = (1 - alpha) * autoKickBalancePsi + alpha * neededPsi;
    effectiveBhp_psi = Math.max(BHP_psi, bhpNoSBP_psi + autoKickBalancePsi);
  } else {
    // Let the auto-balance pressure decay smoothly when the seal opens to
    // avoid abrupt drops on the pressure plot while still clearing the
    // stored value quickly enough once the well is vented.
    autoKickBalancePsi *= 0.7;
  }

  if (kickMode === 'MANUAL') {
    influxRate_gpm = formationFluidRate_gpm;
  } else if (kickMode === 'PRESSURE_DRIVEN') {
    const deltaP = Math.max(0, porePressure_psi - effectiveBhp_psi);
    if (deltaP < 0.1) {
      influxRate_gpm = 0; // Treat near-equilibrium as no new influx
    } else {
      influxRate_gpm = productivityIndex_gpm_psi * deltaP;
    }

    // If the applied auto pressure brings BHP to equilibrium, stop inflow
    if (surfaceSealed && effectiveBhp_psi >= porePressure_psi - 0.05) {
      influxRate_gpm = 0;
    }
  }

  if (surfaceSealed) {
    const availableDraw = Math.max(0, porePressure_psi - BHP_psi);
    if (availableDraw <= 0) {
      influxRate_gpm = 0;
    } else if (kickMode === 'MANUAL') {
      const maxRate = productivityIndex_gpm_psi * availableDraw;
      influxRate_gpm = Math.min(influxRate_gpm, maxRate);
    }
  } else if (!mpdSealed) {
    autoKickBalancePsi = 0;
  }

  // Store current influx rate for flow routing (even if zero)
  const influx_m3s = influxRate_gpm / 15850.323;
  current_influx_m3s = influx_m3s + expansion_m3s;
  if (typeof window !== 'undefined') {
    window.__influxRate_gpm = influxRate_gpm;
    window.__autoKickBalancePsi = autoKickBalancePsi;
  }

  if (influxRate_gpm <= 0) {
    // Even with no influx, migrate existing kick fluids and propagate expansion effects
    migrateKickFluids(dt_s);
    return;
  }

  // Add formation fluid influx at specified depth
  const influx_volume_m3 = influx_m3s * dt_s;

  // Determine which cell the influx enters and add to appropriate phase array
  const densityForMix = fluidProps.density_ppg || MW_DS;

  if (formationFluidDepth_m >= BOP_DEPTH) {
    // Below BOP
    const cellIndex = Math.floor((formationFluidDepth_m - BOP_DEPTH) / CELL_M);
    let leftover = distributeFormationFluidVolume('below', cellIndex, influx_volume_m3, densityForMix);
    if (leftover > 1e-9 && !BOP_CLOSED && N_ABV > 0) {
      leftover = distributeFormationFluidVolume('above', N_ABV - 1, leftover, densityForMix);
    }
    if (leftover > 1e-6) {
      formationFluidOverflow_m3 += leftover;
    }
  } else {
    // Above BOP (riser)
    const cellIndex = Math.floor(formationFluidDepth_m / CELL_M);
    let leftover = distributeFormationFluidVolume('above', cellIndex, influx_volume_m3, densityForMix);
    if (leftover > 1e-6) {
      formationFluidOverflow_m3 += leftover;
    }
  }

  // Migrate kick fluids upward (independent of flow)
  migrateKickFluids(dt_s);

  // Black oil dissociation check
  if (formationFluidType === 'BLACKOIL' && fluidProps.bubblePoint_psi) {
    for (let i = 0; i < N_BELOW; i++) {
      const oilAmt = oilPhaseFrom_below[i] || 0;
      if (oilAmt > 0.001) {
        const depth = BOP_DEPTH + i * CELL_M;
        const P = pressureAtDepth(depth);

        // If pressure drops below bubble point, oil releases gas
        if (P < fluidProps.bubblePoint_psi) {
          const gasReleased = oilAmt * 0.2; // 20% gas release (simplified)
          gasPhaseFrom_below[i] = (gasPhaseFrom_below[i] || 0) + gasReleased;
          oilPhaseFrom_below[i] = Math.max(0, oilAmt - gasReleased);
        }
      }
    }
  }

  // Update total volume
  formationFluidVolume_bbl += (influxRate_gpm * dt_s) / 42; // Convert to barrels

  if (typeof window !== 'undefined') {
    window.__influxInventory_bbl = currentFormationFluidInventory_bbl();
  }

  // Update front position: shallowest depth containing any formation fluid
  const FRACTION_THRESHOLD = 0.01;
  let frontDepth_m = null;

  // Check riser column first (closest to surface)
  if (Array.isArray(gasPhaseFrom_above) && gasPhaseFrom_above.length) {
    for (let i = 0; i < gasPhaseFrom_above.length; i++) {
      const total = (gasPhaseFrom_above[i] || 0) + (oilPhaseFrom_above[i] || 0) + (waterPhaseFrom_above[i] || 0);
      if (total > FRACTION_THRESHOLD) {
        frontDepth_m = i * CELL_M;
        break;
      }
    }
  }

  if (frontDepth_m == null && Array.isArray(gasPhaseFrom_below) && gasPhaseFrom_below.length) {
    for (let i = 0; i < gasPhaseFrom_below.length; i++) {
      const total = (gasPhaseFrom_below[i] || 0) + (oilPhaseFrom_below[i] || 0) + (waterPhaseFrom_below[i] || 0);
      if (total > FRACTION_THRESHOLD) {
        frontDepth_m = BOP_DEPTH + i * CELL_M;
        break;
      }
    }
  }

  if (frontDepth_m != null) {
    formationFluidFront_m = frontDepth_m;
  } else {
    formationFluidFront_m = TD_DEPTH;
  }
}

// REPLACE stepAdvection() completely:

// REPLACE stepAdvection() completely:
function stepAdvection(){
  // --- accumulator guards (persist across frames) ---
  if (typeof window.accDS    !== 'number') window.accDS    = 0;
  if (typeof window.accBo    !== 'number') window.accBo    = 0;
  if (typeof window.accBelow !== 'number') window.accBelow = 0;
  if (typeof window.accDSup  !== 'number') window.accDSup  = 0; // <-- was undefined before
  if (typeof window.accAbove !== 'number') window.accAbove = 0;
  if (typeof window.accTF    !== 'number') window.accTF    = 0;
  if (typeof window.accUpShallow !== 'number') window.accUpShallow = 0;

  const dt   = frameSeconds();
  const vref = V_REF();
  const FLOW_THRESHOLD = 1e-8;

  // Routed internal section flows (magnitudes, in m^3/s) from the router:
  const qUp_m3s   = (typeof __qAnnUp_m3s   === 'number') ? __qAnnUp_m3s   : 0;  // upward above loss zone
  const qDown_m3s = (typeof __qAnnDown_m3s === 'number') ? __qAnnDown_m3s : 0;  // downward toward loss zone

  window.__bopChokeUpMW_ppg = null;
  window.__bopKillUpMW_ppg = null;

  // Grids & geometry helpers you already have:
  const A_riser = area_annulus(riser_ID_m,   ds_OD_m);
  const A_csg   = area_annulus(casing_ID_m,  ds_OD_m);
  const A_oh    = area_annulus(openhole_ODm, ds_OD_m);

  // Derived "below-BOP" average area (used for below-zone advection speed)
  const L_csg = Math.max(SHOE_DEPTH - BOP_DEPTH, 0);
  const L_oh  = Math.max(TD_DEPTH   - SHOE_DEPTH, 0);
  const A_below = (L_csg + L_oh) > 1e-9
    ? (L_csg * A_csg + L_oh * A_oh) / (L_csg + L_oh)
    : Math.max(A_csg, A_oh, 1e-9);

  // ===============================
  // 1) DRILLSTRING PIPE (down only)
  // ===============================
  {
    const qDS_m3s = Math.max(0, ((Q_DS || 0) / 15850.323));
    if (qDS_m3s > FLOW_THRESHOLD) {
      const A_ds = Math.PI * ds_ID_m * ds_ID_m / 4;
      const v_ds = qDS_m3s / Math.max(A_ds, 1e-12);
      const dsStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_ds / vref);

      accDS += dsStep_m;
      while (accDS >= CELL_M){
        dsGrid.pop();
        dsGrid.unshift(MW_DS);
        accDS -= CELL_M;
      }
    }
  }
  const dsEffluentMW = dsGrid[dsGrid.length - 1] || MW_DS;

  // ===============================
  // 2) BOOSTER PIPE (TOP ‚Üí DOWN)
  // ===============================
  let boosterEffluentMW = MW_BO;  // Track what exits booster pipe at BOP
  {
    const qBO_m3s = Math.max(0, ((Q_BO || 0) / 15850.323));
    if (qBO_m3s > FLOW_THRESHOLD) {
      const A_bo = Math.PI * booster_ID_m * booster_ID_m / 4;
      const v_bo = qBO_m3s / Math.max(A_bo, 1e-12);
      const boStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_bo / vref);

      accBo += boStep_m;
      while (accBo >= CELL_M){
        // Fluid enters at TOP (surface/inlet), exits at BOTTOM (BOP)
        boosterEffluentMW = boosterGrid.pop(); // Remove from bottom (exits at BOP)
        boosterGrid.unshift(MW_BO);  // Add new fluid at top (surface inlet)
        accBo -= CELL_M;
      }
    }
    // Always use bottom of grid as current effluent
    boosterEffluentMW = boosterGrid[boosterGrid.length - 1] || MW_BO;
  }
  const boosterMW = boosterEffluentMW;  // Compatibility

  // ===============================
  // 3) EXTRACT LOSSES FROM GRIDS
  // ===============================
  if (LOSSES_ON){
    for (const z of lossZones){ 
      extractLossFluidFromGrid(z, dt); 
    }
  }

  // ===============================================
  // 4) ANNULUS BELOW THE BOP: DOWN + UP PROCESSING
  // ===============================================
  // (A) DOWNWARD advection (booster/topfill routed toward zone)
  const downReachDepth_m = Math.max(BOP_DEPTH, window.__qAnnDown_reachDepth_m || BOP_DEPTH);
  const downCells = Math.max(0, Math.floor((downReachDepth_m - BOP_DEPTH) / CELL_M) + 1);
  const downMixMW = (typeof window.__qAnnDown_mw_ppg === 'number') ? window.__qAnnDown_mw_ppg : boosterEffluentMW;

  if (qDown_m3s > FLOW_THRESHOLD && downCells > 0) {
    const v_down = qDown_m3s / Math.max(A_below, 1e-12);
    const step_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_down / vref);

    accBelow += step_m;
    const limit = Math.max(1, Math.min(annBelowGrid.length, downCells));
    while (accBelow >= CELL_M){
      // Shift DOWN only through the portion that actually sees downflow
      for (let i = limit - 1; i > 0; i--) {
        annBelowGrid[i] = annBelowGrid[i - 1];
      }
      annBelowGrid[0] = downMixMW;

      for (let i = limit - 1; i > 0; i--) {
        gasPhaseFrom_below[i] = gasPhaseFrom_below[i - 1];
        oilPhaseFrom_below[i] = oilPhaseFrom_below[i - 1];
        waterPhaseFrom_below[i] = waterPhaseFrom_below[i - 1];
      }
      gasPhaseFrom_below[0] = 0;
      oilPhaseFrom_below[0] = 0;
      waterPhaseFrom_below[0] = 0;

      accBelow -= CELL_M;
    }
  } else {
    accBelow = 0;
  }

  const qBitFlux_m3s = Math.max(0, window.__dsFlux_m3s || (((Q_DS || 0) / 15850.323) + (typeof current_influx_m3s === 'number' ? current_influx_m3s : 0)));
  const dsStopDepth_m = Math.max(BOP_DEPTH, window.__dsUpflowStopDepth_m || BOP_DEPTH);
  const deepStartIdx = Math.min(
    Math.max(0, Math.floor((dsStopDepth_m - BOP_DEPTH) / CELL_M)),
    annBelowGrid.length - 1
  );

  if (qBitFlux_m3s > FLOW_THRESHOLD) {
    const v_up_bit = qBitFlux_m3s / Math.max(A_below, 1e-12);
    const upStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_up_bit / vref);

    accDSup += upStep_m;
    while (accDSup >= CELL_M){
      for (let i = deepStartIdx; i < annBelowGrid.length - 1; i++) {
        annBelowGrid[i] = annBelowGrid[i + 1];
      }
      annBelowGrid[annBelowGrid.length - 1] = dsEffluentMW;

      for (let i = deepStartIdx; i < gasPhaseFrom_below.length - 1; i++) {
        gasPhaseFrom_below[i] = gasPhaseFrom_below[i + 1];
        oilPhaseFrom_below[i] = oilPhaseFrom_below[i + 1];
        waterPhaseFrom_below[i] = waterPhaseFrom_below[i + 1];
      }
      gasPhaseFrom_below[gasPhaseFrom_below.length - 1] = 0;
      oilPhaseFrom_below[oilPhaseFrom_below.length - 1] = 0;
      waterPhaseFrom_below[waterPhaseFrom_below.length - 1] = 0;

      accDSup -= CELL_M;
    }
  } else {
    accDSup = 0;
  }

  const qUpResidual_m3s = (deepStartIdx > 0) ? Math.max(0, qUp_m3s) : 0;
  if (qUpResidual_m3s > FLOW_THRESHOLD && deepStartIdx > 0) {
    const v_up_resid = qUpResidual_m3s / Math.max(A_below, 1e-12);
    const upStepRes = TIME_ACCEL * BASE_M_PER_FRAME * (v_up_resid / vref);

    window.accUpShallow += upStepRes;
    while (window.accUpShallow >= CELL_M) {
      for (let i = 0; i < deepStartIdx - 1; i++) {
        annBelowGrid[i] = annBelowGrid[i + 1];
      }
      const insertIdx = deepStartIdx - 1;
      if (insertIdx >= 0) {
        annBelowGrid[insertIdx] = annBelowGrid[deepStartIdx];
      }

      for (let i = 0; i < deepStartIdx - 1; i++) {
        gasPhaseFrom_below[i] = gasPhaseFrom_below[i + 1];
        oilPhaseFrom_below[i] = oilPhaseFrom_below[i + 1];
        waterPhaseFrom_below[i] = waterPhaseFrom_below[i + 1];
      }
      if (insertIdx >= 0) {
        gasPhaseFrom_below[insertIdx] = gasPhaseFrom_below[deepStartIdx];
        oilPhaseFrom_below[insertIdx] = oilPhaseFrom_below[deepStartIdx];
        waterPhaseFrom_below[insertIdx] = waterPhaseFrom_below[deepStartIdx];
      }

      window.accUpShallow -= CELL_M;
    }
  } else {
    window.accUpShallow = 0;
  }
  // If qUp_m3s ~ 0, leave annBelowGrid as-is: column below remains static except where DOWN flow was applied.

  // =========================================================
  // 5) RISER (ABOVE BOP): ADVECTION AND MIXING
  // =========================================================

  // ‚úÖ FIXED: Calculate choke/kill DOWN flows OUTSIDE the upflow block
  let qChoke_down = 0, qKill_down = 0;
  let chokeEffluentMW = MW_CHOKE, killEffluentMW = MW_KILL;

  if (!BOP_CLOSED) {
    // When BOP is open, choke/kill DOWN flows mix into riser at BOP depth
    if (CHOKE_LINE_OPEN && CHOKE_DIRECTION === "DOWN") {
      qChoke_down = (Q_CHOKE || 0) / 15850.323;
      chokeEffluentMW = chokeGrid[chokeGrid.length - 1] || MW_CHOKE; // Bottom of grid = BOP depth
    }
    if (KILL_LINE_OPEN && KILL_DIRECTION === "DOWN") {
      qKill_down = (Q_KILL || 0) / 15850.323;
      killEffluentMW = killGrid[killGrid.length - 1] || MW_KILL; // Bottom of grid = BOP depth
    }
  }

  const qAnnulusToRiser = Math.max(0, window.__qBOP_annulusToRiser_m3s || 0);
  const qAnnulusTotalUp = Math.max(0, window.__qBOP_annulusUpTotal_m3s || qAnnulusToRiser);
  const qBO_up_total = Math.max(0, window.__qBOP_boosterUp_m3s || 0);
  const qChokeMixUp_total = Math.max(0, window.__qBOP_chokeDownUp_m3s || 0);
  const qKillMixUp_total = Math.max(0, window.__qBOP_killDownUp_m3s || 0);
  const qBopTotalUp = Math.max(0, window.__qBOP_totalUp_m3s ||
    (qAnnulusTotalUp + qBO_up_total + qChokeMixUp_total + qKillMixUp_total));

  const qBoosterIntoRiser = Math.max(0,
    window.__qBOP_boosterIntoRiser_m3s ?? (BOP_CLOSED ? 0 : qBO_up_total));
  const qChokeMixIntoRiser = Math.max(0,
    window.__qBOP_chokeDownIntoRiser_m3s ?? (BOP_CLOSED ? 0 : qChokeMixUp_total));
  const qKillMixIntoRiser = Math.max(0,
    window.__qBOP_killDownIntoRiser_m3s ?? (BOP_CLOSED ? 0 : qKillMixUp_total));
  const qFromAnnBelow = qAnnulusToRiser;

  const annulusTopMW = annBelowGrid[0] || dsEffluentMW;
  const annulusTopEffMW = effectiveCellDensity_ppg(annulusTopMW, 0, false);
  let bopNodeMW = annulusTopEffMW;
  if (qBopTotalUp > FLOW_THRESHOLD) {
    let bopMix = 0;
    if (qAnnulusTotalUp > FLOW_THRESHOLD) bopMix += qAnnulusTotalUp * annulusTopEffMW;
    if (qBO_up_total > FLOW_THRESHOLD) bopMix += qBO_up_total * boosterEffluentMW;
    if (qChokeMixUp_total > FLOW_THRESHOLD) bopMix += qChokeMixUp_total * chokeEffluentMW;
    if (qKillMixUp_total > FLOW_THRESHOLD) bopMix += qKillMixUp_total * killEffluentMW;
    bopNodeMW = bopMix / qBopTotalUp;
  }
  window.__bopNodeMW_ppg = bopNodeMW;

  // Total flow entering riser at BOP depth
  const qTotalIntoRiser = qFromAnnBelow + qBoosterIntoRiser +
    qChokeMixIntoRiser + qKillMixIntoRiser;

  if (qTotalIntoRiser > FLOW_THRESHOLD) {
    const v_above = qTotalIntoRiser / Math.max(A_riser, 1e-12);
    const aboveStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_above / vref);

    accAbove += aboveStep_m;
    while (accAbove >= CELL_M){
      // Remove from surface, add mixture at BOP (from annulus below + booster + choke/kill going down)
      annAboveGrid.shift();

      // ‚úÖ FIXED: Only include flows that are actually non-zero in mixing
      // Build flow-weighted average (compound average)
      let mixMW = 0;
      let qTotal = 0;

      if (qFromAnnBelow > FLOW_THRESHOLD) {
        mixMW += qFromAnnBelow * annulusTopEffMW;
        qTotal += qFromAnnBelow;
      }

      if (qBoosterIntoRiser > FLOW_THRESHOLD) {
        mixMW += qBoosterIntoRiser * boosterEffluentMW;
        qTotal += qBoosterIntoRiser;
      }

      if (qChokeMixIntoRiser > FLOW_THRESHOLD) {
        mixMW += qChokeMixIntoRiser * chokeEffluentMW;
        qTotal += qChokeMixIntoRiser;
      }

      if (qKillMixIntoRiser > FLOW_THRESHOLD) {
        mixMW += qKillMixIntoRiser * killEffluentMW;
        qTotal += qKillMixIntoRiser;
      }

      if (qTotal > FLOW_THRESHOLD) {
        mixMW = mixMW / qTotal;  // Flow-weighted average
      } else {
        mixMW = MW_DS;  // Fallback
      }

      window.__bopRiserMW_ppg = mixMW;

      annAboveGrid.push(mixMW);

      // Advect formation fluids UP into riser
      // Remove from surface
      gasPhaseFrom_above.shift();
      oilPhaseFrom_above.shift();
      waterPhaseFrom_above.shift();

      // Add formation fluids from below-BOP entering at BOP depth
      // Only the fraction coming from annulus below carries formation fluids
      // Booster, choke, and kill are clean mud, so dilute the formation fluids by flow rate ratio
      const dilutionFactor = clamp(qFromAnnBelow / Math.max(qTotalIntoRiser, 1e-12), 0, 1);
      gasPhaseFrom_above.push((gasPhaseFrom_below[0] || 0) * dilutionFactor);
      oilPhaseFrom_above.push((oilPhaseFrom_below[0] || 0) * dilutionFactor);
      waterPhaseFrom_above.push((waterPhaseFrom_below[0] || 0) * dilutionFactor);

      const remainFrac = 1 - dilutionFactor;
      gasPhaseFrom_below[0] = (gasPhaseFrom_below[0] || 0) * remainFrac;
      oilPhaseFrom_below[0] = (oilPhaseFrom_below[0] || 0) * remainFrac;
      waterPhaseFrom_below[0] = (waterPhaseFrom_below[0] || 0) * remainFrac;

      accAbove -= CELL_M;
    }

    if (annAboveGrid.length){
      const k = annAboveGrid.length - 1;

      // ‚úÖ FIXED: Same flow-weighted mixing for partial cell
      let mixMW = 0;
      let qTotal = 0;

      if (qFromAnnBelow > FLOW_THRESHOLD) {
        mixMW += qFromAnnBelow * annulusTopEffMW;
        qTotal += qFromAnnBelow;
      }

        if (qBoosterIntoRiser > FLOW_THRESHOLD) {
          mixMW += qBoosterIntoRiser * boosterEffluentMW;
          qTotal += qBoosterIntoRiser;
        }

        if (qChokeMixIntoRiser > FLOW_THRESHOLD) {
          mixMW += qChokeMixIntoRiser * chokeEffluentMW;
          qTotal += qChokeMixIntoRiser;
        }

        if (qKillMixIntoRiser > FLOW_THRESHOLD) {
          mixMW += qKillMixIntoRiser * killEffluentMW;
          qTotal += qKillMixIntoRiser;
        }

      if (qTotal > FLOW_THRESHOLD) {
        mixMW = mixMW / qTotal;
      } else {
        mixMW = MW_DS;
      }

      window.__bopRiserMW_ppg = mixMW;

      annAboveGrid[k] = (1 - accAbove/CELL_M) * annAboveGrid[k] + (accAbove/CELL_M) * mixMW;
    }
  } else {
    window.__bopRiserMW_ppg = null;
  }
  // If qTotalIntoRiser ~ 0, leave annAboveGrid unchanged: riser column stays static.

  // =========================================================
  // 6) TOP FILL at actual fluid surface (keep your logic)
  // =========================================================
  (function topFillBlock(){
    const flowProfile = computeFlowProfile(); // reuse your FO/topfill inputs if needed elsewhere
    if ((flowProfile.topfill || 0) > FLOW_THRESHOLD) {
      const actualTop = annulusTopDepthGlobal(); // Actual wet/dry interface

      if (actualTop > 0.5) { // Only if there's headspace
        if (actualTop <= BOP_DEPTH) {
          // Fill riser (annAboveGrid)
          const v_tf = flowProfile.topfill / Math.max(A_riser, 1e-12);
          const tfStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_tf / vref);
          accTF += tfStep_m;
          while (accTF >= CELL_M){
            const surfaceCell = Math.floor(actualTop / CELL_M);
            if (surfaceCell < annAboveGrid.length) {
              for (let i = annAboveGrid.length - 1; i > surfaceCell; i--) {
                annAboveGrid[i] = annAboveGrid[i - 1];
              }
              annAboveGrid[surfaceCell] = MW_TOPFILL;
            }
            accTF -= CELL_M;
          }
        } else {
          // Fill below BOP (annBelowGrid)
          const v_tf = flowProfile.topfill / Math.max(A_below, 1e-12);
          const tfStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_tf / vref);
          accTF += tfStep_m;
          while (accTF >= CELL_M){
            const surfaceCell = Math.floor((actualTop - BOP_DEPTH) / CELL_M);
            if (surfaceCell >= 0 && surfaceCell < annBelowGrid.length) {
              for (let i = annBelowGrid.length - 1; i > surfaceCell; i--) {
                annBelowGrid[i] = annBelowGrid[i - 1];
              }
              annBelowGrid[surfaceCell] = MW_TOPFILL;
            }
            accTF -= CELL_M;
          }
        }
      }
    }
  })();

  // ===============================
  // 7) CML PIPE (unchanged)
  // ===============================
  if (CML_ON && Q_CML > 0){
    const qCML = Q_CML / 15850.323;
    const cmlStep_m = BASE_M_PER_FRAME * (qCML / (Q_REF/15850.323));
    accCML = (accCML || 0) + cmlStep_m;
    const iPump = clamp(Math.floor(CML_DEPTH / CELL_M), 0, N_ABV-1);
    const srcMW = annAboveGrid[iPump] || MW_DS;
    while (accCML >= CELL_M){
      cmlPipeGrid.shift();
      cmlPipeGrid.push(srcMW);
      accCML -= CELL_M;
    }
  }

  // ===============================
  // 8) CHOKE LINE ADVECTION (BOP to Surface)
  // ===============================
  // ‚úÖ NOW WORKS WITH BOP OPEN OR CLOSED
  if (Q_CHOKE > 0 && CHOKE_LINE_OPEN) {
    let qChoke_m3s = Q_CHOKE / 15850.323;
    if (CHOKE_DIRECTION === "UP" && typeof window.__qChokeUp_m3s === 'number') {
      qChoke_m3s = Math.max(0, window.__qChokeUp_m3s);
    }
    const A_choke = Math.PI * CHOKE_LINE_ID_m * CHOKE_LINE_ID_m / 4;
    const v_choke = qChoke_m3s / Math.max(A_choke, 1e-12);
    const chokeStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_choke / vref);

    if (CHOKE_DIRECTION === "DOWN") {
      // Fluid flows DOWN: Surface ‚Üí BOP ‚Üí Below-BOP annulus (or riser if BOP open)
      // Grid: chokeGrid[0] = surface (inlet), chokeGrid[N_ABV-1] = BOP (outlet)
      accChoke += chokeStep_m;
      while (accChoke >= CELL_M) {
        // Shift DOWN (surface to BOP)
        for (let i = chokeGrid.length - 1; i > 0; i--) {
          chokeGrid[i] = chokeGrid[i - 1];
        }
        chokeGrid[0] = MW_CHOKE; // Fresh fluid enters at surface
        accChoke -= CELL_M;
      }
    } else if (CHOKE_DIRECTION === "UP") {
      // Fluid flows UP: Below-BOP annulus ‚Üí BOP ‚Üí Surface
      // Grid: chokeGrid[N_ABV-1] = BOP (inlet), chokeGrid[0] = surface (outlet)
      accChoke += chokeStep_m;
      while (accChoke >= CELL_M) {
        // Shift UP (BOP to surface)
        for (let i = 0; i < chokeGrid.length - 1; i++) {
          chokeGrid[i] = chokeGrid[i + 1];
        }
        // Fluid entering from BOP node (mixture of annulus + booster + choke/kill down)
        const sourceMW = (typeof window.__bopNodeMW_ppg === 'number'
          ? window.__bopNodeMW_ppg
          : (annBelowGrid[0] || MW_DS));
        const effMW = effectiveCellDensity_ppg(sourceMW, 0, false);
        chokeGrid[chokeGrid.length - 1] = effMW;
        accChoke -= CELL_M;
      }
      window.__bopChokeUpMW_ppg = (qChoke_m3s > FLOW_THRESHOLD) ? (window.__bopNodeMW_ppg || (annBelowGrid[0] || MW_DS)) : null;
    }
  }

  // ===============================
  // 9) KILL LINE ADVECTION (BOP to Surface)
  // ===============================
  // ‚úÖ NOW WORKS WITH BOP OPEN OR CLOSED
  if (Q_KILL > 0 && KILL_LINE_OPEN) {
    let qKill_m3s = Q_KILL / 15850.323;
    if (KILL_DIRECTION === "UP" && typeof window.__qKillUp_m3s === 'number') {
      qKill_m3s = Math.max(0, window.__qKillUp_m3s);
    }
    const A_kill = Math.PI * KILL_LINE_ID_m * KILL_LINE_ID_m / 4;
    const v_kill = qKill_m3s / Math.max(A_kill, 1e-12);
    const killStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_kill / vref);

    if (KILL_DIRECTION === "DOWN") {
      // Fluid flows DOWN: Surface ‚Üí BOP ‚Üí Below-BOP annulus (or riser if BOP open)
      // Grid: killGrid[0] = surface (inlet), killGrid[N_ABV-1] = BOP (outlet)
      accKill += killStep_m;
      while (accKill >= CELL_M) {
        // Shift DOWN (surface to BOP)
        for (let i = killGrid.length - 1; i > 0; i--) {
          killGrid[i] = killGrid[i - 1];
        }
        killGrid[0] = MW_KILL; // Fresh fluid enters at surface
        accKill -= CELL_M;
      }
    } else if (KILL_DIRECTION === "UP") {
      // Fluid flows UP: Below-BOP annulus ‚Üí BOP ‚Üí Surface
      // Grid: killGrid[N_ABV-1] = BOP (inlet), killGrid[0] = surface (outlet)
      accKill += killStep_m;
      while (accKill >= CELL_M) {
        // Shift UP (BOP to surface)
        for (let i = 0; i < killGrid.length - 1; i++) {
          killGrid[i] = killGrid[i + 1];
        }
        // Fluid entering from BOP node mixture
        const sourceMW = (typeof window.__bopNodeMW_ppg === 'number'
          ? window.__bopNodeMW_ppg
          : (annBelowGrid[0] || MW_DS));
        const effMW = effectiveCellDensity_ppg(sourceMW, 0, false);
        killGrid[killGrid.length - 1] = effMW;
        accKill -= CELL_M;
      }
      window.__bopKillUpMW_ppg = (qKill_m3s > FLOW_THRESHOLD) ? (window.__bopNodeMW_ppg || (annBelowGrid[0] || MW_DS)) : null;
    }
  }

  // ===============================
  // 10) GAS EXPANSION (if enabled)
  // ===============================
  // Apply gas expansion to all cells after advection
  // Gas expands as it migrates upward to lower pressure zones
  applyGasExpansion(dt);
}



function gravityDensitySwap() {
  if (!EH.GRAV || !EH.GRAV.on) return;
  
  const dt = frameSeconds();
  const swapProb = GRAVITY_SWAP_RATE * dt; // Probability per frame
  
  if (Math.random() > swapProb) return; // Only swap occasionally
  
  // Function to swap adjacent cells if unstable
  const swapIfUnstable = (grid, i) => {
    if (i >= grid.length - 1) return false;
    
    const rhoTop = grid[i] * PPG_TO_KGM3;
    const rhoBot = grid[i + 1] * PPG_TO_KGM3;
    
    // Unstable if heavier on top (Rayleigh-Taylor instability)
    if (rhoTop > rhoBot + 5) { // 5 kg/m¬≥ threshold
      // Swap with mixing (not instant)
      const mixFactor = 0.3; // Partial swap for realism
      const temp = grid[i];
      grid[i] = (1 - mixFactor) * grid[i] + mixFactor * grid[i + 1];
      grid[i + 1] = (1 - mixFactor) * grid[i + 1] + mixFactor * temp;
      return true;
    }
    return false;
  };
  
  // Check all grids for instability
  let swapped = false;
  
  // Riser
  for (let i = 0; i < annAboveGrid.length - 1; i++) {
    if (swapIfUnstable(annAboveGrid, i)) swapped = true;
  }
  
  // Below BOP
  for (let i = 0; i < annBelowGrid.length - 1; i++) {
    if (swapIfUnstable(annBelowGrid, i)) swapped = true;
  }
  
  // Note: Only swap in static regions (where flow velocity is low)
  // You could add a velocity check here if needed
}

// ========================= DENSITY / FLOWS =============================
function annulusAvgPPG(){
  // Calculate average annulus density including kick fluids
  let sum = 0;
  let count = 0;

  // Above BOP cells with kick mixing
  for (let i = 0; i < annAboveGrid.length; i++) {
    const mudWeight = annAboveGrid[i] || MW_DS;
    const effectiveDensity = effectiveCellDensity_ppg(mudWeight, i, true);
    sum += effectiveDensity;
    count++;
  }

  // Below BOP cells with kick mixing
  for (let i = 0; i < annBelowGrid.length; i++) {
    const mudWeight = annBelowGrid[i] || MW_DS;
    const effectiveDensity = effectiveCellDensity_ppg(mudWeight, i, false);
    sum += effectiveDensity;
    count++;
  }

  return count > 0 ? sum / count : MW_DS;
}

function annulusBelowAvgPPG(){
  if (!Array.isArray(annBelowGrid) || annBelowGrid.length === 0) {
    return MW_DS;
  }
  let sum = 0;
  for (let i = 0; i < annBelowGrid.length; i++) {
    const mudWeight = annBelowGrid[i] || MW_DS;
    sum += effectiveCellDensity_ppg(mudWeight, i, false);
  }
  return sum / annBelowGrid.length;
}

function annulusConnectedAvgPPG(){
  return BOP_CLOSED ? annulusBelowAvgPPG() : annulusAvgPPG();
}

function rhoDynamic(){ return annulusAvgPPG() * PPG_TO_KGM3; }
function rho_bo(){ return boosterAvgPPG() * PPG_TO_KGM3; }
function dsAvgPPG(){ return average(dsGrid) || MW_DS; }
function boosterAvgPPG(){ return average(boosterGrid) || MW_BO; }
function flows_m3s(){
  const qDS_m3s = (Q_DS || 0) / 15850.323; // gpm ‚Üí m¬≥/s
  const qBO_m3s = (Q_BO || 0) / 15850.323;
  return { qDS: qDS_m3s, qBO: qBO_m3s, qAnnBelow: qDS_m3s, qAnnAbove: qDS_m3s + qBO_m3s };
}
// ======================= SECTION-SPECIFIC dP/dL ========================
// Add this function near getRheoForCalc (around line 820)
function publishRheoToGlobals(){
  const { K, n, tauY } = getRheoForCalc();

  if (ACTIVE_RHEO_MODEL === "Bingham"){
    window.TAUY_Pa = tauY;
    window.MUP_PaS = K;
    window.K_PaSn = K;
    window.N_dim = 1.0;
  } else if (ACTIVE_RHEO_MODEL === "PowerLaw"){
    window.TAUY_Pa = 0;
    window.MUP_PaS = 0.001; // nominal for PL
    window.K_PaSn = K;
    window.N_dim = n;
  } else { // HB
    window.TAUY_Pa = tauY;
    window.MUP_PaS = K; // approximate
    window.K_PaSn = K;
    window.N_dim = n;
  }
}

function dPperM_riserAnnulus(Q) {
  const base = getRheoForCalc();
  const z0 = 0, z1 = BOP_DEPTH, dz = 200;
  let dP_total = 0;
  for (let z = z0; z < z1; z += dz) {
    const rho0 = rhoDynamic();
    const adj = applyPressureOnly(z, rho0, base.K, base.n, base.tauY);
    const dpdl = dP_per_m_annulus_withRPM(Q, adj.rho, riser_ID_m, ds_OD_m, adj.K, adj.n, adj.tauY, RPM);
    dP_total += dpdl * Math.min(dz, z1 - z);
  }
  return dP_total / (z1 - z0);
}
function dPperM_casingAnnulus(Q) {
  const base = getRheoForCalc();
  const z0 = BOP_DEPTH, z1 = SHOE_DEPTH, dz = 200;
  let dP_total = 0;
  for (let z = z0; z < z1; z += dz) {
    const rho0 = rhoDynamic();
    const adj = applyPressureOnly(z, rho0, base.K, base.n, base.tauY);
    const dpdl = dP_per_m_annulus_withRPM(Q, adj.rho, casing_ID_m, ds_OD_m, adj.K, adj.n, adj.tauY, RPM);
    dP_total += dpdl * Math.min(dz, z1 - z);
  }
  return dP_total / (z1 - z0);
}
function dPperM_openholeAnnulus(Q) {
  const base = getRheoForCalc();
  const z0 = SHOE_DEPTH, z1 = TD_DEPTH, dz = 200;
  let dP_total = 0;
  for (let z = z0; z < z1; z += dz) {
    const rho0 = rhoDynamic();
    const adj = applyPressureOnly(z, rho0, base.K, base.n, base.tauY);
    const dpdl = dP_per_m_annulus_withRPM(Q, adj.rho, openhole_ODm, ds_OD_m, adj.K, adj.n, adj.tauY, RPM);
    dP_total += dpdl * Math.min(dz, z1 - z);
  }
  return dP_total / (z1 - z0);
}
function dPperM_drillstring(Q) {
  const base = getRheoForCalc();
  const z0 = 0, z1 = TD_DEPTH, dz = 200;
  let dP_total = 0;
  for (let z = z0; z < z1; z += dz) {
    const rho0 = dsAvgPPG() * PPG_TO_KGM3;
    const adj = applyPressureOnly(z, rho0, base.K, base.n, base.tauY);
    const dpdl = dP_per_m_pipe_withRPM(Q, adj.rho, ds_ID_m, adj.K, adj.n, adj.tauY, RPM);
    dP_total += dpdl * Math.min(dz, z1 - z);
  }
  return dP_total / (z1 - z0);
}
function dPperM_booster(Q) {
  const base = getRheoForCalc();
  const z0 = 0, z1 = BOP_DEPTH, dz = 200;
  let dP_total = 0;
  for (let z = z0; z < z1; z += dz) {
    const rho0 = rho_bo();
    const adj = applyPressureOnly(z, rho0, base.K, base.n, base.tauY);
    const dpdl = dP_per_m_pipe_withRPM(Q, adj.rho, booster_ID_m, adj.K, adj.n, adj.tauY, 0);
    dP_total += dpdl * Math.min(dz, z1 - z);
  }
  return dP_total / (z1 - z0);
}
// =========================== FRICTION SUMS (RHEOLOGY-AWARE) =============================

// NOTE: frictionPsi_withCML_rheo() is defined later at line ~1437
// (removed duplicate definition here to avoid conflicts)

// Legacy name kept for backward compatibility; prefer rheology-aware when available
function frictionPsi_withCML(depth_m){
  if (typeof frictionPsi_withCML_rheo === 'function') {
    return frictionPsi_withCML_rheo(depth_m);
  }
  // Fallback to original (hydraulics-mode) implementation if you want to keep it:
  // (Paste your original frictionPsi_withCML here if you still need the legacy path.)
  return 0;
}

// Kept as your public entry; now prefers rheology-aware path
function frictionPsiAtDepth(depth_m){
  return frictionPsi_withCML(depth_m);
}

// Compatibility shim for callers using frictionPsi(depth)
function frictionPsi(depth_m){
  if (typeof FRICTION_MODE !== 'undefined' && FRICTION_MODE === "hydraulics") {
    return frictionPsiAtDepth(depth_m);
  }
  // Simple K-factor fallback if someone forces non-hydraulics (kept from your code)
  const qTot = (window.Q_DS || 0) + (window.Q_BO || 0);
  const base = (typeof K_FAC === 'number' ? K_FAC : 0) * qTot * Math.max(depth_m, 0);
  return base; // no RPM boost here
}

// ====================== SMOOTH TRANSITION HELPERS =======================

// Global smoothstep function for smooth blending between two values
// Uses Hermite interpolation: 3t¬≤ - 2t¬≥
function smoothstep(edge0, edge1, x) {
  if (x <= edge0) return 0;
  if (x >= edge1) return 1;
  const t = (x - edge0) / (edge1 - edge0);
  return t * t * (3 - 2 * t);
}

// Linear interpolation between two values
function lerp(a, b, t) {
  return a * (1 - t) + b * t;
}

// Clamp value between min and max
function clamp(value, min, max) {
  return Math.max(min, Math.min(value, max));
}

// ====================== GAS EXPANSION CALCULATIONS =======================

// Pre-calculated Z-factor table for Real Gas mode
// Rows = Pr (reduced pressure = P/Pc), Columns = Tr (reduced temperature = T/Tc)
// Covers typical drilling ranges: Pr from 0.1 to 10, Tr from 1.0 to 2.5
const Z_FACTOR_TABLE = {
  Pr: [0.1, 0.5, 1.0, 1.5, 2.0, 3.0, 4.0, 5.0, 7.0, 10.0],
  Tr: [1.0, 1.1, 1.2, 1.3, 1.5, 1.7, 2.0, 2.5],
  // Z values [Pr_index][Tr_index]
  Z: [
    [0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 1.00, 1.00], // Pr = 0.1
    [0.93, 0.95, 0.96, 0.97, 0.98, 0.99, 0.99, 1.00], // Pr = 0.5
    [0.80, 0.88, 0.91, 0.93, 0.96, 0.97, 0.99, 1.00], // Pr = 1.0
    [0.68, 0.81, 0.87, 0.90, 0.94, 0.96, 0.98, 1.00], // Pr = 1.5
    [0.60, 0.75, 0.83, 0.88, 0.93, 0.95, 0.98, 1.00], // Pr = 2.0
    [0.53, 0.68, 0.79, 0.85, 0.91, 0.94, 0.97, 0.99], // Pr = 3.0
    [0.53, 0.66, 0.77, 0.84, 0.90, 0.94, 0.97, 0.99], // Pr = 4.0
    [0.57, 0.68, 0.78, 0.84, 0.91, 0.94, 0.97, 1.00], // Pr = 5.0
    [0.70, 0.77, 0.84, 0.88, 0.93, 0.96, 0.98, 1.00], // Pr = 7.0
    [0.88, 0.91, 0.94, 0.96, 0.98, 0.99, 1.00, 1.01], // Pr = 10.0
  ]
};

// Interpolate Z-factor from lookup table
function getZFactor(P_psi, T_R) {
  // Calculate reduced pressure and temperature
  const Pr = P_psi / GAS_Pc_psi;
  const Tr = T_R / GAS_Tc_R;

  // Clamp to table bounds
  const Pr_clamped = Math.max(Z_FACTOR_TABLE.Pr[0], Math.min(Pr, Z_FACTOR_TABLE.Pr[Z_FACTOR_TABLE.Pr.length - 1]));
  const Tr_clamped = Math.max(Z_FACTOR_TABLE.Tr[0], Math.min(Tr, Z_FACTOR_TABLE.Tr[Z_FACTOR_TABLE.Tr.length - 1]));

  // Find bounding indices for Pr
  let Pr_idx0 = 0, Pr_idx1 = 0;
  for (let i = 0; i < Z_FACTOR_TABLE.Pr.length - 1; i++) {
    if (Pr_clamped >= Z_FACTOR_TABLE.Pr[i] && Pr_clamped <= Z_FACTOR_TABLE.Pr[i + 1]) {
      Pr_idx0 = i;
      Pr_idx1 = i + 1;
      break;
    }
  }

  // Find bounding indices for Tr
  let Tr_idx0 = 0, Tr_idx1 = 0;
  for (let i = 0; i < Z_FACTOR_TABLE.Tr.length - 1; i++) {
    if (Tr_clamped >= Z_FACTOR_TABLE.Tr[i] && Tr_clamped <= Z_FACTOR_TABLE.Tr[i + 1]) {
      Tr_idx0 = i;
      Tr_idx1 = i + 1;
      break;
    }
  }

  // Bilinear interpolation
  const Pr0 = Z_FACTOR_TABLE.Pr[Pr_idx0];
  const Pr1 = Z_FACTOR_TABLE.Pr[Pr_idx1];
  const Tr0 = Z_FACTOR_TABLE.Tr[Tr_idx0];
  const Tr1 = Z_FACTOR_TABLE.Tr[Tr_idx1];

  const Z00 = Z_FACTOR_TABLE.Z[Pr_idx0][Tr_idx0];
  const Z01 = Z_FACTOR_TABLE.Z[Pr_idx0][Tr_idx1];
  const Z10 = Z_FACTOR_TABLE.Z[Pr_idx1][Tr_idx0];
  const Z11 = Z_FACTOR_TABLE.Z[Pr_idx1][Tr_idx1];

  // Interpolation weights
  const wPr = (Pr1 - Pr0) > 0.001 ? (Pr_clamped - Pr0) / (Pr1 - Pr0) : 0;
  const wTr = (Tr1 - Tr0) > 0.001 ? (Tr_clamped - Tr0) / (Tr1 - Tr0) : 0;

  // Bilinear interpolation
  const Z_interp = Z00 * (1 - wPr) * (1 - wTr) +
                   Z10 * wPr * (1 - wTr) +
                   Z01 * (1 - wPr) * wTr +
                   Z11 * wPr * wTr;

  return Z_interp;
}

// Calculate temperature at a given depth (linear gradient)
function temperatureAtDepth(depth_m) {
  // Linear gradient from surface to bottom
  const fraction = Math.min(1.0, depth_m / TD_DEPTH);
  return SURFACE_TEMP_R + fraction * (BOTTOM_TEMP_R - SURFACE_TEMP_R);
}

// Calculate gas expansion for a single cell
// Returns expansion factor (new volume / reference volume)
function calculateGasExpansionFactor(depth_m, isAboveBOP) {
  if (!GAS_ENABLED || formationFluidType !== 'GAS') return 1.0;

  // Get current pressure at this depth
  const P_current = pressureAtDepth(depth_m);
  if (P_current < 14.7) return 1.0; // Clamp to atmospheric minimum

  // Get temperature at this depth
  const T_current = temperatureAtDepth(depth_m);

  let expansionFactor = 1.0;

  if (GAS_EXPANSION_MODE === 'IDEAL') {
    // Ideal Gas Law: V2/V1 = (P1/P2) * (T2/T1)
    const P_ref = GAS_REFERENCE_P_psi;
    const T_ref = GAS_REFERENCE_T_R;

    expansionFactor = (P_ref / P_current) * (T_current / T_ref);
  } else {
    // Real Gas: V2/V1 = (Z2*P1*T2) / (Z1*P2*T1)
    const P_ref = GAS_REFERENCE_P_psi;
    const T_ref = GAS_REFERENCE_T_R;

    const Z_ref = getZFactor(P_ref, T_ref);
    const Z_current = getZFactor(P_current, T_current);

    expansionFactor = (Z_current * P_ref * T_current) / (Z_ref * P_current * T_ref);
  }

  // Clamp expansion to reasonable limits (prevents runaway expansion)
  return Math.max(0.1, Math.min(expansionFactor, 100.0));
}

// Apply gas expansion to all cells with gas
function applyGasExpansion(dt_s) {
  if (!GAS_ENABLED || formationFluidType !== 'GAS' || dt_s < 1e-6) return;

  let expansionVolume_m3 = 0;

  // Process below-BOP cells
  for (let i = 0; i < gasPhaseFrom_below.length; i++) {
    const gasFraction = gasPhaseFrom_below[i];
    if (gasFraction < 0.001) continue; // Skip cells with negligible gas

    // Calculate cell depth (bottom-up indexing)
    const cellDepth = BOP_DEPTH + i * CELL_M;

    // Get expansion factor
    const expansionFactor = calculateGasExpansionFactor(cellDepth, false);

    // Expanded gas tries to occupy more space
    // This pushes into adjacent cells (simplified: just scale the fraction)
    // Full implementation would redistribute volume across cells
    // For now, scale gas fraction by expansion (clamped to 1.0 max)
    const expandedFraction = Math.min(1.0, gasFraction * expansionFactor);

    // If gas expands beyond cell capacity, excess would push to cell above
    if (expandedFraction > 0.95 && i > 0) {
      const excess = expandedFraction - 0.95;
      gasPhaseFrom_below[i] = 0.95;
      gasPhaseFrom_below[i - 1] = Math.min(1.0, gasPhaseFrom_below[i - 1] + excess * 0.5);
    } else {
      gasPhaseFrom_below[i] = expandedFraction;
    }

    const cellVolume = areaAtDepthTop_(cellDepth) * CELL_M;
    const delta = Math.max(0, gasPhaseFrom_below[i] - gasFraction);
    if (delta > 1e-6) expansionVolume_m3 += delta * cellVolume;
  }

  // Process above-BOP cells (riser)
  for (let i = 0; i < gasPhaseFrom_above.length; i++) {
    const gasFraction = gasPhaseFrom_above[i];
    if (gasFraction < 0.001) continue;

    // Calculate cell depth (top-down indexing, 0 = surface)
    const cellDepth = i * CELL_M;

    const expansionFactor = calculateGasExpansionFactor(cellDepth, true);
    const expandedFraction = Math.min(1.0, gasFraction * expansionFactor);

    // If gas expands beyond cell capacity, push upward (toward surface)
    if (expandedFraction > 0.95 && i > 0) {
      const excess = expandedFraction - 0.95;
      gasPhaseFrom_above[i] = 0.95;
      gasPhaseFrom_above[i - 1] = Math.min(1.0, gasPhaseFrom_above[i - 1] + excess * 0.5);
    } else {
      gasPhaseFrom_above[i] = expandedFraction;
    }

    const cellVolume = areaAtDepthTop_(cellDepth) * CELL_M;
    const delta = Math.max(0, gasPhaseFrom_above[i] - gasFraction);
    if (delta > 1e-6) expansionVolume_m3 += delta * cellVolume;
  }

  window.__gasExpansion_m3s = expansionVolume_m3 > 1e-6
    ? expansionVolume_m3 / Math.max(dt_s, 1e-6)
    : 0;
}

// ====================== PRESSURE / ECD PROFILES =======================
// In ecdAtDepth function, add:
// Helper function to get effective density of a cell including kick fluids
function effectiveCellDensity_ppg(mudWeight_ppg, cellIndex, isAboveBOP) {
  // Start with base mud weight
  let effectiveDensity = mudWeight_ppg;

  // Get kick fluid fractions for this cell
  let gasFraction = 0, oilFraction = 0, waterFraction = 0;

  if (isAboveBOP) {
    gasFraction = gasPhaseFrom_above[cellIndex] || 0;
    oilFraction = oilPhaseFrom_above[cellIndex] || 0;
    waterFraction = waterPhaseFrom_above[cellIndex] || 0;
  } else {
    gasFraction = gasPhaseFrom_below[cellIndex] || 0;
    oilFraction = oilPhaseFrom_below[cellIndex] || 0;
    waterFraction = waterPhaseFrom_below[cellIndex] || 0;
  }

  // Total kick fraction in this cell
  const totalKickFraction = Math.min(1.0, gasFraction + oilFraction + waterFraction);

  // If there are kick fluids, calculate mixed density
  if (totalKickFraction > 0.001) {
    // Get formation fluid densities
    const gasDensity = FORMATION_FLUID_TYPES['GAS'].density_ppg;
    const oilDensity = (formationFluidType === 'BLACKOIL')
      ? FORMATION_FLUID_TYPES['BLACKOIL'].density_ppg
      : FORMATION_FLUID_TYPES['OIL'].density_ppg;
    const waterDensity = FORMATION_FLUID_TYPES['WATER'].density_ppg;

    // Calculate weighted average of kick fluids
    const kickDensity = (gasFraction * gasDensity + oilFraction * oilDensity + waterFraction * waterDensity)
                       / Math.max(totalKickFraction, 0.001);

    // Mix with mud: (mud fraction √ó mud density) + (kick fraction √ó kick density)
    const mudFraction = 1.0 - totalKickFraction;
    effectiveDensity = mudFraction * mudWeight_ppg + totalKickFraction * kickDensity;
  }

  return effectiveDensity;
}

function averageEffectiveDensity(grid, isAboveBOP){
  if (!Array.isArray(grid) || grid.length === 0) {
    return MW_DS;
  }
  let sum = 0;
  for (let i = 0; i < grid.length; i++){
    const base = grid[i] || MW_DS;
    sum += effectiveCellDensity_ppg(base, i, isAboveBOP);
  }
  return sum / grid.length;
}

function effectiveFluidTopForDepth(depth){
  const topGlobal = (typeof surfaceColumnTopDepth === 'function')
    ? surfaceColumnTopDepth()
    : (typeof annulusTopDepthGlobal === 'function' ? annulusTopDepthGlobal() : 0);

  if (BOP_CLOSED && depth >= BOP_DEPTH) {
    return Math.max(topGlobal, BOP_DEPTH);
  }
  return topGlobal;
}

function densitySegmentForHydro(depth){
  const clampedDepth = Math.max(0, Math.min(depth, TD_DEPTH));
  const isAbove = clampedDepth < BOP_DEPTH;
  const idx = isAbove
    ? Math.max(0, Math.floor(clampedDepth / CELL_M))
    : Math.max(0, Math.floor((Math.max(clampedDepth, BOP_DEPTH) - BOP_DEPTH) / CELL_M));
  const cellTop = isAbove ? idx * CELL_M : BOP_DEPTH + idx * CELL_M;
  const cellBottom = Math.min(cellTop + CELL_M, TD_DEPTH);
  const grid = isAbove ? annAboveGrid : annBelowGrid;
  const baseMW = (Array.isArray(grid) && idx < grid.length && typeof grid[idx] === 'number')
    ? grid[idx]
    : MW_DS;
  const density_ppg = effectiveCellDensity_ppg(baseMW, idx, isAbove);
  return { cellBottom, density_ppg };
}

function hydrostaticPsiBetween(topDepth, bottomDepth){
  const top = Math.max(0, Math.min(topDepth, TD_DEPTH));
  const bottom = Math.max(0, Math.min(bottomDepth, TD_DEPTH));
  if (bottom <= top) return 0;

  let psi = 0;
  let depth = top;
  const epsilon = 1e-6;

  while (depth < bottom - epsilon){
    const seg = densitySegmentForHydro(depth);
    const segBottom = Math.min(bottom, seg.cellBottom);
    const dz = Math.max(0, segBottom - depth);
    if (dz <= 0){
      depth = segBottom + epsilon;
      continue;
    }
    psi += PSI_COEF * seg.density_ppg * dz;
    depth = segBottom;
  }

  return psi;
}

function ecdAtDepth(d){
  // ‚úÖ FIXED: Correct averaging from surface to depth
  // ECD = average mud weight from surface down to specified depth
  // ‚úÖ NOW INCLUDES: Kick fluid density mixing (lighter fluids reduce hydrostatic)

  if (d <= BOP_DEPTH){
    // Above BOP: average cells from surface to depth in riser
    const numCells = Math.floor(d / CELL_M) + 1;

    // Calculate sum with kick fluid mixing
    let sum = 0;
    for (let i = 0; i < numCells && i < annAboveGrid.length; i++) {
      const mudWeight = annAboveGrid[i] || MW_DS;
      const effectiveDensity = effectiveCellDensity_ppg(mudWeight, i, true);
      sum += effectiveDensity;
    }

    const result = sum / Math.max(numCells, 1);
    return result;
  } else {
    // Below BOP: average ALL riser cells + cells from BOP to depth

    // Sum riser cells with kick mixing
    let sumAbove = 0;
    for (let i = 0; i < N_ABV; i++) {
      const mudWeight = annAboveGrid[i] || MW_DS;
      const effectiveDensity = effectiveCellDensity_ppg(mudWeight, i, true);
      sumAbove += effectiveDensity;
    }
    const nAbove = N_ABV;

    // Cells from BOP to depth in casing/OH
    const depthBelowBOP = d - BOP_DEPTH;
    const numBelowCells = Math.floor(depthBelowBOP / CELL_M) + 1;

    // ‚úÖ FIX: Don't try to sum more cells than exist in the grid!
    const actualBelowCells = Math.min(numBelowCells, annBelowGrid.length);

    // Sum below-BOP cells with kick mixing
    let sumBelow = 0;
    for (let i = 0; i < actualBelowCells; i++) {
      const mudWeight = annBelowGrid[i] || MW_DS;
      const effectiveDensity = effectiveCellDensity_ppg(mudWeight, i, false);
      sumBelow += effectiveDensity;
    }

    const totalCells = nAbove + actualBelowCells;  // Use actual cells, not calculated
    const result = (sumAbove + sumBelow) / Math.max(totalCells, 1);
    return result;
  }
}



// --- ECD (ppg) that includes SBP + friction at depth ---
function ecdWithSBPAtDepth(d){
  const depth = Math.max(1, Math.min(d, TD_DEPTH));
  const P = pressureAtDepth(depth);             // hydro + friction + SBP
  return P / ((typeof PSI_COEF === 'number' ? PSI_COEF : 0.1704) * depth);
}
function pressureAtDepth_noSBP(d){
  const depth = Math.max(0, Math.min(d, TD_DEPTH));
  const fluidTop = effectiveFluidTopForDepth(depth);
  if (depth <= fluidTop) return 14.7;

  const P_hyd = hydrostaticPsiBetween(fluidTop, depth);
  const P_fric = frictionPsi(depth);
  return P_hyd + P_fric;
}


// --- Rheology-aware ŒîP/L from volumetric flow in a circular conduit (GNF) ---
// We invert Q(dP) numerically to get dP/L that yields the requested Q.
function __dpPerM_pipe_GNF_fromQ(Q_m3s, D_m, tauToShearRateFn){
  const L = 1.0;                    // 1 meter for gradient
  const Qtarget = Math.max(0, Q_m3s);
  if (Qtarget <= 0 || D_m <= 0) return 0;

  // Bracket ŒîP (psi) then bisection
  let lo = 0, hi = 1e6; // psi/m (huge upper bound)
  for (let k=0; k<50; k++){        // expand until Q(hi) >= target
    const Qhi = laminarPipeFlow_GNF(hi, D_m, L, tauToShearRateFn);
    if (Qhi >= Qtarget) break;
    hi *= 2;
  }
  for (let it=0; it<40; it++){
    const mid = 0.5*(lo+hi);
    const Qmid = laminarPipeFlow_GNF(mid, D_m, L, tauToShearRateFn);
    if (Qmid >= Qtarget) hi = mid; else lo = mid;
  }
  return hi; // psi per meter
}

// Return ŒîP/L for an *annulus* using hydraulic diameter equivalence.
// --- Rheology-aware annulus ŒîP/L helper (uses ACTIVE_RHEO_MODEL) ---
function __dpPerM_annulus_GNF_fromQ(Q_m3s, ID_m, OD_m, modelName){
  const ri = Math.min(ID_m, OD_m) * 0.5;
  const ro = Math.max(ID_m, OD_m) * 0.5;
  const gap = ro - ri;
  if (gap <= 1e-6) return 0;

  const A  = Math.PI * (ro*ro - ri*ri);
  const P  = 2*Math.PI*(ri + ro);
  const Dh = 4 * A / P;

  const m = String(modelName || window.ACTIVE_RHEO_MODEL || 'HB').toUpperCase();

  if (m === 'BINGHAM'){
    const tauY = (window.TAUY_Pa ?? 5);
    const muP  = (window.MUP_PaS ?? 0.1);
    const tauToShear = (tau) => (tau <= tauY) ? 0 : (tau - tauY)/Math.max(muP,1e-12);
    const result = __dpPerM_pipe_GNF_fromQ(Q_m3s, Dh, tauToShear);
    return result;
  } else if (m === 'PL' || m === 'POWERLAW' || m === 'POWER-LAW'){
    const K = (window.K_PaSn ?? 0.2);
    const n = Math.max(1e-6, (window.N_dim ?? 0.7));
    const tauToShear = (tau) => Math.pow(Math.max(tau,0)/Math.max(K,1e-12), 1/n);
    const result = __dpPerM_pipe_GNF_fromQ(Q_m3s, Dh, tauToShear);
    return result;
  } else { // HB default
    const tauY = (window.TAUY_Pa ?? 5);
    const K    = (window.K_PaSn  ?? 0.2);
    const n    = Math.max(1e-6, (window.N_dim ?? 0.6));
    const tauToShear = (tau) => (tau <= tauY) ? 0 : Math.pow((tau - tauY)/Math.max(K,1e-12), 1/n);
    const result = __dpPerM_pipe_GNF_fromQ(Q_m3s, Dh, tauToShear);
    return result;
  }
}


// invert Q(dP) to get ŒîP/L for a circular conduit (used with Dh)
function __dpPerM_pipe_GNF_fromQ(Q_m3s, D_m, tauToShearRateFn){
  const L = 1.0;
  const Qtarget = Math.max(0, Q_m3s);
  if (Qtarget <= 0 || D_m <= 0) return 0;

  let lo = 0, hi = 1e6; // psi per meter
  for (let k=0; k<50; k++){
    const Qhi = laminarPipeFlow_GNF(hi, D_m, L, tauToShearRateFn);
    if (Qhi >= Qtarget) break;
    hi *= 2;
  }
  for (let it=0; it<40; it++){
    const mid = 0.5*(lo+hi);
    const Qmid = laminarPipeFlow_GNF(mid, D_m, L, tauToShearRateFn);
    if (Qmid >= Qtarget) hi = mid; else lo = mid;
  }
  return hi; // psi per meter
}

// --- Friction from surface to depth d (psi), CML/wet-top aware & rheology-aware ---
function frictionPsi_withCML_rheo(d){
  const depth = Math.max(0, d);

  // Read section flows published by routeAnnulusFlowsWithLosses()
  // DO NOT call recomputeAnnulusSectionFlowsForLosses() - it uses old routing logic!
  const qAboveRaw = Math.max(0, window.__qAnnAbove_m3s || window.__qAnnUp_m3s || 0);
  const qBelow = Math.max(0, window.__qAnnBelow_m3s || window.__qAnnDown_m3s || 0);
  // When the BOP is closed the riser is hydraulically isolated from the annulus
  // below the stack, so booster circulation inside the riser must not influence
  // the friction (and therefore pressure) calculations for depths at or below
  // the BOP. Otherwise, changing the booster flow would incorrectly alter the
  // BHP even though that circulation cannot communicate with the well.
  const riserFeedsAnnulus = !(BOP_CLOSED && depth >= BOP_DEPTH);
  const qAbove = riserFeedsAnnulus ? qAboveRaw : 0;

  // Wet spans
  const topGlobal = (typeof annulusTopDepthGlobal==='function') ? annulusTopDepthGlobal()
                   : (typeof riserTopDepth==='function' ? riserTopDepth() : 0);
  const topRiser  = Math.min(topGlobal, BOP_DEPTH);
  const topBelow  = Math.max(BOP_DEPTH, topGlobal);

  const L_riser = Math.max(0, Math.min(BOP_DEPTH, depth) - topRiser);
  const L_csg   = (depth <= BOP_DEPTH) ? 0 : Math.max(0, Math.min(depth, SHOE_DEPTH) - topBelow);
  const L_oh    = (depth <= SHOE_DEPTH) ? 0 : Math.max(0, depth - Math.max(topBelow, SHOE_DEPTH));

  // Geometries (outer = section ID, inner = DS OD)
  const ID_ris = (typeof riser_ID_m   !== 'undefined') ? riser_ID_m   : 0.482;
  const ID_csg = (typeof casing_ID_m  !== 'undefined') ? casing_ID_m  : 0.216;
  const ID_oh  = (typeof openhole_ODm !== 'undefined') ? openhole_ODm : 0.216;
  const OD_ds  = (typeof ds_OD_m      !== 'undefined') ? ds_OD_m      : 0.127;

  // ŒîP/L (psi/m) - use turbulent-capable friction function
  const mName = ACTIVE_RHEO_MODEL;
  const { K, n, tauY } = getRheoForCalc();

  // Convert MW to density (ppg to kg/m¬≥)
  const rho = ecdAtDepth(depth) * 119.826; // kg/m¬≥

  // Use turbulent-capable friction (auto-switches laminar/turbulent based on Re)
  // Returns Pa/m, convert to psi/m
  const PA_TO_PSI = 1.0 / 6894.757;
  const dpdm_riser = (L_riser>0) ? dP_per_m_annulus_withRPM(qAbove, rho, ID_ris, OD_ds, K, n, tauY, RPM) * PA_TO_PSI : 0;
  const dpdm_csg   = (L_csg  >0) ? dP_per_m_annulus_withRPM(qBelow, rho, ID_csg, OD_ds, K, n, tauY, RPM) * PA_TO_PSI : 0;
  const dpdm_oh    = (L_oh   >0) ? dP_per_m_annulus_withRPM(qBelow, rho, ID_oh,  OD_ds, K, n, tauY, RPM) * PA_TO_PSI : 0;

  let psi_riser = dpdm_riser * L_riser;
  if (L_riser > 0) {
    psi_riser = enforceMonotonicFriction('riser_total', qAbove, psi_riser);
  }

  const totalFriction = psi_riser + dpdm_csg*L_csg + dpdm_oh*L_oh;
  return totalFriction;
}

// Back-compat entry point
function frictionPsi_withCML(depth_m){
  return frictionPsi_withCML_rheo(depth_m);
}
function frictionPsiAtDepth(depth_m){ return frictionPsi_withCML(depth_m); }

// --- Pressure without SBP: hydro (wet-top aware) + rheology-aware friction ---
function pressureAtDepth_noSBP_withCML(d){
  const depth = Math.max(0, Math.min(d, (typeof TD_DEPTH==='number' ? TD_DEPTH : d)));
  const fluidTop = effectiveFluidTopForDepth(depth);
  if (depth <= fluidTop) return 14.7;

  const P_hyd = hydrostaticPsiBetween(fluidTop, depth);
  const P_fric = (typeof frictionPsi_withCML_rheo==='function') ? frictionPsi_withCML_rheo(depth) : 0;

  return P_hyd + P_fric;
}

// --- Total annulus pressure (psi): hydro + friction + SBP ---
// Find pressureAtDepth (around line 1340) - ensure it looks like this:

function pressureAtDepth(d, opts = {}){
  if (d < 0) return 0;
  if (d > TD_DEPTH) d = TD_DEPTH;

  const overrideTopRaw = (typeof opts.overrideFluidTop === 'number')
    ? Number(opts.overrideFluidTop)
    : null;
  const hasOverrideTop = Number.isFinite(overrideTopRaw);
  let fluidTop = hasOverrideTop
    ? clamp(overrideTopRaw, 0, TD_DEPTH)
    : effectiveFluidTopForDepth(d);

  // Refresh section flows
  if (typeof window.__qAnnAbove_m3s !== 'number' || typeof window.__qAnnBelow_m3s !== 'number'){
    if (typeof recomputeAnnulusSectionFlowsForLosses === 'function') {
      recomputeAnnulusSectionFlowsForLosses();
    }
  }

  const includeBopLines = (typeof opts.includeBopLines === 'boolean') ? opts.includeBopLines : true;
  const includeClosed = (typeof opts.includeClosedWell === 'boolean') ? opts.includeClosedWell : true;
  const belowBOP = d >= BOP_DEPTH;
  const bopIsolated = BOP_CLOSED && belowBOP;
  const mpdSurfaceSeal = (typeof mpdSealActive === 'function') ? mpdSealActive() : false;

  if (bopIsolated && !hasOverrideTop) {
    fluidTop = Math.max(fluidTop, BOP_DEPTH);
  }

  const sbpPsi = sbpAppliedPsi();
  const sbpApplies = !(BOP_CLOSED && belowBOP);
  const P_sbp = sbpApplies ? sbpPsi : 0;

  const bopLineSegment = (includeBopLines && belowBOP) ? dominantBopLineSegment() : null;
  const bopLineActive = !!bopLineSegment;
  const P_bop_lines = bopLineActive
    ? (bopLineSegment.surfacePressure + bopLineSegment.frictionPsi + PSI_COEF * bopLineSegment.mw * bopLineSegment.wetLen)
    : 0;
  const closedApplies = includeClosed && (
    mpdSurfaceSeal || (BOP_CLOSED && belowBOP && closedWellCompressionActive())
  );
  const P_closed_well = closedApplies ? (closedWellPressureBoost_psi || 0) : 0;

  const basePsi = bopIsolated
    ? (isFinite(trappedAnnulusBasePressure_psi)
        ? trappedAnnulusBasePressure_psi
        : (isFinite(lastOpenAnnulusPressure_psi) ? lastOpenAnnulusPressure_psi : 14.7))
    : 0;

  // Above fluid level
  if (d <= fluidTop) {
    if (bopIsolated) {
      const boundaryPsi = bopLineActive ? P_bop_lines : basePsi;
      return boundaryPsi + P_closed_well;
    }
    return 14.7;
  }

  // Hydrostatic (only below fluid level)
  const P_hydro = hydrostaticPsiBetween(fluidTop, d);

  // Friction
  let P_fric = frictionPsi_withCML_rheo(d);
  if (bopIsolated) {
    const refFric = frictionPsi_withCML_rheo(BOP_DEPTH);
    P_fric = Math.max(0, P_fric - refFric);
  }

  let total = P_hydro + P_fric + P_sbp + P_closed_well;
  if (bopLineActive) {
    total += P_bop_lines;
  } else if (bopIsolated) {
    total += basePsi;
  }
  return total;
}

// --- ECD (ppg) from full pressure (includes SBP + friction) ---
function ecdWithSBPAtDepth(d){
  const depth = Math.max(1, d); // avoid /0
  const P     = pressureAtDepth(depth);
  return P / ((typeof PSI_COEF==='number' ? PSI_COEF : 0.1704) * depth);
}


// ================== SPP + LEVEL (smooth low-flow ramp) =================
function dsFrictionPsiLength(len_m){
  const { qDS } = flows_m3s();
  const pa_per_m = dPperM_drillstring(qDS);
  const rawPsi = (pa_per_m * Math.max(len_m, 0)) * PSI_PER_PASCAL;
  return smoothFrictionPsi('ds', rawPsi);
}
function boosterFrictionPsiLength(len_m){
  const { qBO } = flows_m3s();
  const pa_per_m = dPperM_booster(qBO);
  const rawPsi = (pa_per_m * Math.max(len_m, 0)) * PSI_PER_PASCAL;
  return smoothFrictionPsi('booster', rawPsi);
}

// === CHOKE LINE FRICTION ===
function chokeFrictionPsiLength(len_m, flowRate_m3s){
  if (len_m <= 0 || flowRate_m3s <= 0) return 0;

  // Get choke line properties
  const D_m = CHOKE_LINE_ID_m || 0.076; // Default 3 inches
  const { K, n, tauY } = getRheoForCalc();

  // Average density from choke grid
  const avgMW = chokeGrid.length > 0 ? average(chokeGrid) : MW_CHOKE;
  const rho_kgm3 = avgMW * PPG_TO_KGM3;

  // ‚úÖ FIXED: Use pipe friction function (not annulus with OD=0)
  // This ensures proper laminar/turbulent transition for pipe flow
  const dpdm_Pa = dP_per_m_pipe_withRPM(flowRate_m3s, rho_kgm3, D_m, K, n, tauY, 0); // No RPM in choke line
  const PA_TO_PSI = 1.0 / 6894.757;
  const rawPsi = dpdm_Pa * len_m * PA_TO_PSI;
  const dirKey = (CHOKE_DIRECTION === 'DOWN') ? 'choke_down' : 'choke_up';
  return smoothFrictionPsi(dirKey, rawPsi);
}

// === KILL LINE FRICTION ===
function killFrictionPsiLength(len_m, flowRate_m3s){
  if (len_m <= 0 || flowRate_m3s <= 0) return 0;

  // Get kill line properties
  const D_m = KILL_LINE_ID_m || 0.076; // Default 3 inches
  const { K, n, tauY } = getRheoForCalc();

  // Average density from kill grid
  const avgMW = killGrid.length > 0 ? average(killGrid) : MW_KILL;
  const rho_kgm3 = avgMW * PPG_TO_KGM3;

  // ‚úÖ FIXED: Use pipe friction function (not annulus with OD=0)
  // This ensures proper laminar/turbulent transition for pipe flow
  const dpdm_Pa = dP_per_m_pipe_withRPM(flowRate_m3s, rho_kgm3, D_m, K, n, tauY, 0); // No RPM in kill line
  const PA_TO_PSI = 1.0 / 6894.757;
  const rawPsi = dpdm_Pa * len_m * PA_TO_PSI;
  const dirKey = (KILL_DIRECTION === 'DOWN') ? 'kill_down' : 'kill_up';
  return smoothFrictionPsi(dirKey, rawPsi);
}

function activeBopLineSegments(){
  if (!BOP_CLOSED) return [];

  const segments = [];
  const chokeActive = CHOKE_LINE_OPEN && CHOKE_DIRECTION === 'UP';
  const killActive  = KILL_LINE_OPEN && KILL_DIRECTION === 'UP';

  if (chokeActive) {
    const qChoke_m3s = (typeof window !== 'undefined' && typeof window.__Q_CHOKE_CALCULATED_m3s === 'number')
      ? Math.max(window.__Q_CHOKE_CALCULATED_m3s, 0)
      : (Q_CHOKE || 0) * M3_PER_GPM;
    const dryLen = effectiveLineDryLength('choke');
    const wetLen = Math.max(0, BOP_DEPTH - dryLen);
    if (wetLen > 0) {
      const friction_psi = chokeFrictionPsiLength(wetLen, qChoke_m3s);
      const chokeMW = chokeGrid.length > 0 ? average(chokeGrid) : MW_CHOKE;
      segments.push({
        name: 'choke',
        wetLen,
        mw: chokeMW,
        frictionPsi: friction_psi,
        surfacePressure: CHOKE_PRESSURE_psi,
        flow_m3s: qChoke_m3s
      });
    }
  }

  if (killActive) {
    const qKill_m3s = (typeof window !== 'undefined' && typeof window.__Q_KILL_CALCULATED_m3s === 'number')
      ? Math.max(window.__Q_KILL_CALCULATED_m3s, 0)
      : (Q_KILL || 0) * M3_PER_GPM;
    const dryLen = effectiveLineDryLength('kill');
    const wetLen = Math.max(0, BOP_DEPTH - dryLen);
    if (wetLen > 0) {
      const friction_psi = killFrictionPsiLength(wetLen, qKill_m3s);
      const killMW = killGrid.length > 0 ? average(killGrid) : MW_KILL;
      segments.push({
        name: 'kill',
        wetLen,
        mw: killMW,
        frictionPsi: friction_psi,
        surfacePressure: KILL_PRESSURE_psi,
        flow_m3s: qKill_m3s
      });
    }
  }

  return segments;
}

function chokeLineIsFlowingUp(){
  return CHOKE_LINE_OPEN && CHOKE_DIRECTION === 'UP';
}

function killLineIsFlowingUp(){
  return KILL_LINE_OPEN && KILL_DIRECTION === 'UP';
}

function measuredBopLineUpflow_m3s(which){
  if (typeof window !== 'undefined') {
    const directKey = which === 'choke' ? '__qChokeUp_m3s' : '__qKillUp_m3s';
    if (typeof window[directKey] === 'number') {
      return Math.max(window[directKey], 0);
    }
    const legacyKey = which === 'choke' ? '__Q_CHOKE_CALCULATED_m3s' : '__Q_KILL_CALCULATED_m3s';
    if (typeof window[legacyKey] === 'number') {
      return Math.max(window[legacyKey], 0);
    }
  }
  const q_gpm = (which === 'choke') ? (Q_CHOKE || 0) : (Q_KILL || 0);
  const dirUp = (which === 'choke') ? (CHOKE_DIRECTION === 'UP') : (KILL_DIRECTION === 'UP');
  return dirUp ? Math.max(q_gpm, 0) / 15850.323 : 0;
}

function measuredBopLineUpflow_gpm(which){
  return measuredBopLineUpflow_m3s(which) * 15850.323;
}

function chokeLineHasUserPressureControl(){
  if (CHOKE_DIRECTION !== 'UP') return false;
  if (!chokeLineIsFlowingUp()) return false;
  if (!killLineIsFlowingUp()) return true;
  return bopPressureMaster === 'choke';
}

function killLineHasUserPressureControl(){
  if (KILL_DIRECTION !== 'UP') return false;
  if (!killLineIsFlowingUp()) return false;
  if (!chokeLineIsFlowingUp()) return true;
  return bopPressureMaster === 'kill';
}

function updateBopPressureMasterState(chokeUpActive, killUpActive){
  if (chokeUpActive && !chokeUpWasActive){
    chokeUpActivationSeq = ++bopPressureActivationCounter;
  }
  if (killUpActive && !killUpWasActive){
    killUpActivationSeq = ++bopPressureActivationCounter;
  }

  if (!chokeUpActive && !killUpActive){
    bopPressureMaster = null;
  } else {
    if (bopPressureMaster === 'choke' && !chokeUpActive) bopPressureMaster = null;
    if (bopPressureMaster === 'kill' && !killUpActive) bopPressureMaster = null;
    if (!bopPressureMaster){
      if (chokeUpActive && killUpActive){
        if (chokeUpActivationSeq && killUpActivationSeq){
          bopPressureMaster = (chokeUpActivationSeq <= killUpActivationSeq) ? 'choke' : 'kill';
        } else if (chokeUpActivationSeq){
          bopPressureMaster = 'choke';
        } else if (killUpActivationSeq){
          bopPressureMaster = 'kill';
        } else {
          bopPressureMaster = 'choke';
        }
      } else if (chokeUpActive){
        bopPressureMaster = 'choke';
      } else if (killUpActive){
        bopPressureMaster = 'kill';
      }
    }
  }

  chokeUpWasActive = chokeUpActive;
  killUpWasActive = killUpActive;

  applyBopPressureTargets();
}

function applyBopPressureTargets(){
  if (CHOKE_DIRECTION === 'UP' && chokeLineHasUserPressureControl()){
    CHOKE_PRESSURE_psi = CHOKE_PRESSURE_TARGET_psi;
  }
  if (KILL_DIRECTION === 'UP' && killLineHasUserPressureControl()){
    KILL_PRESSURE_psi = KILL_PRESSURE_TARGET_psi;
  }
}

function setChokePressureTarget(psi){
  const clamped = Math.max(0, psi);
  CHOKE_PRESSURE_TARGET_psi = clamped;
  if (chokeLineHasUserPressureControl()) {
    CHOKE_PRESSURE_psi = clamped;
  }
}

function setKillPressureTarget(psi){
  const clamped = Math.max(0, psi);
  KILL_PRESSURE_TARGET_psi = clamped;
  if (killLineHasUserPressureControl()) {
    KILL_PRESSURE_psi = clamped;
  }
}

function chokePressureControlMode(){
  if (CHOKE_DIRECTION !== 'UP') return 'down';
  if (!chokeLineIsFlowingUp()) return 'up-passive';
  if (!killLineIsFlowingUp()) return 'up-control';
  return chokeLineHasUserPressureControl() ? 'up-control' : 'up-passive';
}

function killPressureControlMode(){
  if (KILL_DIRECTION !== 'UP') return 'down';
  if (!killLineIsFlowingUp()) return 'up-passive';
  if (!chokeLineIsFlowingUp()) return 'up-control';
  return killLineHasUserPressureControl() ? 'up-control' : 'up-passive';
}

function chokeWetLength_m(){
  const dryLen = effectiveLineDryLength('choke');
  return Math.max(0, BOP_DEPTH - dryLen);
}

function killWetLength_m(){
  const dryLen = effectiveLineDryLength('kill');
  return Math.max(0, BOP_DEPTH - dryLen);
}

function dominantBopLineSegment(){
  if (!BOP_CLOSED) return null;
  const segments = activeBopLineSegments();
  if (!segments.length) return null;
  if (bopPressureMaster){
    const owner = segments.find(seg => seg.name === bopPressureMaster);
    if (owner) return owner;
  }
  if (segments.length === 1) return segments[0];
  return segments.reduce((best, seg) => {
    if (!best) return seg;
    const flow = Math.max(seg.flow_m3s || 0, 0);
    const bestFlow = Math.max(best.flow_m3s || 0, 0);
    if (flow > bestFlow + 1e-6) return seg;
    if (Math.abs(flow - bestFlow) < 1e-6) {
      const head = (seg.surfacePressure || 0) + (seg.frictionPsi || 0);
      const bestHead = (best.surfacePressure || 0) + (best.frictionPsi || 0);
      if (head > bestHead) return seg;
    }
    return best;
  }, null);
}

// === BOP WELLBORE PRESSURE CONTRIBUTION FROM CHOKE/KILL LINES ===
// When BOP is closed and lines flow UP, this pressure adds to BHP
function bopLinePressureContribution(){
  if (!BOP_CLOSED) return 0;
  const seg = dominantBopLineSegment();
  if (!seg) return 0;
  const hydro_psi = PSI_COEF * seg.mw * seg.wetLen;
  return seg.surfacePressure + seg.frictionPsi + hydro_psi;
}

function bopLinePressureAboveBOP(depth){
  if (!BOP_CLOSED) return NaN;
  const seg = dominantBopLineSegment();
  if (!seg) return NaN;

  const targetDepth = clamp(depth, 0, BOP_DEPTH);
  const wetLen = Math.max(seg.wetLen, 0);
  if (wetLen <= 1e-6) {
    const appliedAtBOP = pressureAtDepth(BOP_DEPTH);
    return targetDepth >= BOP_DEPTH ? appliedAtBOP : Math.max(14.7, appliedAtBOP);
  }

  const fluidTopDepth = BOP_DEPTH - wetLen;
  const depthWithinFluid = Math.max(0, Math.min(targetDepth - fluidTopDepth, wetLen));
  const gradHydro = PSI_COEF * seg.mw;
  const gradFric = seg.frictionPsi / Math.max(wetLen, 1e-6);
  const gradTotal = gradHydro + gradFric;
  const appliedAtBOP = pressureAtDepth(BOP_DEPTH);
  const pressureAtFluidTop = Math.max(14.7, appliedAtBOP - gradTotal * wetLen);

  if (targetDepth <= fluidTopDepth) {
    return pressureAtFluidTop;
  }

  return pressureAtFluidTop + gradTotal * depthWithinFluid;
}

function bopLineEcdAtDepth(depth){
  if (!BOP_CLOSED) return NaN;
  const d = Math.max(1, Math.min(depth, BOP_DEPTH));
  const linePressure = bopLinePressureAboveBOP(d);
  if (!isFinite(linePressure)) return NaN;
  return linePressure / ((typeof PSI_COEF === 'number' ? PSI_COEF : 0.1704) * d);
}

// === MULTI-PATH PRESSURE BALANCE SOLVER FOR UP FLOW ===
// Solves for flow distribution when multiple paths available for UP flow
// Each path must satisfy: BHP_source = P_hydro + P_friction(Q) + P_applied
function calculateUPFlowDistribution(qAvailable_m3s, BHP_source_psi) {
  // Result object
  const result = {
    Q_riser_m3s: 0,
    Q_choke_m3s: 0,
    Q_kill_m3s: 0,
    convergence: false,
    iterations: 0,
    warnings: []
  };

  if (qAvailable_m3s < 1e-8) return result;

  // Identify available paths
  const paths = [];

  // RISER path (available if BOP open)
  if (!BOP_CLOSED) {
    const riserMW = averageEffectiveDensity(annAboveGrid, true);
    const riserHydro_psi = PSI_COEF * riserMW * BOP_DEPTH;
    const appliedPressure = sbpAppliedPsi();

    paths.push({
      name: 'RISER',
      hydrostaticPsi: riserHydro_psi,
      appliedPsi: appliedPressure,
      length_m: BOP_DEPTH,
      diameter_m: riser_ID_m,
      avgMW: riserMW
    });
  }

  // CHOKE LINE path (available if open and direction UP)
  const chokeUp = CHOKE_LINE_OPEN && CHOKE_DIRECTION === 'UP';
  if (chokeUp) {
    const chokeMW = chokeGrid.length > 0 ? average(chokeGrid) : MW_CHOKE;
    const chokeHydro_psi = PSI_COEF * chokeMW * BOP_DEPTH;

    paths.push({
      name: 'CHOKE',
      hydrostaticPsi: chokeHydro_psi,
      appliedPsi: CHOKE_PRESSURE_psi,
      length_m: BOP_DEPTH,
      diameter_m: CHOKE_LINE_ID_m,
      avgMW: chokeMW
    });
  }

  // KILL LINE path (available if open and direction UP)
  const killUp = KILL_LINE_OPEN && KILL_DIRECTION === 'UP';
  if (killUp) {
    const killMW = killGrid.length > 0 ? average(killGrid) : MW_KILL;
    const killHydro_psi = PSI_COEF * killMW * BOP_DEPTH;

    paths.push({
      name: 'KILL',
      hydrostaticPsi: killHydro_psi,
      appliedPsi: KILL_PRESSURE_psi,
      length_m: BOP_DEPTH,
      diameter_m: KILL_LINE_ID_m,
      avgMW: killMW
    });
  }

  // If no paths available, return zero flow
  if (paths.length === 0) {
    result.warnings.push('No UP flow paths available');
    return result;
  }

  // If only one path, all flow goes through it
  if (paths.length === 1) {
    const path = paths[0];
    const Q = qAvailable_m3s;

    if (path.name === 'RISER') result.Q_riser_m3s = Q;
    else if (path.name === 'CHOKE') result.Q_choke_m3s = Q;
    else if (path.name === 'KILL') result.Q_kill_m3s = Q;

    result.convergence = true;
    result.iterations = 1;
    return result;
  }

  // MULTI-PATH: Iterative solver using conductance approach
  // Initial guess: distribute by inverse resistance (linear approximation)
  const { K, n, tauY } = getRheoForCalc();

  // Estimate initial conductances (inverse resistance)
  for (let p of paths) {
    const L = p.length_m;
    // Approximate viscosity from K for power law
    const approxVisc = K * Math.pow(1.0, n-1); // at reference shear rate

    // ‚úÖ FIXED: Use correct hydraulic diameter for annulus vs pipe
    let D_equiv = p.diameter_m; // Default for pipes

    if (p.name === 'RISER') {
      // Riser is an ANNULUS: use hydraulic diameter (D_outer - D_inner)
      D_equiv = riser_ID_m - ds_OD_m;
    }

    // Conductance ~ D^4 / (viscosity * L) for pipes/annulus
    p.conductance = Math.pow(D_equiv, 4) / (approxVisc * L + 1e-9);
  }

  const totalConductance = paths.reduce((sum, p) => sum + p.conductance, 0);

  // Initial flow distribution by conductance
  const Q_initial = paths.map(p => qAvailable_m3s * (p.conductance / totalConductance));

  // Iterative refinement (Newton-Raphson style)
  const MAX_ITERATIONS = 20;
  const TOLERANCE_PSI = 10; // Converge when pressures within 10 psi

  let Q_current = [...Q_initial];

  for (let iter = 0; iter < MAX_ITERATIONS; iter++) {
    result.iterations = iter + 1;

    // Calculate required source pressure for each path with current Q
    const sourcePressures = paths.map((p, i) => {
      const Q = Q_current[i];
      if (Q < 1e-9) return BHP_source_psi + 1e6; // Very high if no flow

      // Calculate friction for this flow rate
      let frictionPsi = 0;
      if (p.name === 'RISER') {
        // Riser is an ANNULUS (drillstring goes through it to surface)
        const A_riser = area_annulus(riser_ID_m, ds_OD_m);
        const rho = p.avgMW * PPG_TO_KGM3;
        const dpdm_Pa = dP_per_m_annulus_withRPM(Q, rho, riser_ID_m, ds_OD_m, K, n, tauY, 0);
        frictionPsi = (dpdm_Pa * p.length_m) / 6894.757;
      } else if (p.name === 'CHOKE') {
        frictionPsi = chokeFrictionPsiLength(p.length_m, Q);
      } else if (p.name === 'KILL') {
        frictionPsi = killFrictionPsiLength(p.length_m, Q);
      }

      // Required source pressure = hydro + friction + applied
      return p.hydrostaticPsi + frictionPsi + p.appliedPsi;
    });

    // Check convergence: all source pressures should match BHP_source
    const avgSourceP = sourcePressures.reduce((sum, p) => sum + p, 0) / sourcePressures.length;
    const maxDeviation = Math.max(...sourcePressures.map(p => Math.abs(p - avgSourceP)));

    if (maxDeviation < TOLERANCE_PSI) {
      result.convergence = true;
      break;
    }

    // Adjust flow rates: if path requires higher pressure, reduce its flow
    // If path requires lower pressure, increase its flow
    const targetPressure = BHP_source_psi;

    for (let i = 0; i < paths.length; i++) {
      const pressureError = sourcePressures[i] - targetPressure;
      // Adjustment factor: reduce Q if pressure too high, increase if too low
      // Use small step for stability
      const adjustment = -pressureError * 0.0001; // Damping factor
      Q_current[i] = Math.max(0, Q_current[i] + adjustment);
    }

    // Normalize to maintain total flow
    const sumQ = Q_current.reduce((sum, q) => sum + q, 0);
    if (sumQ > 1e-9) {
      Q_current = Q_current.map(q => q * (qAvailable_m3s / sumQ));
    }
  }

  // Assign results
  for (let i = 0; i < paths.length; i++) {
    if (paths[i].name === 'RISER') result.Q_riser_m3s = Q_current[i];
    else if (paths[i].name === 'CHOKE') result.Q_choke_m3s = Q_current[i];
    else if (paths[i].name === 'KILL') result.Q_kill_m3s = Q_current[i];
  }

  if (!result.convergence) {
    result.warnings.push('Pressure balance did not converge fully');
  }

  return result;
}
// --- Pump SPP helpers should also use the rheology-aware friction ---
function sppAtLevel(lvl_m){
  const lvl = Math.max(0, Math.min(lvl_m, TD_DEPTH));
  const filledLen = TD_DEPTH - lvl;
  const dsFricPsi = dsFrictionPsiLength(filledLen);
  const annFricPsi = frictionPsi_withCML_rheo(TD_DEPTH);   // <‚Äî rheology-aware
  const sbpPsi = sbpAppliedPsi();
  const MWann = annulusConnectedAvgPPG();
  const MWds = dsAvgPPG();
  const hydroPsi = PSI_COEF * (MWann * TD_DEPTH - MWds * filledLen);

  let bopDeltaPsi = 0;
  if (BOP_CLOSED) {
    const basePsi = isFinite(trappedAnnulusBasePressure_psi)
      ? trappedAnnulusBasePressure_psi
      : (isFinite(lastOpenAnnulusPressure_psi) ? lastOpenAnnulusPressure_psi : 14.7);
    const currentBopPsi = pressureAtDepth(BOP_DEPTH);
    if (isFinite(currentBopPsi)) {
      bopDeltaPsi = Math.max(0, currentBopPsi - basePsi);
    }
  }

  return dsFricPsi + annFricPsi + sbpPsi + hydroPsi + bopDeltaPsi;
}

function boSppAtLevel(lvl_m){
  const lvl = Math.max(0, Math.min(lvl_m, BOP_DEPTH));
  const filledLen = BOP_DEPTH - lvl;
  const boFricPsi = boosterFrictionPsiLength(filledLen);
  const annFricAbovePsi = frictionPsi_withCML_rheo(BOP_DEPTH); // <‚Äî rheology-aware
  const sbpPsi = sbpAppliedPsi();
  const MWannAbv = average(annAboveGrid);
  const MWbo = boosterAvgPPG();
  const hydroPsi = PSI_COEF * (MWannAbv * BOP_DEPTH - MWbo * filledLen);
  return boFricPsi + annFricAbovePsi + sbpPsi + hydroPsi;
}

// === CHOKE LINE SPP (when flowing DOWN) ===
function chokeSppAtLevel(lvl_m){
  const lvl = Math.max(0, Math.min(lvl_m, BOP_DEPTH));
  const filledLen = BOP_DEPTH - lvl;
  const qChoke_m3s = Q_CHOKE / 15850.323;
  const chokeFricPsi = chokeFrictionPsiLength(filledLen, qChoke_m3s);

  // Pressure at BOP from below-BOP annulus
  const pressureBelowBOP = pressureAtDepth(BOP_DEPTH);

  // Hydrostatic in choke line
  const MWchoke = average(chokeGrid);
  const chokeHydroPsi = PSI_COEF * MWchoke * filledLen;

  // U-tube imbalance: wellbore pressure - choke line hydrostatic
  return chokeFricPsi + pressureBelowBOP - chokeHydroPsi;
}

function chokeLinePumpPressure(){
  // Similar to boosterPumpPressure but for choke line
  let f0 = chokeSppAtLevel(levelDeficit_choke_m);
  if (f0 < 0){
    const f1 = chokeSppAtLevel(Math.min(levelDeficit_choke_m + 1, BOP_DEPTH));
    const slope = Math.max(f1 - f0, 1e-6);
    const delta = Math.min((-f0)/slope, BOP_DEPTH - levelDeficit_choke_m);
    levelDeficit_choke_m += delta;
    return 0;
  }
  if (levelDeficit_choke_m > 0){
    const MWchoke = Math.max(average(chokeGrid), 0.1);
    const psiPerM = PSI_COEF * MWchoke;
    const rise_m = Math.min(f0 / psiPerM, levelDeficit_choke_m);
    levelDeficit_choke_m = Math.max(levelDeficit_choke_m - rise_m, 0);
    return f0 - rise_m * psiPerM;
  }
  return f0;
}

// === KILL LINE SPP (when flowing DOWN) ===
function killSppAtLevel(lvl_m){
  const lvl = Math.max(0, Math.min(lvl_m, BOP_DEPTH));
  const filledLen = BOP_DEPTH - lvl;
  const qKill_m3s = Q_KILL / 15850.323;
  const killFricPsi = killFrictionPsiLength(filledLen, qKill_m3s);

  // Pressure at BOP from below-BOP annulus
  const pressureBelowBOP = pressureAtDepth(BOP_DEPTH);

  // Hydrostatic in kill line
  const MWkill = average(killGrid);
  const killHydroPsi = PSI_COEF * MWkill * filledLen;

  // U-tube imbalance: wellbore pressure - kill line hydrostatic
  return killFricPsi + pressureBelowBOP - killHydroPsi;
}

function killLinePumpPressure(){
  // Similar to boosterPumpPressure but for kill line
  let f0 = killSppAtLevel(levelDeficit_kill_m);
  if (f0 < 0){
    const f1 = killSppAtLevel(Math.min(levelDeficit_kill_m + 1, BOP_DEPTH));
    const slope = Math.max(f1 - f0, 1e-6);
    const delta = Math.min((-f0)/slope, BOP_DEPTH - levelDeficit_kill_m);
    levelDeficit_kill_m += delta;
    return 0;
  }
  if (levelDeficit_kill_m > 0){
    const MWkill = Math.max(average(killGrid), 0.1);
    const psiPerM = PSI_COEF * MWkill;
    const rise_m = Math.min(f0 / psiPerM, levelDeficit_kill_m);
    levelDeficit_kill_m = Math.max(levelDeficit_kill_m - rise_m, 0);
    return f0 - rise_m * psiPerM;
  }
  return f0;
}
function surfacePumpPressure(){
  // updates levelDeficit_m as side-effect
  let f0 = sppAtLevel(levelDeficit_m);
  // Not enough head ‚Üí level drops (gauge stays ‚âà0 while dropping)
  if (f0 < 0){
    const f1 = sppAtLevel(Math.min(levelDeficit_m + 1, TD_DEPTH));
    const slope = Math.max(f1 - f0, 1e-6);
    const delta = Math.min((-f0)/slope, TD_DEPTH - levelDeficit_m);
    levelDeficit_m += delta;
    return 0;
  }
  // Have positive head; refill first
  if (levelDeficit_m > 0){
    const MWds = Math.max(dsAvgPPG(), 0.1);
    const psiPerM = PSI_COEF * MWds;
    const rise_m = Math.min(f0 / psiPerM, levelDeficit_m);
    levelDeficit_m = Math.max(levelDeficit_m - rise_m, 0);
    return f0 - rise_m * psiPerM;
  }
  return f0 + localKLossPsi();
}
function boosterPumpPressure(){
  // updates levelDeficit_bo_m
  let f0 = boSppAtLevel(levelDeficit_bo_m);
  if (f0 < 0){
    const f1 = boSppAtLevel(Math.min(levelDeficit_bo_m + 1, BOP_DEPTH));
    const slope = Math.max(f1 - f0, 1e-6);
    const delta = Math.min((-f0)/slope, BOP_DEPTH - levelDeficit_bo_m);
    levelDeficit_bo_m += delta;
    return 0;
  }
  if (levelDeficit_bo_m > 0){
    const MWbo = Math.max(boosterAvgPPG(), 0.1);
    const psiPerM = PSI_COEF * MWbo;
    const rise_m = Math.min(f0 / psiPerM, levelDeficit_bo_m);
    levelDeficit_bo_m = Math.max(levelDeficit_bo_m - rise_m, 0);
    return f0 - rise_m * psiPerM;
  }
  return f0 + localKLossPsi();
}

// --- TOTAL WELLBORE PRESSURE at depth (hydrostatic + annulus friction + SBP) ---
// --- TOTAL WELLBORE PRESSURE at depth (hydrostatic + annulus friction + SBP) ---
function pressureAtDepthTotal(d){
  // pressureAtDepth(d) already includes: hydrostatic (with wetted top), annulus friction, and SBP.
  // This is the annulus pressure seen by the formation at depth d.
  return pressureAtDepth(d);
}

/* ===================== ATTENUATION CONSTANTS (tune as needed) ===================== */
const LOSS_DEADBAND_PSI      = 30;   // ignore small ŒîP wiggles (psi) - increased for stability
const LOSS_P_TAU_S           = 0.80; // low-pass on zone ŒîP (s)
const LOSS_Q_TAU_S           = 1.8;  // low-pass on zone Qloss (s) - increased for smoother stabilization
const LOSS_DQDT_MAX_GPM_S    = 200;  // max zone loss change rate (gpm/s) - reduced for smoother response
const LOSS_RELAX_PER_ITER    = 0.50; // solver relaxation per iteration
const LOSS_SOLVER_MAX_IT     = 8;    // max iterations
const LOSS_SOLVER_TOL_GPM    = 0.05; // convergence tolerance (gpm)

/* ===================== SAFE HELPERS (reuse existing if present) ===================== */
const __lp = (typeof lowpass === 'function')
  ? lowpass
  : function(prev, x, dt, tau_s){ const a = tau_s > 0 ? dt / (tau_s + dt) : 1; return prev + a * (x - prev); };

const __slew = (typeof slew === 'function')
  ? slew
  : function(prev, target, maxRate_per_s, dt){
      const maxStep = Math.max(0, maxRate_per_s) * dt;
      if (target > prev + maxStep) return prev + maxStep;
      if (target < prev - maxStep) return prev - maxStep;
      return target;
    };
// --- Helpers used by the transition logic ---
function areaAtDepthTop_(d){
  if (d <= BOP_DEPTH)  return A_riserAnn();
  if (d <= SHOE_DEPTH) return A_casingAnn();
  return A_openAnn();
}
function nextBoundaryAfter_(d, goingUp){ // goingUp = true if depth is decreasing
  if (goingUp){
    // moving toward surface: boundaries are {BOP, surface}
    if (d > SHOE_DEPTH) return SHOE_DEPTH;
    if (d > BOP_DEPTH)  return BOP_DEPTH;
    return 0; // surface
  } else {
    // moving deeper: boundaries are {BOP, shoe, TD}
    if (d < BOP_DEPTH)  return BOP_DEPTH;
    if (d < SHOE_DEPTH) return SHOE_DEPTH;
    return TD_DEPTH;
  }
}

// ---------------------------------------------------------------------------
// Flow router: splits DS / Booster / TopFill toward losses first,
// then leftover (if any) becomes upward annulus flow.
// ‚úÖ NOW HANDLES BOP CLOSED STATE: Riser isolated from below-BOP annulus
// Publishes: __qToLoss_m3s, __qAnnUp_m3s, __qAnnDown_m3s (signless magnitudes)
//            and a stable FLOW_OUT_gpm via hysteresis+smoothing.
// Call once per substep BEFORE friction and level solver.
// ---------------------------------------------------------------------------
function publishBopNodeContrib(annUp=0, boosterUp=0, chokeDownUp=0, killDownUp=0){
  const clampPos = (v) => (Number.isFinite(v) && v > 0) ? v : 0;
  const ann = clampPos(annUp);
  const bo  = clampPos(boosterUp);
  const ch  = clampPos(chokeDownUp);
  const ki  = clampPos(killDownUp);
  window.__qBOP_annulusUpTotal_m3s = ann;
  window.__qBOP_boosterUp_m3s      = bo;
  window.__qBOP_chokeDownUp_m3s    = ch;
  window.__qBOP_killDownUp_m3s     = ki;
  window.__qBOP_totalUp_m3s        = ann + bo + ch + ki;
  window.__qBOP_boosterIntoRiser_m3s = 0;
  window.__qBOP_chokeDownIntoRiser_m3s = 0;
  window.__qBOP_killDownIntoRiser_m3s = 0;
}

function routeAnnulusFlowsWithLosses(dt_s){
  const M3_PER_GPM = 1/15850.323;

  // ============================================================================
  // INPUTS
  // ============================================================================
  const qDS  = (Q_DS || 0) * M3_PER_GPM;
  const qBO  = (Q_BO || 0) * M3_PER_GPM;
  const qTF  = (TOPFILL_ON ? (Q_TOPFILL||0) : 0) * M3_PER_GPM;
  const qCML = (typeof effective_Q_CML_gpm==='function' ? (effective_Q_CML_gpm()||0) : 0) * M3_PER_GPM;
  const qInflux = (typeof current_influx_m3s === 'number') ? Math.max(0, current_influx_m3s) : 0;
  const influxFeedsLossZones = formationFluidEnabled &&
    typeof formationFluidDepth_m === 'number' && formationFluidDepth_m >= BOP_DEPTH;
  const qInfluxBelow = influxFeedsLossZones ? qInflux : 0;
  const qInfluxAbove = Math.max(0, qInflux - qInfluxBelow);

  // Choke and Kill line flows
  const qChoke_m3s = (Q_CHOKE || 0) * M3_PER_GPM;
  const qKill_m3s = (Q_KILL || 0) * M3_PER_GPM;

  // Defaults for BOP mixing diagnostics (overwritten below)
  publishBopNodeContrib(0, 0, 0, 0);
  window.__qBOP_annulusToRiser_m3s = 0;
  window.__qRiserUp_m3s = 0;
  window.__qChokeUp_m3s = 0;
  window.__qKillUp_m3s = 0;
  window.__qBOP_boosterIntoRiser_m3s = 0;
  window.__qBOP_chokeDownIntoRiser_m3s = 0;
  window.__qBOP_killDownIntoRiser_m3s = 0;
  window.__qAnnDown_reachDepth_m = BOP_DEPTH;
  window.__qAnnDown_mw_ppg = null;
  window.__qAnnDown_breakdown = { booster: 0, choke: 0, kill: 0, topfill: 0 };
  window.__dsUpflowStopDepth_m = BOP_DEPTH;
  window.__dsFlux_m3s = Math.max(0, ((Q_DS || 0) * M3_PER_GPM) + qInflux);
  window.__lossAllocation = {
    fromDS: 0,
    fromBooster: 0,
    fromChoke: 0,
    fromKill: 0,
    fromTopFill: 0,
    fromKick: 0,
    fromStorage: 0
  };

  if (Array.isArray(lossZones)) {
    for (const z of lossZones) {
      if (!z) continue;
      z._downSupply_m3s = 0;
      z._dsSupply_m3s = 0;
    }
  }

  const chokeUpActive = CHOKE_LINE_OPEN && CHOKE_DIRECTION === 'UP';
  const killUpActive = KILL_LINE_OPEN && KILL_DIRECTION === 'UP';

  chokeSurfacePressure_calc_psi = null;
  killSurfacePressure_calc_psi = null;

  updateBopPressureMasterState(chokeUpActive, killUpActive);

  window.__CHOKE_PRESSURE_WARNING = null;
  window.__KILL_PRESSURE_WARNING = null;
  window.__Q_TOTAL_UP_m3s = 0;
  window.__Q_CHOKE_CALCULATED_m3s = 0;
  window.__Q_KILL_CALCULATED_m3s = 0;

  if (CHOKE_DIRECTION === 'UP' && !chokeUpActive) {
    Q_CHOKE = 0;
  }
  if (KILL_DIRECTION === 'UP' && !killUpActive) {
    Q_KILL = 0;
  }

  // Filtered demand wanted by the loss zone (use demand, not actual)
  const qDem = (typeof totalLossDemand_m3s==='function')
    ? totalLossDemand_m3s()
    : ((typeof totalLossRate_gpm==='function' ? totalLossRate_gpm() : 0) * M3_PER_GPM);

  const qLossActual = (typeof totalLossRate_gpm === 'function')
    ? (totalLossRate_gpm() || 0) * M3_PER_GPM
    : qDem;

  // ============================================================================
  // BOP CLOSED STATE - SEPARATE FLOW PATHS
  // ============================================================================
  if (BOP_CLOSED) {
    // When BOP is closed, riser is ISOLATED from below-BOP annulus
    // Only choke and kill lines can transfer fluid across BOP

    // === BELOW BOP (Isolated wellbore annulus) ===
    // Inputs: DS return, Kicks, Choke/Kill lines flowing DOWN
    // Outputs: Losses, Choke/Kill lines flowing UP

    let qIn_belowBOP = qDS + qInfluxBelow; // DS return + kicks enter below BOP

    // Add choke/kill lines flowing DOWN (pumping into wellbore)
    if (CHOKE_DIRECTION === "DOWN" && CHOKE_LINE_OPEN) qIn_belowBOP += qChoke_m3s;
    if (KILL_DIRECTION === "DOWN" && KILL_LINE_OPEN) qIn_belowBOP += qKill_m3s;

    // Track the mud weight being pushed down the stack so the annulus and
    // choke/kill upflow can mix with the correct composition (including
    // injected pills that differ from the annulus/kick blend).
    const qDown_choke = (CHOKE_DIRECTION === "DOWN" && CHOKE_LINE_OPEN) ? qChoke_m3s : 0;
    const qDown_kill  = (KILL_DIRECTION === "DOWN" && KILL_LINE_OPEN)  ? qKill_m3s  : 0;
    const downEffluentMW = (() => {
      const effChoke = (chokeGrid && chokeGrid.length)
        ? (chokeGrid[chokeGrid.length - 1] || MW_CHOKE)
        : MW_CHOKE;
      const effKill = (killGrid && killGrid.length)
        ? (killGrid[killGrid.length - 1] || MW_KILL)
        : MW_KILL;
      const qDownTotal = qDown_choke + qDown_kill;
      if (qDownTotal <= 1e-9) return null;
      return ((qDown_choke * effChoke) + (qDown_kill * effKill)) / qDownTotal;
    })();

    // Losses consume fluid from below-BOP annulus (can exceed instantaneous inflow)
    const qToLoss = qLossActual;
    const qStorageDraw_m3s = Math.max(0, qToLoss - Math.max(0, qIn_belowBOP));
    window.__lossStorageDraw_m3s = qStorageDraw_m3s;

    window.__lossAllocation = {
      fromDS: 0,
      fromBooster: 0,
      fromChoke: 0,
      fromKill: 0,
      fromTopFill: 0,
      fromKick: 0,
      fromStorage: qStorageDraw_m3s
    };

    // Available fluid to flow UP through choke/kill lines
    let qAvailable_belowBOP = Math.max(0, qIn_belowBOP - qToLoss);

    // === PRESSURE-DRIVEN UP FLOW CALCULATION ===
    // Use pressure balance solver to calculate actual flow rates through choke/kill lines
    // User-set flow rates (Q_CHOKE, Q_KILL) are IGNORED for UP direction
    // Flow is determined by pressure balance, not pump setting
    let qChoke_actual = 0, qKill_actual = 0;

    const BHP_at_BOP = pressureAtDepth(BOP_DEPTH);
    const flowDistribution = calculateUPFlowDistribution(qAvailable_belowBOP, BHP_at_BOP);

    qChoke_actual = flowDistribution.Q_choke_m3s;
    qKill_actual = flowDistribution.Q_kill_m3s;

    window.__qChokeUp_m3s = qChoke_actual;
    window.__qKillUp_m3s = qKill_actual;
    window.__qRiserUp_m3s = 0;

    const chokeActual_gpm = qChoke_actual * 15850.323;
    const killActual_gpm = qKill_actual * 15850.323;

    if (chokeUpActive) {
      Q_CHOKE = chokeActual_gpm;
    }
    if (killUpActive) {
      Q_KILL = killActual_gpm;
    }

    // Store calculated flow rates for UI display
    window.__Q_CHOKE_CALCULATED_m3s = qChoke_actual;
    window.__Q_KILL_CALCULATED_m3s = qKill_actual;

    // Check if requested pressures can be achieved (for user feedback)
    if (chokeUpActive) {
      const chokeMW = chokeGrid.length > 0 ? average(chokeGrid) : MW_CHOKE;
      const wetLen = chokeWetLength_m();
      const actualFriction = chokeFrictionPsiLength(wetLen, qChoke_actual);
      const actualHydro = PSI_COEF * chokeMW * wetLen;
      const actualSurfaceP = Math.max(0, BHP_at_BOP - actualHydro - actualFriction);
      chokeSurfacePressure_calc_psi = actualSurfaceP;
      if (chokeLineHasUserPressureControl()) {
        const target = CHOKE_PRESSURE_TARGET_psi;
        const pressureDiff = Math.abs(actualSurfaceP - target);
        if (pressureDiff > 50) {
          window.__CHOKE_PRESSURE_WARNING = `Target: ${target.toFixed(0)} psi, Actual: ${actualSurfaceP.toFixed(0)} psi`;
        }
      } else {
        CHOKE_PRESSURE_psi = actualSurfaceP;
      }
    } else if (CHOKE_DIRECTION === 'UP') {
      const chokeMW = chokeGrid.length > 0 ? average(chokeGrid) : MW_CHOKE;
      const wetLen = chokeWetLength_m();
      const staticSurface = Math.max(0, BHP_at_BOP - PSI_COEF * chokeMW * wetLen);
      chokeSurfacePressure_calc_psi = staticSurface;
      CHOKE_PRESSURE_psi = staticSurface;
    }

    if (killUpActive) {
      const killMW = killGrid.length > 0 ? average(killGrid) : MW_KILL;
      const wetLen = killWetLength_m();
      const actualFriction = killFrictionPsiLength(wetLen, qKill_actual);
      const actualHydro = PSI_COEF * killMW * wetLen;
      const actualSurfaceP = Math.max(0, BHP_at_BOP - actualHydro - actualFriction);
      killSurfacePressure_calc_psi = actualSurfaceP;
      if (killLineHasUserPressureControl()) {
        const target = KILL_PRESSURE_TARGET_psi;
        const pressureDiff = Math.abs(actualSurfaceP - target);
        if (pressureDiff > 50) {
          window.__KILL_PRESSURE_WARNING = `Target: ${target.toFixed(0)} psi, Actual: ${actualSurfaceP.toFixed(0)} psi`;
        }
      } else {
        KILL_PRESSURE_psi = actualSurfaceP;
      }
    } else if (KILL_DIRECTION === 'UP') {
      const killMW = killGrid.length > 0 ? average(killGrid) : MW_KILL;
      const wetLen = killWetLength_m();
      const staticSurface = Math.max(0, BHP_at_BOP - PSI_COEF * killMW * wetLen);
      killSurfacePressure_calc_psi = staticSurface;
      KILL_PRESSURE_psi = staticSurface;
    }

    // Flow reaching surface through choke/kill lines
    const qToSurface_belowBOP = qChoke_actual + qKill_actual;
    // All upflow while BOP is closed originates from the annulus below
    publishBopNodeContrib(qToSurface_belowBOP, 0, 0, 0);
    window.__qBOP_annulusToRiser_m3s = 0;
    window.__qBOP_boosterIntoRiser_m3s = Math.max(0, qBO);
    window.__qBOP_chokeDownIntoRiser_m3s = 0;
    window.__qBOP_killDownIntoRiser_m3s = 0;
    window.__Q_TOTAL_UP_m3s = qToSurface_belowBOP;

    // Publish downward injection so advection and hydrostatic use the injected mud
    // weight (important when pumping a different MW pill while closed in).
    const qDown_total = qDown_choke + qDown_kill;
    window.__qAnnDown_m3s = qDown_total;
    window.__qAnnDown_reachDepth_m = BOP_DEPTH;
    window.__qAnnDown_mw_ppg = (downEffluentMW != null && isFinite(downEffluentMW))
      ? downEffluentMW
      : null;
    window.__qAnnDown_breakdown = { booster: 0, choke: qDown_choke, kill: qDown_kill, topfill: 0 };

    // === CLOSED WELL PHYSICS ===
    // When pumping to a closed well (no UP path, more IN than losses), pressure builds
    const netVolumeChange_m3s = qIn_belowBOP - qToLoss - qToSurface_belowBOP;
    if (closedWellCompressionActive()) {
      applyClosedWellCompression(netVolumeChange_m3s, dt_s, 'BOP SHUT');
    } else {
      bleedClosedWellPressure(dt_s);
    }

    // === ABOVE BOP (Isolated riser) ===
    // Inputs: Booster, TopFill
    // Outputs: CML, Flow Out (if riser full)

    let qIn_aboveBOP = qBO + qTF; // Booster and TopFill enter riser from surface
    let qOut_aboveBOP = qCML; // CML removes from riser

    const qNet_riser = qIn_aboveBOP - qOut_aboveBOP;

    // Publish separated flows for friction calculation
      window.__qToLoss_m3s = qToLoss;
      window.__qAnnBelow_m3s = Math.max(0, qIn_belowBOP - qToLoss - qToSurface_belowBOP); // Net upward in annulus below BOP
      window.__qAnnAbove_m3s = qNet_riser; // Net flow in riser
      window.__qAnnUp_m3s = qToSurface_belowBOP; // Flow through choke/kill lines
      window.__qAnnDown_m3s = qDown_total; // Downward injections crossing the stack

    // Flow Out calculation - from choke/kill lines
    const targetFO_gpm = Math.max(0, qToSurface_belowBOP * 15850.323);

    // Update FLOW_OUT with fast filter (line flow only when surface path exists)
    const ALPHA = 0.5;
    const DQDT_MAX = 1000;
    const prev = (typeof FLOW_OUT_gpm==='number') ? FLOW_OUT_gpm : 0;
    const lp = prev + ALPHA*(targetFO_gpm - prev);
    const dtSmooth = Math.max(window.dt_s || 1/60, 1/120);
    const maxStep = DQDT_MAX * dtSmooth;
    const step = Math.max(-maxStep, Math.min(maxStep, lp - prev));
    FLOW_OUT_gpm = prev + step;
    if (targetFO_gpm < 1e-3) {
      FLOW_OUT_gpm = 0;
    }

    if (typeof FLOW_OUT_ALPHA==='number') {
      window.FLOW_OUT_smooth = (window.FLOW_OUT_smooth||0) + FLOW_OUT_ALPHA*(FLOW_OUT_gpm - (window.FLOW_OUT_smooth||0));
    }

    return; // Exit early for BOP closed state
  }

  // ============================================================================
  // BOP OPEN STATE - NORMAL FLOW ROUTING
  // ============================================================================

  // ‚úÖ NEW: Add choke/kill DOWN flows to supply when BOP is open
  const qChoke_down = (CHOKE_LINE_OPEN && CHOKE_DIRECTION === "DOWN") ? qChoke_m3s : 0;
  const qKill_down = (KILL_LINE_OPEN && KILL_DIRECTION === "DOWN") ? qKill_m3s : 0;
  const mpdSurfaceSeal = mpdSealActive();

  // Supply that can feed losses from downhole side (no surface returns here)
  // We allow DS + Booster + TopFill + Choke/Kill DOWN to feed the zone; subtract CML intake
  let qSupply = Math.max(0, qDS + qInfluxBelow + qBO + qTF + qChoke_down + qKill_down - qCML);

  const qToLoss = qLossActual;
  const qSupplyForLoss = Math.min(qSupply, qToLoss);
  const qStorageDraw_m3s = Math.max(0, qToLoss - qSupplyForLoss);
  window.__lossStorageDraw_m3s = qStorageDraw_m3s;

  // How to source qToLoss: prefer Booster + Choke/Kill (downward) while level below surface,
  // then DS, then TopFill; this ensures downward flows go DOWN to the zone when not full.
  const connectedTopDepth = (typeof surfaceColumnTopDepth === 'function')
    ? surfaceColumnTopDepth()
    : ((typeof annulusTopDepthGlobal === 'function') ? annulusTopDepthGlobal() : (LOSS_TOP_DEPTH_m || 0));
  const riserFull = connectedTopDepth <= 0.5;

  let takeBO = 0, takeDS = 0, takeTF = 0, takeChoke = 0, takeKill = 0;
  let takeKick = 0;
  let kickAvail = qInfluxBelow;

  if (!riserFull) {
    // prioritize booster + choke/kill ‚Üí DS ‚Üí TF to feed the loss zone
    takeBO = Math.min(qBO, qToLoss);                // booster down first
    let rem = qToLoss - takeBO;
    takeChoke = Math.min(qChoke_down, rem);         // then choke down
    rem = rem - takeChoke;
    takeKill = Math.min(qKill_down, rem);           // then kill down
    rem = rem - takeKill;
    const dsKickAvail = Math.max(0, qDS + kickAvail);
    const dsKickTake = Math.min(dsKickAvail, rem);
    if (dsKickTake > 0) {
      const kickShare = Math.min(kickAvail, dsKickTake);
      if (kickShare > 0) {
        takeKick += kickShare;
        kickAvail -= kickShare;
      }
      takeDS = dsKickTake - kickShare;
      rem -= dsKickTake;
    }
    takeTF = Math.min(qTF, rem);                    // then topfill
  } else {
    // riser full: let DS/TF supply zone first; booster and choke/kill contribute to returns
    const dsKickTake = Math.min(Math.max(0, qDS + kickAvail), qToLoss);
    let rem = qToLoss - dsKickTake;
    if (dsKickTake > 0) {
      const kickShare = Math.min(kickAvail, dsKickTake);
      if (kickShare > 0) {
        takeKick += kickShare;
        kickAvail -= kickShare;
      }
      takeDS = dsKickTake - kickShare;
    }
    takeTF = Math.min(qTF, rem);
    rem = rem - takeTF;
    takeBO = Math.min(qBO, rem);
    rem = rem - takeBO;
    takeChoke = Math.min(qChoke_down, rem);
    rem = rem - takeChoke;
    takeKill = Math.min(qKill_down, rem);
  }

  // Leftovers after feeding losses
  const DS_left = Math.max(0, qDS - takeDS);
  const Kick_left = Math.max(0, qInfluxBelow - takeKick);
  const BO_left = Math.max(0, qBO - takeBO);
  const TF_left = Math.max(0, qTF - takeTF);
  const Choke_left = Math.max(0, qChoke_down - takeChoke);
  const Kill_left = Math.max(0, qKill_down - takeKill);

  const qDownTotal = takeBO + takeChoke + takeKill + takeTF;

  const boosterEffluentMW = (boosterGrid && boosterGrid.length)
    ? (boosterGrid[boosterGrid.length - 1] || MW_BO)
    : MW_BO;
  const chokeEffluentMW = (chokeGrid && chokeGrid.length)
    ? (chokeGrid[chokeGrid.length - 1] || MW_CHOKE)
    : MW_CHOKE;
  const killEffluentMW = (killGrid && killGrid.length)
    ? (killGrid[killGrid.length - 1] || MW_KILL)
    : MW_KILL;
  const riserAtBopMW = (annAboveGrid && annAboveGrid.length)
    ? (annAboveGrid[annAboveGrid.length - 1] || MW_DS)
    : MW_DS;

  let downMixMW_ppg = null;
  if (qDownTotal > 1e-9) {
    const weighted = (takeBO * boosterEffluentMW)
      + (takeChoke * chokeEffluentMW)
      + (takeKill * killEffluentMW)
      + (takeTF * MW_TOPFILL);
    downMixMW_ppg = weighted / qDownTotal;
  }

  window.__qAnnDown_mw_ppg = (downMixMW_ppg != null && isFinite(downMixMW_ppg)) ? downMixMW_ppg : null;
  window.__qAnnDown_breakdown = { booster: takeBO, choke: takeChoke, kill: takeKill, topfill: takeTF };
  window.__lossAllocation = {
    fromDS: takeDS,
    fromBooster: takeBO,
    fromChoke: takeChoke,
    fromKill: takeKill,
    fromTopFill: takeTF,
    fromKick: takeKick,
    fromStorage: Math.max(0, qToLoss - (takeDS + takeBO + takeChoke + takeKill + takeTF + takeKick))
  };

  const zonesBelow = Array.isArray(lossZones)
    ? lossZones.filter(z => z && z.enabled && z.depth_m > BOP_DEPTH && (z.Qloss_gpm || 0) > 0)
    : [];

  zonesBelow.sort((a, b) => a.depth_m - b.depth_m);
  let downReachDepth_m = BOP_DEPTH;
  let downRemaining = qDownTotal;
  for (const z of zonesBelow) {
    const zoneLoss_m3s = Math.max(0, (z.Qloss_gpm || 0) * M3_PER_GPM);
    if (zoneLoss_m3s <= 0 || downRemaining <= 1e-9) {
      z._downSupply_m3s = 0;
      continue;
    }
    const share = Math.min(downRemaining, zoneLoss_m3s);
    z._downSupply_m3s = share;
    downRemaining -= share;
    if (share > 1e-9) {
      downReachDepth_m = Math.max(downReachDepth_m, z.depth_m);
    }
  }

  const qDS_m3s = (Q_DS || 0) * M3_PER_GPM;
  const qBitFlux_m3s = Math.max(0, qDS_m3s + qInflux);
  let dsStopDepth_m = BOP_DEPTH;
  let dsRemaining = takeDS;
  const zonesBelowDesc = [...zonesBelow].sort((a, b) => b.depth_m - a.depth_m);
  for (const z of zonesBelowDesc) {
    const zoneLoss_m3s = Math.max(0, (z.Qloss_gpm || 0) * M3_PER_GPM);
    const unmet = Math.max(0, zoneLoss_m3s - (z._downSupply_m3s || 0));
    if (unmet <= 0 || dsRemaining <= 1e-9) {
      z._dsSupply_m3s = z._dsSupply_m3s || 0;
      continue;
    }
    const share = Math.min(dsRemaining, unmet);
    z._dsSupply_m3s = share;
    dsRemaining -= share;
  }
  if (takeDS >= qDS_m3s - 1e-9) {
    const dsZones = zonesBelow.filter(z => (z._dsSupply_m3s || 0) > 1e-9);
    if (dsZones.length) {
      dsStopDepth_m = Math.min(...dsZones.map(z => z.depth_m));
    }
  }

  window.__qAnnDown_reachDepth_m = downReachDepth_m;
  window.__dsUpflowStopDepth_m = dsStopDepth_m;
  window.__dsFlux_m3s = qBitFlux_m3s;

  // ‚úÖ KICK INFLUX: Add formation fluid influx to upward flow
  // Kicks enter the wellbore and flow upward, contributing to surface returns

  // Upward annulus flow contributor
  // - If riser full: everything goes up to surface
  // - If riser NOT full but NO losses (takeBO=0): booster/choke/kill goes UP to fill riser
  // - If riser NOT full AND losses active (takeBO>0): booster/choke/kill goes DOWN, rest goes UP
  // - KICKS always flow upward (added to upward flow)
  //
  // ‚úÖ AUTOMATIC REVERSAL:
  // If pressure doesn't allow downward flow (BHP < Pfrac at loss zone),
  // the zone deactivates (dP < 0 triggers hysteresis), qToLoss ‚Üí 0, takeBO/takeChoke/takeKill ‚Üí 0,
  // and leftovers route upward via this logic. This increases riser hydrostatic until new equilibrium.
  // Any portion of the down-going supply that wasn't consumed by losses
  // is what actually backs up into the riser.  Treat those leftovers as
  // true upward contributors so the riser fills with the fluid that was
  // pumped, not with whatever mud happened to be there previously.
  const boosterUpToSurface = BO_left;
  const chokeDownUpToSurface = Choke_left;
  const killDownUpToSurface = Kill_left;

  let qAnnUp = DS_left + TF_left + boosterUpToSurface +
               chokeDownUpToSurface + killDownUpToSurface + Kick_left + qInfluxAbove;

  const qAnnulusToSurface = Math.max(0, qAnnUp - boosterUpToSurface -
    chokeDownUpToSurface - killDownUpToSurface);
  publishBopNodeContrib(qAnnulusToSurface, boosterUpToSurface,
    chokeDownUpToSurface, killDownUpToSurface);

  // === MULTI-PATH UP FLOW WHEN BOP OPEN + CHOKE/KILL LINES ALSO UP ===
  // If choke/kill lines are open for UP flow when BOP is also open,
  // use pressure balance to distribute flow across riser + choke + kill paths
  const hasChokeUP = CHOKE_LINE_OPEN && CHOKE_DIRECTION === 'UP';
  const hasKillUP = KILL_LINE_OPEN && KILL_DIRECTION === 'UP';

  if (hasChokeUP || hasKillUP) {
    // Use pressure balance solver to distribute upward flow
    const BHP_at_BOP = pressureAtDepth(BOP_DEPTH);
    const flowDistribution = calculateUPFlowDistribution(qAnnUp, BHP_at_BOP);

    // Flow through riser (most of it will go here due to lower resistance)
    const Q_riser_actual = flowDistribution.Q_riser_m3s;
    const Q_choke_actual = flowDistribution.Q_choke_m3s;
    const Q_kill_actual = flowDistribution.Q_kill_m3s;

    // Update qAnnUp to reflect only riser flow (choke/kill bypass the riser)
    qAnnUp = Q_riser_actual;

    window.__qRiserUp_m3s = Q_riser_actual;
    window.__qChokeUp_m3s = hasChokeUP ? Q_choke_actual : 0;
    window.__qKillUp_m3s = hasKillUP ? Q_kill_actual : 0;

    const totalOutletFlow = Math.max(Q_riser_actual + Q_choke_actual + Q_kill_actual, 0);
    const riserShare = totalOutletFlow > 1e-9 ? (Q_riser_actual / totalOutletFlow) : 0;

    const annulusToRiser = Math.max(0, qAnnulusToSurface * riserShare);
    const boosterToRiser = Math.max(0, boosterUpToSurface * riserShare);
    const chokeDownToRiser = Math.max(0, chokeDownUpToSurface * riserShare);
    const killDownToRiser = Math.max(0, killDownUpToSurface * riserShare);

    window.__qBOP_annulusToRiser_m3s = annulusToRiser;
    window.__qBOP_boosterIntoRiser_m3s = boosterToRiser;
    window.__qBOP_chokeDownIntoRiser_m3s = chokeDownToRiser;
    window.__qBOP_killDownIntoRiser_m3s = killDownToRiser;

    // Store calculated choke/kill flows
    window.__Q_CHOKE_CALCULATED_m3s = Q_choke_actual;
    window.__Q_KILL_CALCULATED_m3s = Q_kill_actual;

    // Total flow out includes riser + choke + kill paths
    window.__Q_TOTAL_UP_m3s = Q_riser_actual + Q_choke_actual + Q_kill_actual;

    if (hasChokeUP) {
      const chokeActual_gpm = Q_choke_actual * 15850.323;
      Q_CHOKE = chokeActual_gpm;

      const chokeMW = chokeGrid.length > 0 ? average(chokeGrid) : MW_CHOKE;
      const wetLen = chokeWetLength_m();
      const friction = chokeFrictionPsiLength(wetLen, Q_choke_actual);
      const hydro = PSI_COEF * chokeMW * wetLen;
      const actualSurface = Math.max(0, BHP_at_BOP - hydro - friction);
      chokeSurfacePressure_calc_psi = actualSurface;
      if (chokeLineHasUserPressureControl()) {
        const target = CHOKE_PRESSURE_TARGET_psi;
        if (Math.abs(actualSurface - target) > 50) {
          window.__CHOKE_PRESSURE_WARNING = `Target: ${target.toFixed(0)} psi, Actual: ${actualSurface.toFixed(0)} psi`;
        }
      } else {
        CHOKE_PRESSURE_psi = actualSurface;
      }
    } else if (CHOKE_DIRECTION === 'UP') {
      const chokeMW = chokeGrid.length > 0 ? average(chokeGrid) : MW_CHOKE;
      const wetLen = chokeWetLength_m();
      const staticSurface = Math.max(0, BHP_at_BOP - PSI_COEF * chokeMW * wetLen);
      chokeSurfacePressure_calc_psi = staticSurface;
      CHOKE_PRESSURE_psi = staticSurface;
    }

    if (hasKillUP) {
      const killActual_gpm = Q_kill_actual * 15850.323;
      Q_KILL = killActual_gpm;

      const killMW = killGrid.length > 0 ? average(killGrid) : MW_KILL;
      const wetLen = killWetLength_m();
      const friction = killFrictionPsiLength(wetLen, Q_kill_actual);
      const hydro = PSI_COEF * killMW * wetLen;
      const actualSurface = Math.max(0, BHP_at_BOP - hydro - friction);
      killSurfacePressure_calc_psi = actualSurface;
      if (killLineHasUserPressureControl()) {
        const target = KILL_PRESSURE_TARGET_psi;
        if (Math.abs(actualSurface - target) > 50) {
          window.__KILL_PRESSURE_WARNING = `Target: ${target.toFixed(0)} psi, Actual: ${actualSurface.toFixed(0)} psi`;
        }
      } else {
        KILL_PRESSURE_psi = actualSurface;
      }
    } else if (KILL_DIRECTION === 'UP') {
      const killMW = killGrid.length > 0 ? average(killGrid) : MW_KILL;
      const wetLen = killWetLength_m();
      const staticSurface = Math.max(0, BHP_at_BOP - PSI_COEF * killMW * wetLen);
      killSurfacePressure_calc_psi = staticSurface;
      KILL_PRESSURE_psi = staticSurface;
    }
  } else {
    // No choke/kill lines open for UP, all flow through riser
    window.__Q_CHOKE_CALCULATED_m3s = 0;
    window.__Q_KILL_CALCULATED_m3s = 0;
    window.__Q_TOTAL_UP_m3s = qAnnUp;
    window.__qRiserUp_m3s = qAnnUp;
    window.__qChokeUp_m3s = 0;
    window.__qKillUp_m3s = 0;
    window.__qBOP_annulusToRiser_m3s = qAnnulusToSurface;
    window.__qBOP_boosterIntoRiser_m3s = boosterUpToSurface;
    window.__qBOP_chokeDownIntoRiser_m3s = chokeDownUpToSurface;
    window.__qBOP_killDownIntoRiser_m3s = killDownUpToSurface;
  }

  // ‚úÖ CRITICAL FIX: Separate flows for friction calculation
  // BELOW BOP (casing/openhole): DS return + KICK INFLUX
  // DS goes down drillstring, returns up annulus below BOP (minus losses consumed)
  // Kicks enter below BOP and flow upward
  const qAnnBelow = qDS - takeDS + qInflux;  // DS return + influx

  // ABOVE BOP (riser): DS + Booster + KICK (after passing through BOP)
  // This is already correctly calculated as qAnnUp
  const qAnnAbove = qAnnUp;  // DS_left + TF_left + BO_left + qInflux (when riser full or no losses)

  // Downward flow component (for advection direction tracking)
  const qAnnDown = qDownTotal; // total downward supply feeding losses

  // Publish clean section "signals" (magnitudes, signless)
  window.__qToLoss_m3s   = qToLoss;
  window.__qAnnUp_m3s    = qAnnUp;
  window.__qAnnDown_m3s  = qAnnDown;

  // ‚úÖ CRITICAL: Publish correct flows for friction calculation
  // These represent actual flow through each annulus section:
  // - Below BOP: Only DS return (through casing/OH geometry)
  // - Above BOP: DS + Booster combined (through riser geometry)
  window.__qAnnAbove_m3s = qAnnAbove;  // DS+BO through riser
  window.__qAnnBelow_m3s = qAnnBelow;  // Only DS through casing/OH

  // ------------------- Stable FLOW_OUT with hysteresis -------------------
  const top = (typeof surfaceColumnTopDepth === 'function')
    ? surfaceColumnTopDepth()
    : ((typeof annulusTopDepthGlobal === 'function') ? annulusTopDepthGlobal() : 0);
  const HYST_UP = 0.25, HYST_DN = 0.75;
  if (typeof routeAnnulusFlowsWithLosses._full === 'undefined'){
    routeAnnulusFlowsWithLosses._full = (top <= HYST_UP);
  }
  const wasFull = routeAnnulusFlowsWithLosses._full;
  const nowFull = wasFull ? (top <= HYST_DN) : (top <= HYST_UP);
  routeAnnulusFlowsWithLosses._full = nowFull;

  // If riser full, surface return equals upward annulus flow; otherwise zero
  const totalUp_m3s = window.__Q_TOTAL_UP_m3s || 0;
  const chokeUp_m3s = window.__Q_CHOKE_CALCULATED_m3s || 0;
  const killUp_m3s = window.__Q_KILL_CALCULATED_m3s || 0;
  const riserUp_m3s = Math.max(0, totalUp_m3s - (chokeUp_m3s + killUp_m3s));

  let targetFO_m3s = 0;
  const lineUp_m3s = chokeUp_m3s + killUp_m3s;
  if (lineUp_m3s > 1e-6) {
    targetFO_m3s += lineUp_m3s;
  }
  if (nowFull) {
    targetFO_m3s += riserUp_m3s;
  }

  if (mpdSurfaceSeal) {
    targetFO_m3s = 0;
  }

  const targetFO_gpm = Math.max(0, targetFO_m3s * 15850.323);

  // Debug FO calculation disabled (too verbose)
  // if (frameCount % 150 === 0) {
  //   console.log(`[FO_DEBUG] top=${top.toFixed(2)}m, wasFull=${wasFull}, nowFull=${nowFull}, qAnnUp=${(qAnnUp*15850.323).toFixed(1)} gpm, targetFO=${targetFO_gpm.toFixed(1)} gpm, FLOW_OUT=${(FLOW_OUT_gpm||0).toFixed(1)} gpm`);
  // }

  // Fast response for conventional circulation (no losses)
  // Slow response during losses to avoid oscillations
  const lossesActive = LOSSES_ON && qToLoss > 1e-6;
  const ALPHA = lossesActive ? 0.25 : 0.8;  // Fast filter when no losses
  const DQDT_MAX = lossesActive ? 800 : 5000; // Fast slew when no losses

    if (mpdSurfaceSeal) {
      FLOW_OUT_gpm = 0;
    } else {
      const prev = (typeof FLOW_OUT_gpm==='number') ? FLOW_OUT_gpm : 0;
      const lp   = prev + ALPHA*(targetFO_gpm - prev);
      const maxStep = DQDT_MAX * Math.max(dt_s, 1/120);
      const step = Math.max(-maxStep, Math.min(maxStep, lp - prev));
      FLOW_OUT_gpm = prev + step;
      if (targetFO_gpm < 1e-3) {
        FLOW_OUT_gpm = 0;
      }
    }

  // Additional debug disabled (too verbose)
  // if (frameCount % 150 === 0 && Math.abs(targetFO_gpm - FLOW_OUT_gpm) > 10) {
  //   console.log(`[FO_DEBUG] Slewing: prev=${prev.toFixed(1)}, lp=${lp.toFixed(1)}, step=${step.toFixed(1)}, dt=${dt_s.toFixed(4)}s, maxStep=${maxStep.toFixed(1)}`);
  // }

  const qSurfaceActual_m3s = Math.max(0, (FLOW_OUT_gpm || 0)) * M3_PER_GPM;
  const qTotalIn_m3s = qDS + qBO + qTF + qChoke_down + qKill_down + qInflux;
  const qTotalOut_m3s = qToLoss + qCML + qSurfaceActual_m3s;
  const netVolumeChange_m3s = qTotalIn_m3s - qTotalOut_m3s;

  if (mpdSurfaceSeal) {
    applyClosedWellCompression(netVolumeChange_m3s, dt_s, 'RCD SEALED');
  } else if (!BOP_CLOSED) {
    bleedClosedWellPressure(dt_s);
    if (typeof window !== 'undefined') {
      window.__PRESSURE_COMPRESSION_WARNING = null;
    }
  }

  // Optional smoother you already have
  if (typeof FLOW_OUT_ALPHA==='number') {
    window.FLOW_OUT_smooth = (window.FLOW_OUT_smooth||0) + FLOW_OUT_ALPHA*(FLOW_OUT_gpm - (window.FLOW_OUT_smooth||0));
  }
}


/* ===================== GENERALIZED-NEWTONIAN LAMINAR PIPE FLOW ===================== */
// === Units ===
// dP_psi (psi), D_m (m), L_m (m)
// tauToShearRateFn: function( tau_Pa ) -> shear_rate [1/s]
// Returns: Q [m^3/s]
function laminarPipeFlow_GNF(dP_psi, D_m, L_m, tauToShearRateFn) {
  const PSI_TO_PA = 6894.757;
  const dP = Math.max(0, dP_psi) * PSI_TO_PA;   // Pa
  const D  = Math.max(1e-6, D_m);               // m
  const L  = Math.max(1e-6, L_m);               // m
  const R  = 0.5 * D;                           // m

  // Wall shear stress œÑ_w = (ŒîP * R) / (2 L) = ŒîP * D / (4 L)
  const tau_w = dP * D / (4 * L);               // Pa

  // Radial discretization for velocity integration
  const N = 96;                                 // increase for accuracy if needed
  const dr = R / N;
  const r = new Array(N + 1);
  for (let i = 0; i <= N; i++) r[i] = i * dr;

  // Shear rate profile Œ≥Ãá(r) from œÑ(r) = œÑ_w * r/R
  const gdot = new Array(N + 1);
  for (let i = 0; i <= N; i++) {
    const tau = tau_w * (r[i] / R);
    gdot[i] = Math.max(0, tauToShearRateFn(tau));
  }

  // Velocity profile: u(r) = ‚à´_{r}^{R} Œ≥Ãá(Œæ) dŒæ  (no-slip at wall: u(R)=0)
  const u = new Array(N + 1);
  u[N] = 0; // at r=R
  for (let i = N - 1; i >= 0; i--) {
    // Trapezoid for ‚à´ Œ≥Ãá dŒæ between r[i]..r[i+1]
    u[i] = u[i + 1] + 0.5 * (gdot[i] + gdot[i + 1]) * dr;
  }

  // Volumetric flow: Q = 2œÄ ‚à´_{0}^{R} u(r) r dr
  let Q = 0;
  for (let i = 0; i < N; i++) {
    const r1 = r[i], r2 = r[i + 1];
    const u1 = u[i], u2 = u[i + 1];
    const ring = 0.5 * (u1 * r1 + u2 * r2) * (r2 - r1); // trapezoid in r
    Q += ring;
  }
  Q *= 2 * Math.PI; // m^3/s
  return Math.max(0, Q);
}

// Bingham: œÑ = œÑy + ŒºP * Œ≥Ãá  ‚Üí  Œ≥Ãá = max(0, (œÑ - œÑy) / ŒºP)
function binghamFlow(dP_psi, D_m, L_m, tauY_Pa, muP_Pa_s) {
  const tauToShear = (tau) => (tau <= (tauY_Pa || 0)) ? 0 : (tau - (tauY_Pa || 0)) / Math.max(muP_Pa_s || 1e-9, 1e-9);
  return laminarPipeFlow_GNF(dP_psi, D_m, L_m, tauToShear);
}

// Power-Law: œÑ = K * Œ≥Ãá^n  ‚Üí  Œ≥Ãá = (œÑ / K)^(1/n)
function powerLawFlow(dP_psi, D_m, L_m, K_Pa_s_n, n_dim) {
  const n = Math.max(1e-6, n_dim || 1);
  const K = Math.max(1e-12, K_Pa_s_n || 1e-12);
  const tauToShear = (tau) => Math.pow(Math.max(tau, 0) / K, 1 / n);
  return laminarPipeFlow_GNF(dP_psi, D_m, L_m, tauToShear);
}

// Herschel‚ÄìBulkley: œÑ = œÑy + K * Œ≥Ãá^n  ‚Üí  Œ≥Ãá = ((œÑ - œÑy)/K)^(1/n) if œÑ>œÑy, else 0
function herschelBulkleyFlow(dP_psi, D_m, L_m, tauY_Pa, K_Pa_s_n, n_dim) {
  const n = Math.max(1e-6, n_dim || 1);
  const K = Math.max(1e-12, K_Pa_s_n || 1e-12);
  const tauY = Math.max(0, tauY_Pa || 0);
  const tauToShear = (tau) => (tau <= tauY) ? 0 : Math.pow((tau - tauY) / K, 1 / n);
  return laminarPipeFlow_GNF(dP_psi, D_m, L_m, tauToShear);
}

/* ===================== NEW PHYSICS: BHP-BASED WITH FRICTION REDISTRIBUTION ===================== */

// Calculate fracture friction: ŒîP caused by flow through fracture
function calculateFractureFriction_psi(qFrac_m3s, zone) {
  if (!zone || qFrac_m3s <= 0) return 0;

  const qFrac_gpm = qFrac_m3s * 15850.323;
  const n = zone.n || 1.0;

  // Use the calibrated ŒîP-Q curve for the fracture when it exists
  if (zone.Qref_gpm > 0 && zone.DPref_psi > 0) {
    const C_frac = zone.Qref_gpm / Math.pow(zone.DPref_psi, n);
    const denom = Math.max(C_frac, 1e-6);
    const ratio = Math.max(qFrac_gpm, 0) / denom;
    const raw = Math.pow(ratio, 1 / n);
    return smoothFrictionPsi(`loss_${zone.id || zone.depth_m || 0}`, raw);
  }

  // Fallback: treat fracture as a low-resistance annulus section (~20%)
  const depth_m = zone.depth_m;
  const qAbove_save = window.__qAnnAbove_m3s;
  window.__qAnnAbove_m3s = qFrac_m3s;
  const P_fric_ann_equiv = frictionPsi_withCML_rheo(depth_m);
  window.__qAnnAbove_m3s = qAbove_save;
  const fallback = P_fric_ann_equiv * 0.2;
  return smoothFrictionPsi(`loss_${zone.id || zone.depth_m || 0}`, fallback);
}

// Fast friction approximation for losses solver (trades accuracy for speed)
// Uses simple power-law: dP ~ K * Q^n instead of full GNF rheology
// This gives ~10x speedup in the iterative BHP solver with acceptable accuracy
function frictionPsi_fast(depth_m, q_m3s) {
  if (q_m3s < 1e-9 || depth_m < 1) return 0;

  const q_gpm = q_m3s * 15850.323;

  // Power-law exponent from current rheology
  const n = (typeof window.N_dim === 'number') ? window.N_dim : 0.7;

  // Calibrate K_approx based on actual friction at reference condition
  // Use memoization to avoid recalculating every call
  if (typeof frictionPsi_fast._K_ref === 'undefined' || (frameCount % 60) === 0) {
    // Recalibrate every second (60 frames)
    const q_ref_m3s = 1000 / 15850.323; // 1000 gpm reference
    window.__qAnnAbove_m3s = q_ref_m3s;
    window.__qAnnBelow_m3s = q_ref_m3s;
    const fric_ref = frictionPsi_withCML_rheo(TD_DEPTH || 4500);
    const q_ref_gpm = 1000;
    // dP_ref = K_approx * (q_ref_gpm)^n * depth
    // K_approx = dP_ref / (q_ref_gpm^n * depth)
    frictionPsi_fast._K_ref = fric_ref / (Math.pow(q_ref_gpm, n) * (TD_DEPTH || 4500));
  }

  const K_approx = frictionPsi_fast._K_ref || 0.00015; // Fallback

  const dP_psi = K_approx * Math.pow(q_gpm, n) * depth_m;

  return dP_psi;
}

function computeLossZoneBhpState(zone, qLoss_m3s, qIn_m3s) {
  if (!zone) {
    return {
      BHP: 0,
      qUp_m3s: 0,
      P_hydro: 0,
      P_fric_ann: 0,
      P_sbp: 0,
      P_fracFric: 0,
      residual: 0,
    };
  }

  const depth_m = zone.depth_m;
  const wetTop = annulusTopDepthGlobal();

  const depth_wet = Math.max(0, depth_m - wetTop);
  const ecd_ppg = ecdAtDepth(depth_m);
  const P_hydro = PSI_COEF * ecd_ppg * depth_wet;

  const qUp_m3s = Math.max(0, qIn_m3s - qLoss_m3s);
  const P_fric_ann = qUp_m3s > 1e-9 ? frictionPsi_fast(depth_m, qUp_m3s) : 0;
  const P_sbp = sbpAppliedPsi();

  const P_fracFric = calculateFractureFriction_psi(Math.max(0, qLoss_m3s), zone);
  const P_frac = zone.fracPressure_psi || 0;

  const BHP = P_hydro + P_fric_ann + P_sbp;
  const residual = BHP - P_frac - P_fracFric;

  return {
    BHP,
    qUp_m3s,
    P_hydro,
    P_fric_ann,
    P_sbp,
    P_fracFric,
    residual,
  };
}

// Calculate BHP at zone with flow split between annulus and fracture
// (legacy helper kept for compatibility ‚Äì returns hydro+annulus friction+SBP)
function calculateBHPWithLossSplit(zone, qLoss_m3s, qIn_m3s) {
  return computeLossZoneBhpState(zone, qLoss_m3s, qIn_m3s).BHP;
}

// Iteratively solve for loss rate where BHP balances at fracture pressure
// OPTIMIZED: Feedforward + reduced iterations + relaxed tolerance
function solveZoneLossEquilibrium(zone, qIn_m3s, dt_s) {
  if (!zone || !zone.enabled) return 0;

  const Pfrac = zone.fracPressure_psi || 0;
  const wetTop = annulusTopDepthGlobal();

  // Zone must be below fluid level
  if (zone.depth_m <= wetTop) return 0;

  // Check static condition (no flow)
  const BHP_static = calculateBHPWithLossSplit(zone, 0, 0);

  // OPTIMIZATION 1: Early exit if far below fracture pressure
  if (BHP_static < Pfrac - LOSS_DEADBAND_PSI) return 0;

  // SPECIAL CASE: Static overbalance
  // User physics: Level only drops if Hyd + ŒîP_frac + Friction_going_down > Pfrac
  // Check if we're in static overbalance case (no flow, but pressure > Pfrac)
  if (BHP_static > Pfrac && qIn_m3s < 1e-6) {
    // This means Hyd + SBP > Pfrac with no flow
    // This would cause level to drop, which removes SBP, causing oscillation
    //
    // SOLUTION: Override SBP to anchor at fracture pressure
    // This prevents the drop-lose-SBP-rise-gain-SBP oscillation cycle
    const depth_wet = Math.max(0, zone.depth_m - wetTop);
    const ecd_ppg = ecdAtDepth(zone.depth_m);
    const P_hydro = PSI_COEF * ecd_ppg * depth_wet;

    // Calculate friction of any flow going down (booster during losses)
    // If booster is pumping down, include its friction
    const qDown_m3s = window.__qAnnBelow_m3s || 0;

    // Calculate friction for downward flow
    const qBelow_save = window.__qAnnBelow_m3s;
    window.__qAnnBelow_m3s = qDown_m3s;
    const P_fric_down = qDown_m3s > 1e-6 ? frictionPsi_withCML_rheo(zone.depth_m) : 0;
    window.__qAnnBelow_m3s = qBelow_save;

    // SBP override: balance at Pfrac considering hydrostatic and friction going down
    // Pfrac = P_hydro + P_fric_down + P_sbp
    // P_sbp = Pfrac - P_hydro - P_fric_down - margin
    const SBP_override = Math.max(0, Pfrac - P_hydro - P_fric_down - 50); // 50 psi safety margin

    if (MPD_ON && wetTop <= 0.5) {
      CURRENT_SBP = SBP_override;
    }
    return 0; // No losses needed, system balanced
  }

  // OPTIMIZATION 2: Feedforward - start search near previous result
  const qLoss_prev_m3s = (typeof zone._Q_filt === 'number') ? zone._Q_filt / 15850.323 : 0;

  let qLoss_min, qLoss_max;
  if (qLoss_prev_m3s > 1e-6) {
    // Use previous result as starting point (bracket around it)
    qLoss_min = Math.max(0, qLoss_prev_m3s * 0.3);
    qLoss_max = Math.min(qIn_m3s * 10, qLoss_prev_m3s * 3.0);
  } else {
    // First time or was zero - use wide bracket
    qLoss_min = 0;
    qLoss_max = qIn_m3s * 10;
  }

  let qLoss_result = (qLoss_min + qLoss_max) / 2;

  // OPTIMIZATION 3: Fast iterations with approximation friction
  // Binary search with fast friction converges quickly: 5 iterations = 2^5 = 32x resolution
  // With feedforward and damping, typically converges in 2-3 iterations
  const MAX_ITERATIONS = 5; // Reduced from 6 for performance
  const TOLERANCE_PSI = 40; // Increased for stability - damping/filtering handle precision

  for (let iter = 0; iter < MAX_ITERATIONS; iter++) {
    const qLoss_trial = (qLoss_min + qLoss_max) / 2;
    const state = computeLossZoneBhpState(zone, qLoss_trial, qIn_m3s);
    const residual = state.residual;

    if (Math.abs(residual) < TOLERANCE_PSI) {
      qLoss_result = qLoss_trial;
      break; // OPTIMIZATION 5: Early exit on convergence
    }

    if (residual > 0) {
      // Hydro + annulus friction + SBP still exceed FracP + fracture friction ‚Üí increase qLoss
      qLoss_min = qLoss_trial;
    } else {
      // Net pressure is below the fracture requirement ‚Üí decrease qLoss so more flow reaches surface
      qLoss_max = qLoss_trial;
    }

    qLoss_result = (qLoss_min + qLoss_max) / 2;
  }

  // Apply zone capacity limit if calibrated
  // NOTE: dP_available uses BHP_static (no losses), so if BHP_static < Pfrac,
  //       capacity = 0, which allows RECOVERY from total losses when BHP drops
  if (zone.Qref_gpm > 0 && zone.DPref_psi > 0) {
    const n = zone.n || 1.0;
    const dP_available = Math.max(0, BHP_static - Pfrac);
    const C_L = zone.Qref_gpm / Math.pow(zone.DPref_psi, n);
    const Q_capacity_gpm = C_L * Math.pow(dP_available, n);
    const Q_capacity_m3s = Q_capacity_gpm / 15850.323;

    qLoss_result = Math.min(qLoss_result, Q_capacity_m3s);
  }

  // STABILITY: Blend with previous solution to reduce oscillation (0.7 = 70% new, 30% old)
  // This provides additional damping on top of the filtering in zoneLoss_gpm
  if (qLoss_prev_m3s > 1e-6) {
    const SOLVER_DAMPING = 0.7; // Tune between 0.5 (heavy damping) and 1.0 (no damping)
    qLoss_result = SOLVER_DAMPING * qLoss_result + (1 - SOLVER_DAMPING) * qLoss_prev_m3s;
  }

  return qLoss_result; // m3/s (recalculated every frame, allows dynamic response)
}

/* ===================== PER-ZONE LOSS (ATTENUATED) ===================== */
// UPDATED: Now uses BHP-based physics with friction redistribution
// Uses iterative solver to find equilibrium where BHP ‚âà Pfrac
// Returns gpm.

function zoneLoss_gpm(z, dt_s = 0.1){
  if (!z || !z.enabled || !(z.depth_m > 0)) return 0;

  const wetTop = annulusTopDepthGlobal();

  // Zone must be BELOW fluid level to be active
  if (z.depth_m <= wetTop) {
    z._Q_filt = 0;
    z.Qloss_gpm = 0;
    return 0;
  }

  // ============================================================================
  // NEW PHYSICS: Use iterative equilibrium solver
  // ============================================================================
  const qTopFill_m3s = (TOPFILL_ON ? (Q_TOPFILL || 0) : 0) / 15850.323;
  const qChokeDown_m3s = (CHOKE_LINE_OPEN && CHOKE_DIRECTION === "DOWN") ? ((Q_CHOKE || 0) / 15850.323) : 0;
  const qKillDown_m3s = (KILL_LINE_OPEN && KILL_DIRECTION === "DOWN") ? ((Q_KILL || 0) / 15850.323) : 0;
  const qInflux_m3s = Math.max(0, (typeof current_influx_m3s === 'number') ? current_influx_m3s : 0);
  const qIn_m3s = Math.max(0,
    ((Q_DS || 0) + (Q_BO || 0) - (Q_CML || 0)) / 15850.323
    + qTopFill_m3s + qChokeDown_m3s + qKillDown_m3s + qInflux_m3s
  );
  const qLoss_equilibrium_m3s = solveZoneLossEquilibrium(z, qIn_m3s, dt_s);
  const Q_target_gpm = qLoss_equilibrium_m3s * 15850.323;

  // ============================================================================
  // Apply filtering and slew limiting for stability
  // ============================================================================
  z._P_filt = (typeof z._P_filt === 'number') ? z._P_filt : 0;
  z._Q_filt = (typeof z._Q_filt === 'number') ? z._Q_filt : (z.Qloss_gpm || 0);

  const dt = Math.max(1e-3, dt_s);

  // Low-pass filter
  const Q_lpf = __lp(z._Q_filt, Q_target_gpm, dt, LOSS_Q_TAU_S);

  // Slew rate limiter
  const Q_slew = __slew(z._Q_filt, Q_lpf, LOSS_DQDT_MAX_GPM_S, dt);

  z._Q_filt = Math.max(0, Q_slew);
  z.Qloss_gpm = z._Q_filt;

  return z._Q_filt;
}

/* ===================== COUPLED LOSS SOLVER (ATTENUATED) ===================== */
// Iterates with relaxation, uses filtered per-zone losses. Returns total losses (gpm).
function solveCoupledLosses(dt_s = 0.1){
  if (!LOSSES_ON){ (lossZones||[]).forEach(z => { if (z){ z.Qloss_gpm = 0; z._Q_filt = 0; z._P_filt = 0; } }); return 0; }

  mapLossZonesToGrid?.();

  for (let it = 0; it < LOSS_SOLVER_MAX_IT; it++){
    // Recompute section flows (above/below) for friction using current losses
    recomputeAnnulusSectionFlowsForLosses();

    let maxDelta = 0;
    for (const z of (lossZones || [])){
      if (!z || !z.enabled){
        if (z){ z.Qloss_gpm = 0; z._Q_filt = 0; z._P_filt = 0; }
        continue;
      }

      // Attenuated per-zone loss (uses ŒîP deadband, LPFs, dQ/dt limiter)
      const Qnew = zoneLoss_gpm(z, dt_s);

      // Iterative relaxation (fixed-point stability)
      const Qupd = z.Qloss_gpm + LOSS_RELAX_PER_ITER * (Qnew - z.Qloss_gpm);
      const clipped = Math.max(0, Qupd);

      maxDelta = Math.max(maxDelta, Math.abs(clipped - z.Qloss_gpm));
      z.Qloss_gpm = clipped;   // published value used by the rest of the sim
      z._Q_filt   = clipped;   // keep filter state coherent with published value
    }

    if (maxDelta < LOSS_SOLVER_TOL_GPM) break;
  }

  // Final pass so the rest of the frame sees consistent section flows
  recomputeAnnulusSectionFlowsForLosses();

  return totalLossRate_gpm(); // gpm
}
// --- helpers used by the filter (place once, near utils) ---
function lp1(prev, x, alpha){ return prev + alpha * (x - prev); }
function slewLimit(prev, target, maxPerSec, dt){
  const maxStep = maxPerSec * dt, d = target - prev;
  return Math.abs(d) <= maxStep ? target : prev + Math.sign(d) * maxStep;
}

function smoothLossCommand(z, target_gpm, dt_s, qAvailable_gpm){
  if (!Number.isFinite(target_gpm)) target_gpm = 0;
  if (typeof z._Q_cmd !== 'number') {
    z._Q_cmd = Math.max(0, z._Q_filt || 0);
  }

  const tau = Math.max(LOSS_CMD_LPF_TAU_S, 1e-3);
  const alpha = 1 - Math.exp(-dt_s / tau);
  let cmd = z._Q_cmd + alpha * (target_gpm - z._Q_cmd);

  const maxStep = LOSS_CMD_SLEW_GPM_PER_S * dt_s;
  if (cmd > z._Q_cmd + maxStep) {
    cmd = z._Q_cmd + maxStep;
  } else if (cmd < z._Q_cmd - maxStep) {
    cmd = z._Q_cmd - maxStep;
  }

  if (Number.isFinite(qAvailable_gpm)) {
    cmd = Math.min(qAvailable_gpm, cmd);
  }

  cmd = Math.max(0, cmd);
  z._Q_cmd = cmd;
  return cmd;
}

// --- filtered loss-demand (define once) ---
function refreshLossDemandFiltered(dt_s){
  if (!LOSSES_ON || !Array.isArray(lossZones)) return;

  const ALPHA = 0.20;      // low-pass weight
  const DQDT_MAX = 600;    // gpm/s per zone

  for (const z of lossZones){
    if (!z || !z.enabled) continue;

    const P  = pressureAtDepth(z.depth_m);
    const dP = Math.max(0, (P - (z.fracPressure_psi||0)) - (LOSS_DEADBAND_PSI||0));
    const n  = (z.n != null ? z.n : 1.0);

    let Qdem_raw_gpm = 0;
    if (z.Qref_gpm > 0 && z.DPref_psi > 0){
      const C = z.Qref_gpm / Math.pow(z.DPref_psi, n);
      Qdem_raw_gpm = C * Math.pow(dP, n);
    } else {
      Qdem_raw_gpm = 1e6; // ‚Äúinfinite‚Äù/karst; slew will tame it
    }

    if (typeof z.Qdem_filt_gpm !== 'number') z.Qdem_filt_gpm = 0;

    const Q_lp     = lp1(z.Qdem_filt_gpm, Qdem_raw_gpm, ALPHA);
    const Q_smooth = slewLimit(z.Qdem_filt_gpm, Q_lp, DQDT_MAX, dt_s);

    z.Qdem_filt_gpm = Math.max(0, Q_smooth);
  }
}

// REPLACE the loss zone update section in your main loop/draw:

function updateAllLossZones(dt_s) {
  if (!LOSSES_ON || !lossZones) return;

  // Get active wet zones
  const fluidTop = annulusTopDepthGlobal();
  const activeZones = lossZones
    .filter(z => z && z.enabled && z.depth_m > 0 && z.depth_m > fluidTop)
    .sort((a, b) => a.depth_m - b.depth_m); // SHALLOWEST to DEEPEST for spatial processing

  if (activeZones.length === 0) {
    // All zones dry - decay to zero
    for (const z of lossZones.filter(z => z)) {
      const decay = Math.exp(-dt_s / 2.0);
      z._Q_filt = (z._Q_filt || 0) * decay;
      z._Q_vel = (z._Q_vel || 0) * decay;
      z.Qloss_gpm = z._Q_filt;
      z._Q_cmd = (z._Q_cmd || 0) * decay;
    }
    if (typeof window !== 'undefined') {
      window.sumLoss_gpm = 0;
      window.__lossZoneDiag = [];
    }
    return;
  }

  // Initialize zone states if needed
  for (const z of activeZones) {
    if (typeof z._active === 'undefined') z._active = false;
    if (typeof z._Q_filt === 'undefined') z._Q_filt = 0;
    if (typeof z._Q_vel === 'undefined') z._Q_vel = 0;
    if (typeof z._Q_cmd === 'undefined') z._Q_cmd = z._Q_filt || 0;
    if (typeof z._dP_filt === 'undefined') z._dP_filt = 0;
  }

  // ========================================================================
  // SPATIAL FLOW ROUTING: Track DS (upward) and Booster (downward) separately
  // ========================================================================
  const Q_DS_gpm = Q_DS || 0;
  const Q_BO_gpm = Q_BO || 0;
  const Q_TF_gpm = (TOPFILL_ON ? Q_TOPFILL : 0) || 0;
  const Q_CHOKE_DOWN_gpm = (CHOKE_LINE_OPEN && CHOKE_DIRECTION === 'DOWN') ? (Q_CHOKE || 0) : 0;
  const Q_KILL_DOWN_gpm  = (KILL_LINE_OPEN  && KILL_DIRECTION  === 'DOWN') ? (Q_KILL  || 0) : 0;
  const boosterDown = (fluidTop > 0.5);

  const influxFeedsLossZones = formationFluidEnabled &&
    typeof formationFluidDepth_m === 'number' && formationFluidDepth_m >= BOP_DEPTH;
  const qInfluxBelow_gpm = (influxFeedsLossZones && typeof current_influx_m3s === 'number')
    ? Math.max(0, current_influx_m3s * GPM_PER_M3S)
    : 0;

  const dsSupplyTotal_gpm = Q_DS_gpm;
  const kickSupplyTotal_gpm = qInfluxBelow_gpm;
  const totalDownInjection_gpm = Q_BO_gpm + Q_TF_gpm + Q_CHOKE_DOWN_gpm + Q_KILL_DOWN_gpm;
  const downInjectionAvailable_gpm = boosterDown ? totalDownInjection_gpm : 0;

  // Track total loss change for global rate limit
  let totalLossChange_gpm = 0;
  const lossDiag = [];

  // ========================================================================
  // Process zones from SHALLOW to DEEP (spatial order for downward booster flow)
  // ========================================================================
  for (const z of activeZones) {
    // Calculate zone capacity based on pressure
    const P_psi = pressureAtDepth(z.depth_m);
    const P_frac_psi = z.fracPressure_psi || 0;
    const dP_raw = P_psi - P_frac_psi;
    const tau = Math.max(LOSS_P_TAU_S, 0);
    if (tau > 0 && Number.isFinite(dt_s) && dt_s > 0) {
      const alpha = dt_s / (tau + dt_s);
      z._dP_filt = (z._dP_filt || 0) + alpha * (dP_raw - (z._dP_filt || 0));
    } else {
      z._dP_filt = dP_raw;
    }
    const dP = z._dP_filt;

    // === HYSTERESIS: Prevent chattering on/off ===
    if (!z._active) {
      if (dP < LOSS_ACTIVATION_HYST_PSI) {
        z.Qloss_gpm = 0;
        z._Q_filt = 0;
        z._Q_vel = 0;
        z._Q_cmd = 0;
        z._pendingNeed_gpm = 0;
        z._fromDownLines_gpm = 0;
        z._fromDS_gpm = 0;
        z._fromKick_gpm = 0;
        z._storageDraw_gpm = 0;
        z._lastOverbalance_psi = dP;
        continue;
      }
      z._active = true;
    } else {
      if (dP < -LOSS_DEACTIVATION_HYST_PSI) {
        z._active = false;
        const decay = Math.exp(-dt_s / 1.0);
        z._Q_filt *= decay;
        z._Q_vel *= decay;
        z.Qloss_gpm = z._Q_filt;
        z._Q_cmd = 0;
        z._pendingNeed_gpm = 0;
        z._fromDownLines_gpm = 0;
        z._fromDS_gpm = 0;
        z._fromKick_gpm = 0;
        z._storageDraw_gpm = 0;
        z._lastOverbalance_psi = dP;
        continue;
      }
    }

    // === Calculate zone capacity ===
    const n = z.n || 1.0;
    const dP_eff = Math.max(0, dP);

    let Q_capacity_gpm = 0;
    if (z.Qref_gpm > 0 && z.DPref_psi > 0) {
      const C_L = z.Qref_gpm / Math.pow(z.DPref_psi, n);
      Q_capacity_gpm = C_L * Math.pow(dP_eff, n);
    } else {
      Q_capacity_gpm = 10000;  // Karstic (large capacity)
    }

    // === SPATIAL FLOW AVAILABILITY ===
    // Target flow is purely physics-driven (capacity from ŒîP)
    const Q_target = Q_capacity_gpm;
    const Q_command = smoothLossCommand(z, Q_target, dt_s, null);

    // === ACCELERATION LIMITING (prevents spikes) ===
    const Q_current = z._Q_filt || 0;
    const Q_vel_current = z._Q_vel || 0;
    const Q_vel_desired = (Q_command - Q_current) / Math.max(dt_s, 0.01);

    const max_accel = LOSS_MAX_ACCEL_GPM_S2 * dt_s;
    const Q_vel_new = Math.max(
      Q_vel_current - max_accel,
      Math.min(Q_vel_current + max_accel, Q_vel_desired)
    );

    let Q_new = Q_current + Q_vel_new * dt_s;
    Q_new = Math.max(0, Math.min(Q_new, Q_command));

    // Track change
    const deltaQ = Math.abs(Q_new - z._Q_filt);
    totalLossChange_gpm += deltaQ;

    // Update zone state
    z._Q_vel = Q_vel_new;
    z._Q_filt = Q_new;
    z.Qloss_gpm = Q_new;
    z._pendingNeed_gpm = Q_new;
    z._fromDownLines_gpm = 0;
    z._fromDS_gpm = 0;
    z._fromKick_gpm = 0;
    z._storageDraw_gpm = 0;
    z._lastOverbalance_psi = dP;
  }

  // Allocate downward supply (booster/choke/kill/top-fill) shallow ‚Üí deep
  let downAvail_gpm = downInjectionAvailable_gpm;
  if (downAvail_gpm > 1e-9) {
    for (const z of activeZones) {
      if (z.depth_m < BOP_DEPTH) { z._fromDownLines_gpm = 0; continue; }
      const need = Math.max(0, z._pendingNeed_gpm || 0);
      if (need <= 0) { z._fromDownLines_gpm = 0; continue; }
      const take = Math.min(need, downAvail_gpm);
      z._fromDownLines_gpm = take;
      z._pendingNeed_gpm = need - take;
      downAvail_gpm -= take;
      if (downAvail_gpm <= 1e-6) break;
    }
  } else {
    for (const z of activeZones) {
      z._fromDownLines_gpm = 0;
    }
  }

  // Allocate upward supply (kick + drillstring) deep ‚Üí shallow
  let dsAvail_gpm = dsSupplyTotal_gpm;
  let kickAvail_gpm = kickSupplyTotal_gpm;
  const kickEntryDepth_m = (formationFluidEnabled && typeof formationFluidDepth_m === 'number')
    ? formationFluidDepth_m
    : null;
  const kickBelowBOP = kickEntryDepth_m != null && kickEntryDepth_m >= BOP_DEPTH;
  const zonesDescending = [...activeZones].sort((a, b) => b.depth_m - a.depth_m);
  for (const z of zonesDescending) {
    let need = Math.max(0, z._pendingNeed_gpm || 0);
    const canSeeKick = kickBelowBOP && kickEntryDepth_m != null && z.depth_m <= kickEntryDepth_m;
    let takeKick = 0;
    let takeDS = 0;
    if (need > 0 && canSeeKick && kickAvail_gpm > 0) {
      takeKick = Math.min(need, kickAvail_gpm);
      kickAvail_gpm -= takeKick;
      need -= takeKick;
    }
    if (need > 0 && dsAvail_gpm > 0) {
      takeDS = Math.min(need, dsAvail_gpm);
      dsAvail_gpm -= takeDS;
      need -= takeDS;
    }
    z._fromKick_gpm = takeKick;
    z._fromDS_gpm = takeDS;
    z._pendingNeed_gpm = need;
  }

  for (const z of activeZones) {
    const drawFromColumn_gpm = Math.max(0, z._pendingNeed_gpm || 0);
    z._storageDraw_gpm = drawFromColumn_gpm;
    lossDiag.push({
      depth_m: z.depth_m,
      overbalance_psi: z._lastOverbalance_psi || 0,
      qLoss_gpm: z.Qloss_gpm || 0,
      active: z._active === true,
      storageDraw_gpm: drawFromColumn_gpm,
      fromDownLines_gpm: z._fromDownLines_gpm || 0,
      fromDS_gpm: z._fromDS_gpm || 0,
      fromKick_gpm: z._fromKick_gpm || 0
    });
  }

  // === GLOBAL RATE LIMIT (prevents total system shock) ===
  if (totalLossChange_gpm > LOSS_GLOBAL_RATE_LIMIT * dt_s) {
    const scale = (LOSS_GLOBAL_RATE_LIMIT * dt_s) / totalLossChange_gpm;
    for (const z of activeZones) {
      if (z.Qloss_gpm > 0) {
        const oldQ = z._Q_filt;
        z._Q_filt = oldQ * scale;
        z.Qloss_gpm = z._Q_filt;
      }
    }
  }

  // Dry zones (above fluid level) - decay to zero
  for (const z of lossZones.filter(z => z && z.enabled && z.depth_m <= fluidTop)) {
    const decay = Math.exp(-dt_s / 2.0);
    z._Q_filt = (z._Q_filt || 0) * decay;
    z._Q_vel = (z._Q_vel || 0) * decay;
    z.Qloss_gpm = z._Q_filt;
    z._Q_cmd = (z._Q_cmd || 0) * decay;
  }

  const sumLoss_gpm = activeZones.reduce((s, z) => s + (z.Qloss_gpm || 0), 0);
  if (typeof window !== 'undefined') {
    window.sumLoss_gpm = sumLoss_gpm;
    window.__lossZoneDiag = lossDiag;
  }
}


// Call this INSTEAD OF individual zoneLoss_gpm calls:
// In your main loop, REPLACE:
//   for (const z of lossZones) { z.Qloss_gpm = zoneLoss_gpm(z, dt); }
// WITH:
//   updateAllLossZones(dt);
/* ===================== TOTAL & EXTRA ===================== */
function totalLossRate_gpm(){ return (lossZones || []).reduce((s,z)=>s+(z.Qloss_gpm||0),0); }
function totalLossDemand_m3s(){
  if (!LOSSES_ON || !lossZones) return 0;

  let demand_gpm = 0;

  for (const z of lossZones){
    if (!z || !z.enabled || !(z.depth_m > 0)) continue;

    // Skip dry zones
    const top = (typeof annulusTopDepthGlobal === 'function') ? annulusTopDepthGlobal() : 0;
    if (z.depth_m <= top) continue;

    const P_psi      = pressureAtDepth(z.depth_m);
    const P_frac_psi = z.fracPressure_psi || 0;
    const dP         = Math.max(0, P_psi - P_frac_psi - (LOSS_DEADBAND_PSI || 0));

    // Demand capacity based on injectivity (no qAvailable clamp)
    const n = z.n || 1.0;
    if (z.Qref_gpm > 0 && z.DPref_psi > 0){
      const C_L = z.Qref_gpm / Math.pow(z.DPref_psi, n);
      demand_gpm += C_L * Math.pow(dP, n);
    } else {
      // Karstic/infinite ‚Äì set a large number so deficit is driven by supply
      demand_gpm += 1e9; // effectively unbounded
    }
  }

  return demand_gpm / 15850.323; // -> m¬≥/s
}

// Composition-aware extraction at zone cell (called inside advection step)
// Replace extractLossFluidFromGrid with this improved version:
function extractLossFluidFromGrid(z, dt_s){
  if (!z.enabled || z.cellIdx < 0 || z.Qloss_gpm <= 0) return;
  
  const Q_m3s = z.Qloss_gpm / 15850.323;
  const Vloss = Q_m3s * dt_s;
  
  let A = 0, grid = null;
  if (z.section === 'riser'){ 
    A = A_riserAnn(); 
    grid = annAboveGrid; 
  } else if (z.section === 'casing'){ 
    A = A_casingAnn(); 
    grid = annBelowGrid; 
  } else { 
    A = A_openAnn(); 
    grid = annBelowGrid;
  }

  if (!grid || !grid.length) return;
  
  const i = Math.min(Math.max(0, z.cellIdx), grid.length-1);
  const Vcell = A * CELL_M;
  const fractionLost = Math.min(0.95, Vloss / Math.max(Vcell, 1e-9));

  // ‚úÖ Extract fluid from this specific cell only
  // The lost fluid "disappears" - reduce density slightly toward lighter neighbor
  // This simulates the cell partially draining
  const upwindIdx = Math.max(0, i - 1); // Fluid comes from below
  
  // Weighted average: keep most of current, blend slightly with upwind
  grid[i] = (1 - fractionLost * 0.5) * grid[i] + (fractionLost * 0.5) * grid[upwindIdx];
  
  // ‚úÖ The flow rate reduction is already handled in recomputeAnnulusSectionFlowsForLosses()
  // so the advection above this zone will automatically slow down
}

function effective_Q_CML_gpm(){
  if (!CML_ON) return 0;
  if (BOP_CLOSED) return 0;
  const intakeDepth = CML_DEPTH || 0;
  const annulusTop = annulusTopDepthGlobal();
  if (intakeDepth <= annulusTop) return 0; // intake ‚Äúin air‚Äù
  return Q_CML || 0;
}


function computeFlowOut_gpm(dt_s) {
  const top = annulusTopDepthGlobal();
  const riserAtSurface = (top <= 0.5);
  const riserAboveBOP = (top < BOP_DEPTH);
  const lossesActive = LOSSES_ON && totalLossRate_gpm() > 1.0;

  // ============================================================================
  // CRITICAL: 4-Layer FO Protection (from commit 19d8516)
  // ============================================================================

  // Check 1: Active losses and level not at surface ‚Üí FO must be zero
  if (lossesActive && !riserAtSurface) {
    FLOW_OUT_gpm = 0;
    FLOWOUT_VELOCITY_gpm_s = 0;
    return 0;
  }

  // Check 2: Level below BOP ‚Üí no returns possible
  if (!riserAboveBOP) {
    FLOW_OUT_gpm = 0;
    FLOWOUT_VELOCITY_gpm_s = 0;
    return 0;
  }

  // Check 3: If losses consuming >50% of flow ‚Üí FO must be zero
  const totalIn_gpm = (Q_DS || 0) + (Q_BO || 0);
  const lossRate_gpm = totalLossRate_gpm();
  if (lossRate_gpm > totalIn_gpm * 0.5) {
    FLOW_OUT_gpm = 0;
    FLOWOUT_VELOCITY_gpm_s = 0;
    return 0;
  }

  // Riser above BOP and no significant losses - calculate target
  // FIX: Use correct variable name - recomputeAnnulusSectionFlowsForLosses publishes to __qAnnAbove_m3s
  const qAnnUp_m3s = window.__qAnnAbove_m3s || 0;

  // Check 4: Sanity check on qAnnUp itself
  if (qAnnUp_m3s < 1e-9) {
    FLOW_OUT_gpm = 0;
    FLOWOUT_VELOCITY_gpm_s = 0;
    return 0;
  }

  let targetFO_gpm = qAnnUp_m3s * 15850.323;

  // CRITICAL SANITY CHECK: FO cannot exceed total inflow (reduced from 1.5x to 1.2x)
  const totalInflow_gpm = totalIn_gpm;
  const maxReasonableFO_gpm = totalInflow_gpm * 1.2;
  if (targetFO_gpm > maxReasonableFO_gpm) {
    console.warn(`FO explosion detected! targetFO=${targetFO_gpm.toFixed(0)} gpm, clamping to ${maxReasonableFO_gpm.toFixed(0)} gpm. qAnnUp=${qAnnUp_m3s.toFixed(4)}, loss=${lossRate_gpm.toFixed(0)}`);
    targetFO_gpm = maxReasonableFO_gpm;
  }
  
  // Current state
  const FO_current = FLOW_OUT_gpm || 0;
  const FO_vel_current = FLOWOUT_VELOCITY_gpm_s || 0;
  
  // Apply deadband
  const error = targetFO_gpm - FO_current;
  if (Math.abs(error) < FLOWOUT_DEADBAND_GPM) {
    // In deadband - decay velocity
    FLOWOUT_VELOCITY_gpm_s *= 0.95;
    FLOW_OUT_gpm += FLOWOUT_VELOCITY_gpm_s * dt_s;
    return FLOW_OUT_gpm;
  }
  
  // Desired velocity (with LPF)
  const tau = FLOWOUT_LPF_TAU;
  const alpha = Math.min(1.0, dt_s / (tau + dt_s));
  const FO_vel_desired = error / tau;
  
  // Acceleration limit
  const max_accel = FLOWOUT_MAX_ACCEL * dt_s;
  const FO_vel_new = Math.max(
    FO_vel_current - max_accel,
    Math.min(FO_vel_current + max_accel, FO_vel_desired)
  );
  
  // Integrate
  FLOWOUT_VELOCITY_gpm_s = FO_vel_new;
  FLOW_OUT_gpm = Math.max(0, FO_current + FO_vel_new * dt_s);
  
  // Optional smooth
  if (typeof FLOW_OUT_ALPHA === 'number') {
    window.FLOW_OUT_smooth = (window.FLOW_OUT_smooth || 0) + 
      FLOW_OUT_ALPHA * (FLOW_OUT_gpm - (window.FLOW_OUT_smooth || 0));
  }
  
  return FLOW_OUT_gpm;
}
// Run the coupled loss solver and get instantaneous losses (gpm)


function chokeCv(pct){
  const p = Math.max(0, Math.min(1, pct/100));
  return CHOKE_CV_MAX * (1 - Math.exp(-CHOKE_K * p)) / (1 - Math.exp(-CHOKE_K));
}
function updateChokeFromFO(){
  const sbpPsi = sbpAppliedPsi();
  if (!MPD_ON || FLOW_OUT_gpm < 1 || sbpPsi < 1){ CHOKE_POS_pct = 0; return 0; }
  const SG = rhoDynamic()/1000;
  const Cv_req = FLOW_OUT_gpm / Math.sqrt(Math.max(sbpPsi/Math.max(SG,0.7), 1e-6));
  let best = 0;
  for (let p=0; p<=100; p+=0.5){ if (chokeCv(p) >= Cv_req){ best = p; break; } }
  if (chokeCv(100) < Cv_req) best = 100;
  CHOKE_POS_pct = 0.85*CHOKE_POS_pct + 0.15*best;
  return CHOKE_POS_pct;
}

 // === LEVEL / MASS-BALANCE CORE (drop-in) ===
// Drives ANN_TOP_DEPTH_m using inflows, top fill, CML, surface outflow,
// *and* loss demand that can exceed inflow (deficit drains the annulus).

// Helper: area at the current free surface (uses your existing A_* funcs)
function annulusAreaAtTop(){
  const top = annulusTopDepthGlobal ? annulusTopDepthGlobal() : (LOSS_TOP_DEPTH_m || 0);
  if (top <= BOP_DEPTH)  return A_riserAnn();
  if (top <= SHOE_DEPTH) return A_casingAnn();
  return A_openAnn();
}

// --- Simple exponential low-pass (single-pole): y += a*(x - y), a in (0,1]
function lp1(prev, x, alpha){ return prev + alpha * (x - prev); }

// --- Slew limiter (caps rate of change): max |Œî per second|
function slewLimit(prev, target, maxPerSec, dt){
  const maxStep = maxPerSec * dt;
  const d = target - prev;
  if (Math.abs(d) <= maxStep) return target;
  return prev + Math.sign(d) * maxStep;
}

// --- BOP-closed line volume buffers ---------------------------------------
function pipeArea_m2(diameter_m){
  const dia = Math.max(Number(diameter_m) || 0, 0);
  if (dia <= 0) return 0;
  return Math.PI * dia * dia / 4;
}

function closedBopLineBuffers(){
  if (!BOP_CLOSED) return [];
  const buffers = [];

  // Even if a choke/kill valve is shut at surface, the trapped column between
  // the BOP and that valve is still part of the closed system.  When losses are
  // active the column should drain before the isolated annulus level moves, so
  // treat any existing line as an available buffer whenever the stack is shut.
  const addBuffer = (name, shouldInclude, diameter_m, readFn, writeFn) => {
    if (!shouldInclude) return;
    const area = pipeArea_m2(diameter_m);
    if (area <= 0) return;
    const current = clamp(Number(readFn()) || 0, 0, BOP_DEPTH);
    buffers.push({
      name,
      area,
      deficit: current,
      setDeficit: (val) => writeFn(clamp(val, 0, BOP_DEPTH))
    });
  };

  const chokeExists = (CHOKE_LINE_ID_m || 0) > 0;
  const killExists  = (KILL_LINE_ID_m  || 0) > 0;

  addBuffer('choke', chokeExists,
    CHOKE_LINE_ID_m,
    () => levelDeficit_choke_m,
    (v) => { levelDeficit_choke_m = v; });

  addBuffer('kill', killExists,
    KILL_LINE_ID_m,
    () => levelDeficit_kill_m,
    (v) => { levelDeficit_kill_m = v; });

  return buffers;
}

function bufferWetLength(buf){
  return Math.max(0, BOP_DEPTH - (Number(buf.deficit) || 0));
}

function drainClosedLineBuffers(buffers, volume_m3){
  let remaining = Math.max(0, volume_m3);
  let removed = 0;
  const EPS = 1e-12;
  while (remaining > EPS){
    const active = buffers.filter(buf => bufferWetLength(buf) > EPS);
    if (!active.length) break;
    const totalArea = active.reduce((sum, buf) => sum + buf.area, 0);
    if (totalArea <= EPS) break;
    const maxDrop = Math.min(...active.map(bufferWetLength));
    const volToMaxDrop = totalArea * maxDrop;
    if (remaining >= volToMaxDrop - EPS){
      for (const buf of active){
        buf.deficit = Math.min(BOP_DEPTH, (buf.deficit || 0) + maxDrop);
      }
      removed += volToMaxDrop;
      remaining -= volToMaxDrop;
    } else {
      const drop = remaining / totalArea;
      for (const buf of active){
        buf.deficit = Math.min(BOP_DEPTH, (buf.deficit || 0) + drop);
      }
      removed += remaining;
      remaining = 0;
    }
  }
  return removed;
}

function fillClosedLineBuffers(buffers, volume_m3){
  let remaining = Math.max(0, volume_m3);
  let added = 0;
  const EPS = 1e-12;
  while (remaining > EPS){
    const active = buffers.filter(buf => (buf.deficit || 0) > EPS);
    if (!active.length) break;
    const totalArea = active.reduce((sum, buf) => sum + buf.area, 0);
    if (totalArea <= EPS) break;
    const minDeficit = Math.min(...active.map(buf => buf.deficit || 0));
    const volToFull = totalArea * minDeficit;
    if (remaining >= volToFull - EPS){
      for (const buf of active){
        buf.deficit = Math.max(0, (buf.deficit || 0) - minDeficit);
      }
      added += volToFull;
      remaining -= volToFull;
    } else {
      const rise = remaining / totalArea;
      for (const buf of active){
        buf.deficit = Math.max(0, (buf.deficit || 0) - rise);
      }
      added += remaining;
      remaining = 0;
    }
  }
  return added;
}

function applyVolumeChangeToClosedLineBuffers(deltaVolume_m3){
  if (!BOP_CLOSED || Math.abs(deltaVolume_m3) < 1e-12) return deltaVolume_m3;
  const buffers = closedBopLineBuffers();
  if (!buffers.length) return deltaVolume_m3;

  let remaining = Math.abs(deltaVolume_m3);
  if (deltaVolume_m3 < 0){
    const drained = drainClosedLineBuffers(buffers, remaining);
    remaining = Math.max(0, remaining - drained);
    deltaVolume_m3 = -remaining;
  } else if (deltaVolume_m3 > 0){
    const filled = fillClosedLineBuffers(buffers, remaining);
    remaining = Math.max(0, remaining - filled);
    deltaVolume_m3 = remaining;
  }

  for (const buf of buffers){
    buf.setDeficit(buf.deficit || 0);
  }

  return deltaVolume_m3;
}


// ---- DROP-IN: replace your current updateRiserLevelWithLosses entirely ----

// DROP-IN: complete, self-contained, robust
// ---------------------------------------------------------------------------
// Recompute annulus section flows (above-BOP & below-BOP) + FLOW_OUT with
// hysteresis and smoothing to prevent 600‚Üî0 ping-pong.
// Call this once per sub-iteration, *before* pressure/friction calls.
// Requires: GPM_PER_M3S, annulusTopDepthGlobal(), totalLossDemand_m3s()
// Publishes: window.__qAnnAbove_m3s, window.__qAnnBelow_m3s, window.__qBelowIsDownward
//            and updates FLOW_OUT_gpm via low-pass + slew.
// ---------------------------------------------------------------------------
function recomputeAnnulusSectionFlowsForLosses(dt_s){
  const M3_PER_GPM = 1/15850.323;

  // Inflows that truly enter annulus "bucket"
  const qIn_m3s      = ((Q_DS||0) + (Q_BO||0)) * M3_PER_GPM;
  const qTopFill_m3s = (TOPFILL_ON ? (Q_TOPFILL||0) : 0) * M3_PER_GPM;
  const qCML_m3s     = (typeof effective_Q_CML_gpm==='function' ? (effective_Q_CML_gpm()||0) : 0) * M3_PER_GPM;

  // Use *filtered* demand if you added it; else sum actuals
  const qDem_m3s = (typeof totalLossDemand_m3s==='function') ? totalLossDemand_m3s() :
                   ((typeof totalLossRate_gpm==='function' ? totalLossRate_gpm() : 0) * M3_PER_GPM);

  // Net available to annulus after CML (before losses)
  const qAvail_m3s = Math.max(0, qIn_m3s + qTopFill_m3s - qCML_m3s);

  // Split into sections: below BOP consumes losses first (dominant sink)
  // Whatever demand can't be met (deficit) will pull the level down.
  const qBelow_m3s = Math.min(qDem_m3s, qAvail_m3s);         // what actually goes down to loss zone
  const qAbove_m3s = (qIn_m3s + qTopFill_m3s - qCML_m3s) - qBelow_m3s; // remainder goes up the riser

  // Publish section flows (using both new and old variable names for compatibility)
  window.__qAnnBelow_m3s   = qBelow_m3s;
  window.__qAnnAbove_m3s   = qAbove_m3s;
  window.__qAnnDown_m3s    = qBelow_m3s;  // Compatibility alias for advection code
  window.__qAnnUp_m3s      = qAbove_m3s;  // Compatibility alias for advection code
  window.__qBelowIsDownward = true; // sign convention handled in friction function

  // NOTE: FLOW_OUT_gpm calculation REMOVED from this function!
  // FO is now calculated ONLY in routeAnnulusFlowsWithLosses() which has:
  //   - Adaptive filter (fast when no losses)
  //   - Adaptive slew rate (5000 gpm/s when no losses)
  //   - Proper booster routing logic
  //
  // This function should ONLY publish section flows for friction calculations.
  // DO NOT add FLOW_OUT_gpm calculation here - it causes conflicts and slow response!
}


// REPLACE updateRiserLevelWithLosses() with rate-limited version
// ============================================================================

function updateRiserLevelWithLosses(dt_s) {
  // ========================================================================
  // SPATIAL MASS BALANCE SOLVER
  // Handles multiple fluid sections with different densities and flow directions
  // ========================================================================
  const GPM_PER_M3S = 15850.323;
  const to_m3s = (gpm) => (gpm || 0) / GPM_PER_M3S;

  const qDS_m3s = to_m3s(Q_DS || 0);
  const qBO_m3s = to_m3s(Q_BO || 0);
  const qTF_m3s = TOPFILL_ON ? to_m3s(Q_TOPFILL || 0) : 0;
  const qChokeDown_m3s = (CHOKE_LINE_OPEN && CHOKE_DIRECTION === "DOWN")
    ? to_m3s(Q_CHOKE || 0)
    : 0;
  const qKillDown_m3s = (KILL_LINE_OPEN && KILL_DIRECTION === "DOWN")
    ? to_m3s(Q_KILL || 0)
    : 0;
  const qCML_m3s = to_m3s(effective_Q_CML_gpm() || 0);

  // Get active loss zones sorted by depth (deepest first)
  const activeLossZones = (LOSSES_ON && Array.isArray(lossZones))
    ? lossZones.filter(z => z && z.enabled && (z.Qloss_gpm || 0) > 1.0).sort((a,b) => b.depth_m - a.depth_m)
    : [];

  const topDepthNow = LOSS_TOP_DEPTH_m || 0;
  const riserIsNotFull = topDepthNow > 0.5;
  const qOutSurface_m3s = riserIsNotFull ? 0 : to_m3s(FLOW_OUT_gpm || 0);

  // ========================================================================
  // SPATIAL SECTION ANALYSIS
  // ========================================================================

  if (activeLossZones.length === 0) {
    // NO ACTIVE LOSSES: Simple global mass balance
    const qIn_total = qDS_m3s + qBO_m3s + qTF_m3s + qChokeDown_m3s + qKillDown_m3s - qCML_m3s;
    const qOut_total = qOutSurface_m3s;
    const qNet = qIn_total - qOut_total;

    let dV = qNet * dt_s;
    dV = applyVolumeChangeToClosedLineBuffers(dV);
    let newTop = topDepthNow;

    // Move level up/down
    let guard = 0;
    while (Math.abs(dV) > 1e-12 && guard++ < 4) {
      const A = Math.max(areaAtDepthTop_(newTop), 1e-12);
      const dH = dV / A;
      newTop = clamp(newTop - dH, 0, TD_DEPTH);

      // Check boundary crossing
      const nextBoundary = (dH < 0) ? nextBoundaryAfter_(newTop, false) : nextBoundaryAfter_(newTop, true);
      if (Math.abs(newTop - nextBoundary) < 0.1) {
        const dV_toBoundary = A * Math.abs(newTop - nextBoundary);
        if (Math.abs(dV) > dV_toBoundary) {
          dV -= (dH < 0 ? -dV_toBoundary : dV_toBoundary);
          newTop = nextBoundary;
        } else {
          break;
        }
      } else {
        break;
      }
    }

    // Rate limiting
    const deltaTop = newTop - topDepthNow;
    const maxChange = (deltaTop < 0 ? LEVEL_MAX_DROP_RATE_M_S : LEVEL_MAX_RISE_RATE_M_S) * dt_s;
    newTop = topDepthNow + clamp(deltaTop, -maxChange, maxChange);

    LOSS_TOP_DEPTH_m = clamp(newTop, 0, TD_DEPTH);
    if (typeof syncSurfaceTopDepths === 'function') syncSurfaceTopDepths();
    return;
  }

  // ========================================================================
  // WITH ACTIVE LOSSES: Spatial mass balance
  // ========================================================================

  // Total losses currently exiting into the formation
  const qLoss_total_m3s = activeLossZones.reduce((sum, z) => sum + to_m3s(z.Qloss_gpm || 0), 0);
  const qDemand_m3s = (typeof totalLossDemand_m3s === 'function')
    ? totalLossDemand_m3s()
    : qLoss_total_m3s;
  const highestLossDepth = activeLossZones[activeLossZones.length - 1].depth_m;
  const allowDeficit = topDepthNow < (highestLossDepth - 1e-3);
  const qDeficit_m3s = allowDeficit ? Math.max(0, qDemand_m3s - qLoss_total_m3s) : 0;

  if (typeof window !== 'undefined') {
    window.__qLossDemand_m3s = qDemand_m3s;
    window.__qLossDeficit_m3s = qDeficit_m3s;
  }

  const qIn_total_m3s = qDS_m3s + qBO_m3s + qTF_m3s + qChokeDown_m3s + qKillDown_m3s;
  const qOut_total_m3s = qLoss_total_m3s + qOutSurface_m3s + qCML_m3s;
  const qNet_total_m3s = qIn_total_m3s - qOut_total_m3s - qDeficit_m3s;

  let dV_total = qNet_total_m3s * dt_s;
  dV_total = applyVolumeChangeToClosedLineBuffers(dV_total);
  let newTop = topDepthNow;

  let guard = 0;
  while (Math.abs(dV_total) > 1e-12 && guard++ < 4) {
    const A = Math.max(areaAtDepthTop_(newTop), 1e-12);
    const dH = dV_total / A;
    const proposedTop = clamp(newTop - dH, 0, TD_DEPTH);
    const nextBoundary = (dH < 0)
      ? nextBoundaryAfter_(proposedTop, false)
      : nextBoundaryAfter_(proposedTop, true);

    newTop = proposedTop;

    if (Math.abs(newTop - nextBoundary) < 0.1) {
      const dV_toBoundary = A * Math.abs(newTop - nextBoundary);
      if (Math.abs(dV_total) > dV_toBoundary) {
        dV_total -= (dH < 0 ? -dV_toBoundary : dV_toBoundary);
        newTop = nextBoundary;
      } else {
        break;
      }
    } else {
      break;
    }
  }

  // Prevent the wet top from dropping deeper than the shallowest active loss zone
  newTop = Math.min(newTop, highestLossDepth);

  // Rate limiting for stability
  const deltaTop = newTop - topDepthNow;
  const maxChange = (deltaTop < 0 ? LEVEL_MAX_DROP_RATE_M_S : LEVEL_MAX_RISE_RATE_M_S) * dt_s;
  newTop = topDepthNow + clamp(deltaTop, -maxChange, maxChange);

  LOSS_TOP_DEPTH_m = clamp(newTop, 0, TD_DEPTH);
  if (typeof syncSurfaceTopDepths === 'function') syncSurfaceTopDepths();

  // Diagnostics
  if (typeof window !== 'undefined') {
    window.qResid_gpm = qNet_total_m3s * GPM_PER_M3S;
  }
}

function updateSurfaceConnectedLevels(dt_s){
  const mpdSealed = (typeof mpdSealActive === 'function') ? mpdSealActive() : false;
  const chokeVent = typeof chokeLineIsFlowingUp === 'function' ? chokeLineIsFlowingUp() : false;
  const killVent  = typeof killLineIsFlowingUp === 'function' ? killLineIsFlowingUp() : false;
  const riserConnected = !BOP_CLOSED && !(mpdSealed || (MPD_ON && RCD_CLOSED));
  if (!riserConnected && !chokeVent && !killVent) return;
  const dt = Math.max(dt_s || 0, 0);
  const bopPsi = pressureAtDepth(BOP_DEPTH);
  if (!isFinite(bopPsi) || bopPsi <= 0) return;

  const relaxTarget = Math.min(surfaceColumnTopDepth(), BOP_DEPTH);
  const relaxDeficit = (prev) => {
    const tau = Math.max(LINE_LEVEL_EQ_TAU_S, 1e-3);
    const alpha = dt > 0 ? Math.min(1, dt / (tau + dt)) : 1;
    const clamped = Math.max(0, Math.min(relaxTarget, BOP_DEPTH));
    return prev + alpha * (clamped - prev);
  };

  const solveWetLength = (surfacePsi, avgMW, flow_m3s, frictionFn) => {
    const maxLen = BOP_DEPTH;
    if (maxLen <= 0) return 0;

    const totalAt = (len) => {
      if (len <= 0) return surfacePsi;
      const hydro = PSI_COEF * avgMW * len;
      const fric = (flow_m3s > 1e-9) ? frictionFn(len, flow_m3s) : 0;
      return surfacePsi + hydro + fric;
    };

    const hiTotal = totalAt(maxLen);
    if (hiTotal <= bopPsi + 0.5) return maxLen;

    const loTotal = totalAt(0);
    if (loTotal >= bopPsi - 0.5) return 0;

    let lo = 0;
    let hi = maxLen;
    for (let i = 0; i < 14; i++) {
      const mid = 0.5 * (lo + hi);
      const total = totalAt(mid);
      if (total >= bopPsi) {
        hi = mid;
      } else {
        lo = mid;
      }
    }
    return hi;
  };

  const updateLine = (opts) => {
    const prev = Math.max(0, Math.min(opts.get() || 0, BOP_DEPTH));
    if (!opts.active) {
      opts.set(relaxDeficit(prev));
      return;
    }

    const surfacePsi = Math.max(0, opts.surfacePsi());
    const avgMW = Math.max(0.1, opts.avgMW());
    const flow_m3s = Math.max(0, opts.flow());
    const wetLen = solveWetLength(surfacePsi, avgMW, flow_m3s, opts.friction);
    const targetDef = Math.max(0, Math.min(BOP_DEPTH - wetLen, BOP_DEPTH));
    const tau = Math.max(LINE_LEVEL_EQ_TAU_S, 1e-3);
    const alpha = dt > 0 ? Math.min(1, dt / (tau + dt)) : 1;
    const next = prev + alpha * (targetDef - prev);
    opts.set(Math.max(0, Math.min(next, BOP_DEPTH)));
  };

  updateLine({
    active: CHOKE_LINE_OPEN && CHOKE_DIRECTION === 'UP',
    get: () => levelDeficit_choke_m,
    set: (v) => { levelDeficit_choke_m = v; },
    surfacePsi: () => CHOKE_PRESSURE_psi || 0,
    avgMW: () => (chokeGrid.length > 0 ? average(chokeGrid) : MW_CHOKE),
    flow: () => {
      if (typeof window !== 'undefined' && typeof window.__Q_CHOKE_CALCULATED_m3s === 'number') {
        return Math.max(window.__Q_CHOKE_CALCULATED_m3s, 0);
      }
      return Math.max((Q_CHOKE || 0) * M3_PER_GPM, 0);
    },
    friction: (len, flow) => chokeFrictionPsiLength(len, flow)
  });

  updateLine({
    active: KILL_LINE_OPEN && KILL_DIRECTION === 'UP',
    get: () => levelDeficit_kill_m,
    set: (v) => { levelDeficit_kill_m = v; },
    surfacePsi: () => KILL_PRESSURE_psi || 0,
    avgMW: () => (killGrid.length > 0 ? average(killGrid) : MW_KILL),
    flow: () => {
      if (typeof window !== 'undefined' && typeof window.__Q_KILL_CALCULATED_m3s === 'number') {
        return Math.max(window.__Q_KILL_CALCULATED_m3s, 0);
      }
      return Math.max((Q_KILL || 0) * M3_PER_GPM, 0);
    },
    friction: (len, flow) => killFrictionPsiLength(len, flow)
  });
}

// Helper functions for level solver
function areaAtDepthTop_(d) {
  if (d <= BOP_DEPTH) return A_riserAnn();
  if (d <= SHOE_DEPTH) return A_casingAnn();
  return A_openAnn();
}

function nextBoundaryAfter_(d, goingUp) {
  if (goingUp) {
    if (d > SHOE_DEPTH) return SHOE_DEPTH;
    if (d > BOP_DEPTH) return BOP_DEPTH;
    return 0;
  } else {
    if (d < BOP_DEPTH) return BOP_DEPTH;
    if (d < SHOE_DEPTH) return SHOE_DEPTH;
    return TD_DEPTH;
  }
}


function equilibrateFluidLevel(dt_s, maxIterations = 5) {
  const M3_PER_GPM = 1 / 15850.323;
  const kickLossCoupled = !!(LOSSES_ON && formationFluidEnabled &&
    ((formationFluidRate_gpm || 0) > 0 || (typeof current_influx_m3s === 'number' && current_influx_m3s > 1e-8)));
  const iterCount = Math.max(maxIterations, kickLossCoupled ? 8 : 5);
  const dt_sub = dt_s / Math.max(1, iterCount);

  for (let i = 0; i < iterCount; i++) {
    // 1) Zones: compute ŒîP, capacity, and per-zone actual qLoss_gpm
    updateAllLossZones(dt_sub); // produces z.qLoss_gpm and window.sumLoss_gpm

    // 2) Smooth/slew the DEMAND used by mass-balance (if present)
    if (typeof refreshLossDemandFiltered === 'function') {
      refreshLossDemandFiltered(dt_sub);
    }

    // 3) Route flows so friction/advection know directions & returns are stable
    if (typeof routeAnnulusFlowsWithLosses === 'function') {
      routeAnnulusFlowsWithLosses(dt_sub); // publishes __qAnnUp_m3s, __qAnnDown_m3s, smooth FLOW_OUT_gpm
    } else if (typeof recomputeAnnulusSectionFlowsForLosses === 'function') {
      // Backward-compatible: if you kept the older helper name
      recomputeAnnulusSectionFlowsForLosses(dt_sub);
    }

    // (Your friction/advection step should read __qAnnUp_m3s / __qAnnDown_m3s and wet lengths)

    // 4) Level solver: hybrid (actual zone outflow + demand deficit)
    updateRiserLevelWithLosses(dt_sub);

    // 5) Optional early-exit (demand ‚âà available supply)
    const qIn_m3s = (
      ((Q_DS || 0) + (Q_BO || 0)) * M3_PER_GPM
      + (TOPFILL_ON ? (Q_TOPFILL || 0) * M3_PER_GPM : 0)
    );
    const qDemand_m3s = (typeof totalLossDemand_m3s === 'function')
      ? totalLossDemand_m3s()
      : ((typeof totalLossRate_gpm === 'function' ? totalLossRate_gpm() : 0) * M3_PER_GPM);

    const epsBase = Math.max(1e-6, 0.02 * Math.max(qIn_m3s, 1e-3));
    const eps = kickLossCoupled ? epsBase * 0.5 : epsBase;
    if (Math.abs(qDemand_m3s - qIn_m3s) <= eps) break;
  }
}



// ---------------------------------------------------------------------------
// Recompute effective annulus section flows (above-BOP and below-BOP) 
// given current losses, CML intake, and whether the riser is dry.
// Publishes window.__qAnnAbove_m3s and window.__qAnnBelow_m3s for friction.
// NOTE: Duplicate function definition removed - using comprehensive version at line ~2510
// with FO protection and friction redistribution for losses physics

function safeRheoVal(key, def){
  const el = rheoPanel && rheoPanel[key];
  return (el && typeof el.value === 'function') ? num(el.value()) : def;
}
// --- U-tube helper (riser leg: surface -> pump depth) ---
function dPperM_riserLeg_forUTube(Q, dTop, dPump){
  // use the same riser annulus model, but only the wet span (surface‚Üítop is "dry")
  const L = Math.max(0, Math.min(BOP_DEPTH, dPump) - Math.max(0, dTop));
  if (L <= 0) return 0;
  // Use your existing function for the riser section at current total annulus flow
  return dPperM_riserAnnulus(Q);
}
// Linearized hydraulic resistance of the leg (psi per m¬≥/s)
function riserLegResistancePsiPer_m3s(dTop, dPump){
  const L = Math.max(0, Math.min(BOP_DEPTH, dPump) - Math.max(0, dTop));
  if (L <= 0) return 1e9; // practically infinite (no wet column)
  // Evaluate slope around a small reference flow through the leg
  const qRef = (Q_REF/15850.323); // m¬≥/s
  const dpdl_Pa = dPperM_riserLeg_forUTube(qRef, dTop, dPump); // Pa/m
  const dp_Pa = dpdl_Pa * L; // Pa
  const dp_psi = dp_Pa * PSI_PER_PASCAL; // psi
  // "resistance" R = ŒîP / Q (psi per m¬≥/s)
  return Math.max(dp_psi / Math.max(qRef, 1e-9), 1); // avoid tiny values
}
// --- Visual column helpers (ADD near other helpers) ---

// Minimal fallback line plotter for the active time-chart panel.
// Assumes you have a current chart rect and transforms already set.
// If not, it draws in normalized screen space at top-left  (safe default).
function plotTimeSeriesLine(series, ymin, ymax, strokeCol) {
  if (!series || !series.length) return;
  push();
  if (strokeCol) stroke(strokeCol); else stroke(255);
  noFill();
  beginShape();
  // Draw left-to-right with newest at left (index 0)
  const N = series.length;
  for (let i = 0; i < N; i++) {
    const x = map(i, 0, N-1, 10, 10 + Math.min(width-20, 600));  // fallback width 600
    const yVal = constrain(series[i], ymin, ymax);
    const y = map(yVal, ymin, ymax, 10 + 100, 10);                // fallback height 100
    vertex(x, y);
  }
  endShape();
  pop();
}


function clipFillY_forRiser(){
  const wetTop = riserTopDepth(); // 0..BOP
  return mapDepthToY(wetTop);
}
function clipFillY_forDS(){
  const dsTop = clamp(levelDeficit_m, 0, TD_DEPTH);
  return mapDepthToY(dsTop);
}
function clipFillY_forBooster(){
  const boTop = clamp(levelDeficit_bo_m, 0, BOP_DEPTH);
  return mapDepthToY(boTop);
}
// --- CML visual helpers (ADD near mapDepthToY / riserTopDepth) ---
function cmlPumpY() {
  // clamp to riser leg interval (0..BOP_DEPTH)
  const d = clamp(CML_DEPTH || 0, 0, BOP_DEPTH);
  return mapDepthToY(d);
}
// ============================ RHEOLOGY CORE ============================
function getRheoForCalc(){
  let K, n, tauY;
  if (ACTIVE_RHEO_MODEL === "Bingham"){
    K = Math.max(fitParams.mu_p_Pa_s || 0, 1e-6);
    n = 1.0;
    tauY = Math.max(fitParams.tau_y_Pa || 0, 0);
  } else if (ACTIVE_RHEO_MODEL === "PowerLaw"){
    K = Math.max(fitParams.K_PL_Pa_s_n || 0.05, 1e-6);
    n = clamp(fitParams.n_PL ?? 0.9, 0.25, 1.0);
    tauY = 0;
  } else { // HB
    K = Math.max(fitParams.K_HB_Pa_s_n || 0.05, 1e-6);
    n = clamp(fitParams.n_HB ?? 0.9, 0.25, 1.0);
    tauY = Math.max(fitParams.tau_y_HB_Pa || 0, 0);
  }
  return { K, n, tauY };
}
// Rheology fitting functions
function collectRheoPoints(){
  const rVal = (key, def) => {
    const el = rheoPanel && rheoPanel[key];
    if (el && typeof el.value === 'function') return num(el.value());
    return def;
  };
  const rows = [
    { rpm: 600, dial: rVal('R600', rheoDefaults.R600) },
    { rpm: 300, dial: rVal('R300', rheoDefaults.R300) },
    { rpm: 200, dial: rVal('R200', rheoDefaults.R200) },
    { rpm: 100, dial: rVal('R100', rheoDefaults.R100) },
    { rpm: 6, dial: rVal('R6', rheoDefaults.R6) },
    { rpm: 3, dial: rVal('R3', rheoDefaults.R3) },
    { rpm: 1, dial: rVal('R1', rheoDefaults.R1) },
  ].filter(r => r.dial > 0);
  return rows.map(r => {
    const gdot = 1.703 * r.rpm; // s^-1
    const tauPa = r.dial * LBF100FT2_to_Pa; // Pa
    return { gdot, tauPa, rpm: r.rpm, dial: r.dial };
  });
}
function fitBingham(pts){
  let Sx=0, Sy=0, Sxx=0, Sxy=0, n=0;
  for (const p of pts){
    const x=p.gdot, y=p.tauPa;
    Sx+=x; Sy+=y; Sxx+=x*x; Sxy+=x*y; n++;
  }
  if (n<2){ return {mu_p:null, tau_y:null, sse:Infinity}; }
  const denom = (n*Sxx - Sx*Sx) || 1e-12;
  const b = (n*Sxy - Sx*Sy)/denom; // Œºp
  const a = (Sy - b*Sx)/n; // œÑy
  let sse=0;
  for(const p of pts){
    const yhat=a+b*p.gdot;
    sse+=(p.tauPa-yhat)**2;
  }
  return { mu_p: Math.max(b,0), tau_y: Math.max(a,0), sse };
}
function fitPowerLaw(pts){
  let Sx=0, Sy=0, Sxx=0, Sxy=0, n=0;
  for(const p of pts){
    if (p.tauPa<=0 || p.gdot<=0) continue;
    const x=Math.log(p.gdot), y=Math.log(p.tauPa);
    Sx+=x; Sy+=y; Sxx+=x*x; Sxy+=x*y; n++;
  }
  if (n<2){ return {K:null, n:null, sse:Infinity}; }
  const denom=(n*Sxx - Sx*Sx) || 1e-12;
  const n_pl=(n*Sxy - Sx*Sy)/denom;
  const logK=(Sy - n_pl*Sx)/n;
  const K=Math.exp(logK);
  let sse=0;
  for(const p of pts){
    if (p.tauPa<=0 || p.gdot<=0) continue;
    const yhat=Math.log(K) + n_pl*Math.log(p.gdot);
    sse+=(Math.log(p.tauPa)-yhat)**2;
  }
  return {K, n: n_pl, sse};
}
function fitHB(pts){
  const taus = pts.map(p => p.tauPa);
  const tauMin = 0;
  const tauMax = Math.max(...taus) * 0.9;
  let best = { tau_y:null, K:null, n:null, sse:Infinity };
  const coarseSteps = 60; // coarse sweep
  for (let i=0; i<=coarseSteps; i++){
    const tau_y = tauMin + (tauMax - tauMin) * i / coarseSteps;
    const res = [];
    for (const p of pts){
      const tr = p.tauPa - tau_y;
      if (tr > 0 && p.gdot > 0) res.push({ gdot:p.gdot, tauR:tr, rpm:p.rpm });
    }
    if (res.length < 2) continue;
    let Sx=0, Sy=0, Sxx=0, Sxy=0, n=0;
    for (const r of res){
      const x=Math.log(r.gdot), y=Math.log(r.tauR);
      Sx+=x; Sy+=y; Sxx+=x*x; Sxy+=x*y; n++;
    }
    const denom = (n*Sxx - Sx*Sx) || 1e-12;
    const nHB = (n*Sxy - Sx*Sy)/denom;
    const logK = (Sy - nHB*Sx)/n;
    const KHB = Math.exp(logK);
    // mild weighting for low-shear points (stabilizes œÑy)
    let sse=0;
    for (const p of pts){
      const pred = tau_y + KHB*Math.pow(p.gdot, nHB);
      const w = (p.rpm <= 100) ? 1.5 : 1.0;
      sse += w * Math.pow(p.tauPa - pred, 2);
    }
    if (sse < best.sse) best = { tau_y, K:KHB, n:nHB, sse };
  }
  // local refine around best
  if (isFinite(best.sse) && best.tau_y != null){
    const t0 = best.tau_y;
    const lo = Math.max(0, t0*0.8), hi = t0*1.2;
    for (let i=0; i<=60; i++){
      const tau_y = lo + (hi-lo)*i/60;
      const res = [];
      for (const p of pts){
        const tr = p.tauPa - tau_y;
        if (tr>0 && p.gdot>0) res.push({ gdot:p.gdot, tauR:tr, rpm:p.rpm });
      }
      if (res.length < 2) continue;
      let Sx=0, Sy=0, Sxx=0, Sxy=0, n=0;
      for (const r of res){
        const x=Math.log(r.gdot), y=Math.log(r.tauR);
        Sx+=x; Sy+=y; Sxx+=x*x; Sxy+=x*y; n++;
      }
      const denom=(n*Sxx - Sx*Sx) || 1e-12;
      const nHB=(n*Sxy - Sx*Sy)/denom;
      const logK=(Sy - nHB*Sx)/n;
      const KHB=Math.exp(logK);
      let sse=0;
      for (const p of pts){
        const pred = tau_y + KHB*Math.pow(p.gdot, nHB);
        const w = (p.rpm <= 100) ? 1.5 : 1.0;
        sse += w * Math.pow(p.tauPa - pred, 2);
      }
      if (sse < best.sse) best = { tau_y, K:KHB, n:nHB, sse };
    }
  }
  return best;
}
function doRheologyFit(){
  const pts = collectRheoPoints();
  if (!pts.length){
    rheoPanel.statusDiv.html("No rheology points provided.");
    return;
  }


  // Direct Bingham if PV/YP are provided and Bingham is selected
 const PVcp = safeRheoVal('PV', 0); // cP
 const YPlbf = safeRheoVal('YP', 0); // lbf/100ft¬≤
  const usePVYP = (ACTIVE_RHEO_MODEL === "Bingham") && (PVcp > 0 || YPlbf > 0);


  let b, p, h;
  if (usePVYP){
    b = { mu_p: PVcp * 1e-3, // Pa¬∑s
         tau_y: YPlbf * LBF100FT2_to_Pa, // Pa
         sse: 0 };
  } else {
    b = fitBingham(pts);
  }
  p = fitPowerLaw(pts);
  h = fitHB(pts);

  fitParams.mu_p_Pa_s = b.mu_p ?? fitParams.mu_p_Pa_s;
  fitParams.tau_y_Pa = b.tau_y ?? fitParams.tau_y_Pa;
  fitParams.K_PL_Pa_s_n = p.K;
  fitParams.n_PL = p.n;
  fitParams.K_HB_Pa_s_n = h.K;
  fitParams.n_HB = h.n;
  fitParams.tau_y_HB_Pa = h.tau_y;

  publishRheoToGlobals()

  // gel from 10s if provided
const g10s = safeRheoVal('G10s', rheoDefaults.G10s ?? 0);
if (g10s > 0) gel_Pa = g10s * LBF100FT2_to_Pa;
  const srcNote = usePVYP ? "Bingham (PV/YP direct)" : "Bingham (regressed)";
  rheoPanel.statusDiv.html(
    `Fit OK <br> ${srcNote} <br> Bingham SSE=${(b.sse??0).toFixed(3)} <br>
PL SSE=${(p.sse??0).toFixed(3)} HB SSE=${(h.sse??0).toFixed(3)}`
  );
}
function showFittedParams(){
  const s = (v, d=4) => (v == null ? "‚Äî" : Number(v).toFixed(d));
  const msg = `
    Model = ${ACTIVE_RHEO_MODEL}<br>
    + Bingham: Œºp = ${s(fitParams.mu_p_Pa_s)} Pa¬∑s; œÑy = ${s(fitParams.tau_y_Pa)} Pa<br>
    + Power-Law: K = ${s(fitParams.K_PL_Pa_s_n)} Pa¬∑s^n; n = ${s(fitParams.n_PL)}<br>
    + HB: K = ${s(fitParams.K_HB_Pa_s_n)} Pa¬∑s^n; n = ${s(fitParams.n_HB)}; œÑy = ${s(fitParams.tau_y_HB_Pa)} Pa;
  `;
  rheoPanel.statusDiv.html(msg);
}

// --- Keep CML and loss-driven free surfaces in sync when connected ---------
function syncSurfaceTopDepths(){
  const lossActive = LOSSES_ON && typeof LOSS_TOP_DEPTH_m === 'number';
  const cmlActive  = CML_ON && !BOP_CLOSED && typeof CML_TOP_DEPTH === 'number';

  let top = 0;

  if (lossActive && cmlActive) {
    // One connected column: use the deepest (largest depth) and sync both
    top = Math.max(LOSS_TOP_DEPTH_m || 0, CML_TOP_DEPTH || 0);
    if (Math.abs((LOSS_TOP_DEPTH_m || 0) - top) > 1e-6) LOSS_TOP_DEPTH_m = top;
    if (Math.abs((CML_TOP_DEPTH   || 0) - top) > 1e-6) CML_TOP_DEPTH   = top;
  } else if (lossActive) {
    top = LOSS_TOP_DEPTH_m || 0;
  } else if (cmlActive) {
    top = CML_TOP_DEPTH || 0;
  }

  if (typeof ANN_TOP_DEPTH_m !== 'undefined') {
    ANN_TOP_DEPTH_m = top;
  }

  return top;
}

// --- Global annulus top (can drop below BOP due to losses) ---
function annulusTopDepthGlobal(){
  // Returns the PHYSICAL top of fluid column (deepest of all constraints)
  const top = syncSurfaceTopDepths();
  return Math.max(0, Math.min(top, TD_DEPTH));
}

// ================== CML level update + simple controller ==================

function computeImbalanceFlows(){
  const fluidTop = annulusTopDepthGlobal();
  
  // Heights of wet fluid columns
  const H_riser = Math.max(BOP_DEPTH - fluidTop, 0);
  const H_below = Math.max(TD_DEPTH - Math.max(BOP_DEPTH, fluidTop), 0);
  const H_ds = TD_DEPTH; // DS always full
  const H_bo = BOP_DEPTH; // Booster line always full

  // Mean densities
  const MW_ds = dsAvgPPG();
  const MW_abv = average(annAboveGrid) || MW_ds;
  const MW_blw = average(annBelowGrid) || MW_ds;
  const MW_bo = boosterAvgPPG();

  // Hydrostatic pressures at key points
  const P_ds_TD = PSI_COEF * MW_ds * H_ds;
  const P_ann_TD = PSI_COEF * (MW_abv * H_riser + MW_blw * H_below);
  const P_bo_BOP = PSI_COEF * MW_bo * H_bo;
  const P_ris_BOP = PSI_COEF * MW_abv * H_riser;

  // ŒîP with soft deadband
  const dP_ds_ann = smoothDeadbandPsi(P_ds_TD - P_ann_TD, IMB_DEADBAND_PSI);
  const dP_bo_ris = smoothDeadbandPsi(P_bo_BOP - P_ris_BOP, IMB_DEADBAND_PSI);

  // Calculate resistances at reference flow
  const qRef = (Q_REF / 15850.323);
  
  // DS loop resistance (DS + annulus + bit)
  const R_ds = drillstringLegResistancePsiPer_m3s();
  const R_ann_below = belowBOPResistancePsiPer_m3s();
  const R_ann_riser = riserResistancePsiPer_m3s();
  const R_bit = 1000 / Math.max(qRef, 1e-9); // ~1000 psi @ Qref
  const R_loop_DS = R_ds + R_ann_below + R_ann_riser + R_bit;

  // Booster loop resistance
  const R_bo = boosterResistancePsiPer_m3s();
  const R_loop_BO = R_bo + R_ann_riser;

  // Raw imbalance flows
  const q_ds2ann_raw = dP_ds_ann / Math.max(R_loop_DS, 1e-6);
  const q_bo2ris_raw = dP_bo_ris / Math.max(R_loop_BO, 1e-6);

  // Smooth and limit (max 5% of total flow as imbalance)
  const qMax_imb = ((Q_DS + Q_BO) / 15850.323) * 0.05;
  
  QIMB_DS2ANN_m3s = (1 - IMB_ALPHA) * QIMB_DS2ANN_m3s + 
                    IMB_ALPHA * clamp(q_ds2ann_raw, -qMax_imb, qMax_imb);
  QIMB_BO2RIS_m3s = (1 - IMB_ALPHA) * QIMB_BO2RIS_m3s + 
                    IMB_ALPHA * clamp(q_bo2ris_raw, -qMax_imb, qMax_imb);
}

// Helper: Riser resistance
function riserResistancePsiPer_m3s() {
  const L = Math.max(BOP_DEPTH - annulusTopDepthGlobal(), 0);
  if (L <= 0) return 1e9;
  const qRef = (Q_REF / 15850.323);
  const dpdl_Pa = dPperM_riserAnnulus(qRef);
  return (dpdl_Pa * L * PSI_PER_PASCAL) / Math.max(qRef, 1e-9);
}

// Helper: Below BOP resistance
function belowBOPResistancePsiPer_m3s() {
  const top = Math.max(BOP_DEPTH, annulusTopDepthGlobal());
  const L_csg = Math.max(0, SHOE_DEPTH - top);
  const L_oh = Math.max(0, TD_DEPTH - Math.max(SHOE_DEPTH, top));
  
  if (L_csg + L_oh <= 0) return 1e9;
  
  const qRef = (Q_REF / 15850.323);
  const dp_csg_Pa = dPperM_casingAnnulus(qRef) * L_csg;
  const dp_oh_Pa = dPperM_openholeAnnulus(qRef) * L_oh;
  
  return ((dp_csg_Pa + dp_oh_Pa) * PSI_PER_PASCAL) / Math.max(qRef, 1e-9);
}

// Helper: DS resistance
function drillstringLegResistancePsiPer_m3s() {
  const L = TD_DEPTH;
  const qRef = (Q_REF / 15850.323);
  const dpdl_Pa = dPperM_drillstring(qRef);
  return (dpdl_Pa * L * PSI_PER_PASCAL) / Math.max(qRef, 1e-9);
}

// Helper: Booster resistance
function boosterResistancePsiPer_m3s() {
  const L = BOP_DEPTH;
  const qRef = (Q_REF / 15850.323);
  const dpdl_Pa = dPperM_booster(qRef);
  return (dpdl_Pa * L * PSI_PER_PASCAL) / Math.max(qRef, 1e-9);
}

// ================== CML level update + controller ==================
function updateCMLLevelAndControl(){
  // --- 0) Inputs we need every frame
  const { qDS: qDS_m3s, qBO: qBO_m3s } = flows_m3s();
  const dt_ctrl = frameSeconds();
// --- 1) Auto CML (pressure-anchored, ultra-smooth) ---
// Optional: keep imbalance feed-forward commented until stable
let qIn_total_m3s = qDS_m3s + qBO_m3s;
// qIn_total_m3s += Math.max(0, QIMB_DS2ANN_m3s) + Math.max(0, QIMB_BO2RIS_m3s);

// Tunables (conservative defaults)
const CML_DB_HOLD_PSI   = 10;    // freeze band near setpoint
const CML_DB_INT_PSI    = 20;    // don't integrate inside this
const CML_PSOFT_BLEND   = 150;   // how fast we move from FF to PI
const CML_P_LPF_TAU_S   = 4.0;   // pressure LPF
const CML_FF_LPF_TAU_S  = 2.0;   // inflow LPF
const CML_KP_BASE       = 0.40;  // gpm/psi (base; scheduled)
const CML_KI_BASE       = 0.015; // gpm/psi/s (base; scheduled)
const CML_SLEW_GPM_S    = 80;    // |ŒîQ|/s
const CML_ACCEL_GPM_S2  = 400;   // |ŒîŒîQ|/s¬≤ (accel limit)
const CML_CMD_LPF_TAU_S = 1.2;   // final command LPF

// Controller state (extend your cmlCtrl safely)
cmlCtrl.P_lpf_psi   = cmlCtrl.P_lpf_psi   || 0;
cmlCtrl.qFF_lpf_gpm = cmlCtrl.qFF_lpf_gpm || 0;
cmlCtrl.I_gpm       = cmlCtrl.I_gpm       || 0;
cmlCtrl.Q_cmd_prev  = cmlCtrl.Q_cmd_prev  || (Q_CML || 0);
cmlCtrl.dQ_prev     = cmlCtrl.dQ_prev     || 0; // for accel limiting
cmlCtrl.Q_out_lpf   = cmlCtrl.Q_out_lpf   || (Q_CML || 0);

if (AUTO_CML_ON && CML_AP_DEPTH > 0 && CML_AP_ECD > 0){
  const P_set = PSI_COEF * CML_AP_ECD * CML_AP_DEPTH; // psi

  // LPF helper
  const lpf = (yPrev, x, tau, dt) => {
    const a = clamp(dt / Math.max(tau, 1e-6), 0, 1);
    return (1 - a) * yPrev + a * x;
  };

  // Filtered pressure & error
  const P_meas = pressureAtDepth_noSBP_withCML(CML_AP_DEPTH);
  cmlCtrl.P_lpf_psi = lpf(cmlCtrl.P_lpf_psi, P_meas, CML_P_LPF_TAU_S, dt_ctrl);

  const e_raw = cmlCtrl.P_lpf_psi - P_set; // + ‚Üí pull more (‚ÜëQ_CML)
  const inHold = Math.abs(e_raw) <= CML_DB_HOLD_PSI;
  const e_db = inHold ? 0
                      : (e_raw > 0 ? e_raw - CML_DB_HOLD_PSI
                                   : e_raw + CML_DB_HOLD_PSI);

  // Feed-forward = filtered inflow
  const qFF_gpm_raw = clamp(qIn_total_m3s * 15850.323, 0, Q_MAX);
  cmlCtrl.qFF_lpf_gpm = lpf(cmlCtrl.qFF_lpf_gpm, qFF_gpm_raw, CML_FF_LPF_TAU_S, dt_ctrl);

  // Gain scheduling & integral separation
  const wPI = clamp((Math.abs(e_raw) - CML_DB_HOLD_PSI) / Math.max(CML_PSOFT_BLEND, 1e-6), 0, 1);
  const smoothstep = (t) => (t<=0?0:t>=1?1:t*t*(3-2*t));
  const W = smoothstep(wPI); // 0‚Üítrust FF, 1‚Üíuse PI

  const Kp = CML_KP_BASE * W;
  const Ki = CML_KI_BASE * W;
  const allowI = (Math.abs(e_raw) > CML_DB_INT_PSI);

  const Pterm_gpm = Kp * e_db;
  if (allowI){
    cmlCtrl.I_gpm += Ki * e_db * dt_ctrl;
    cmlCtrl.I_gpm = clamp(cmlCtrl.I_gpm, -400, +400);
  }

  // Blend FF and PI
  const qPI_gpm = cmlCtrl.qFF_lpf_gpm + Pterm_gpm + cmlCtrl.I_gpm;
  let qCmd_gpm = (1 - W) * cmlCtrl.qFF_lpf_gpm + W * qPI_gpm;

  // Two-stage motion limiting: accel then slew
  const dQ_des   = (qCmd_gpm - cmlCtrl.Q_cmd_prev) / Math.max(dt_ctrl, 1e-6);
  const dQ_rate  = clamp(
    dQ_des,
    cmlCtrl.dQ_prev - CML_ACCEL_GPM_S2*dt_ctrl,
    cmlCtrl.dQ_prev + CML_ACCEL_GPM_S2*dt_ctrl
  );
  let qCmd_accel = cmlCtrl.Q_cmd_prev + dQ_rate * dt_ctrl;

  const maxStep  = CML_SLEW_GPM_S * dt_ctrl;
  let qCmd_slew  = cmlCtrl.Q_cmd_prev + clamp(qCmd_accel - cmlCtrl.Q_cmd_prev, -maxStep, +maxStep);
  qCmd_slew = clamp(qCmd_slew, 0, Q_MAX);

  // Final command LPF
  cmlCtrl.Q_out_lpf = lpf(cmlCtrl.Q_out_lpf, qCmd_slew, CML_CMD_LPF_TAU_S, dt_ctrl);
  Q_CML = cmlCtrl.Q_out_lpf;

  // Anti-windup & hold-band housekeeping
  const atHi = (Q_CML >= Q_MAX - 1e-3) && (e_db > 0);
  const atLo = (Q_CML <= 0 + 1e-3)     && (e_db < 0);
  if (atHi || atLo) cmlCtrl.I_gpm *= 0.98;
  if (inHold)       cmlCtrl.I_gpm *= 0.99;

  // Advance state
  cmlCtrl.dQ_prev    = (Q_CML - cmlCtrl.Q_cmd_prev) / Math.max(dt_ctrl, 1e-6);
  cmlCtrl.Q_cmd_prev = Q_CML;

  if (cmlQSlider) cmlQSlider.value(Q_CML);
  if (cmlQInput)  cmlQInput.value(nf(Q_CML,1,0));

} else {
  // Auto off / anchor invalid ‚Üí reset controller state
  cmlCtrl.I_gpm = 0;
  cmlCtrl.Q_cmd_prev = (Q_CML || 0);
  cmlCtrl.dQ_prev = 0;
}

 
  // --- 2) Soft limiter near pump pickup (prevents sucking air)
  const margin_m = Math.max(0, CML_DEPTH - CML_TOP_DEPTH);
  let qCML_m3s = (Q_CML || 0) / 15850.323;
  const m0 = 2.0;
  const s = clamp((margin_m / m0), 0, 1);
  const soft = s*s*(3 - 2*s);
  qCML_m3s *= soft;
  if (margin_m < 0.05) qCML_m3s = 0;

  // --- 3) Level update (riser volume integration)
  const qIn_total = qDS_m3s + qBO_m3s; // keep imbalances off for now
  const Aann_riser = A_riser();
  const dt_effective = dt_ctrl * CML_TIME_ACCEL;
  const netFlow_m3s = qIn_total - qCML_m3s;
  const dVol_m3 = netFlow_m3s * dt_effective;
  const dH_signed = dVol_m3 / Math.max(Aann_riser, 1e-12); // + fill, - drain

  const newTopDepth = (CML_TOP_DEPTH || 0) - dH_signed;
  const CML_ALPHA = 0.35;
  const cand = clamp(newTopDepth, 0, BOP_DEPTH);
  CML_TOP_DEPTH = (1 - CML_ALPHA) * (CML_TOP_DEPTH || 0) + CML_ALPHA * cand;

  CML_Q_MAX = Q_MAX; // expose max to UI
}


// Linearized DS leg resistance (psi per m¬≥/s) at ~Q_REF
function drillstringLegResistancePsiPer_m3s() {
  const L = TD_DEPTH;
  if (L <= 0) return 1e9;
  const qRef = (Q_REF/15850.323); // m¬≥/s
  const dpdl_Pa = dPperM_drillstring(qRef); // Pa/m at qRef
  const dp_Pa = dpdl_Pa * L; // Pa
  const dp_psi = dp_Pa * PSI_PER_PASCAL; // psi
  return Math.max(dp_psi / Math.max(qRef, 1e-9), 1);
}
const R_BIT_NOZZLE = 800 / Math.max((Q_REF/15850.323), 1e-9); // ~800 psi at Q_REF
function withFrameDtOverride(dt, fn){
  const prev = frameDtOverride_s;
  frameDtOverride_s = dt;
  try {
    return fn();
  } finally {
    frameDtOverride_s = prev;
  }
}

// One frame worth of "simulation time" (keeps the fast-clock consistent)
function frameSeconds(){
  if (frameDtOverride_s != null) return frameDtOverride_s;
  // BASE_M_PER_FRAME is tied to a reference velocity. Convert to a time step.
  const qRef_m3s = (Q_REF/15850.323);
  const vRef = qRef_m3s / Math.max(A_riser(), 1e-12); // m/s in riser
  const dx = BASE_M_PER_FRAME; // m advanced per frame at vRef
  const baseDt = dx / Math.max(vRef, 1e-9);
  const scale = currentTimeScaleFactor(baseDt);
  const pausedFactor = simulationPaused ? 0 : 1;
  window.timeScaleFactor = scale;
  return baseDt * scale * pausedFactor; // seconds per frame (scaled or clamped)
}
// ========================== CAPTURE / OVERLAYS =========================
function captureState(){
  const step = 25;
  const n = Math.floor(MAX_DEPTH / step) + 1;
  capturedP = Array.from({ length: n }, (_, i) => pressureAtDepth(i * step));
  capturedECD = Array.from({ length: n }, (_, i) => ecdWithSBPAtDepth(i * step));
}
window.captureState = captureState; // allow console trigger
// ============================== UI HELPERS =============================
function mkLabel(txt, x, y){ createDiv(txt).position(x,y).style("color","#EEE").style("font-size","12px"); }
// ================================ SETUP ================================
function setup(){
  createCanvas(W, H+220);
  colorMode(HSB, 360, 100, 100, 255);
  textFont('Arial');
  textAlign(CENTER, CENTER);
  frameRate(30);

  // Center the main well schematic horizontally
  well.x = Math.round((width - well.w) / 2);


  // ========== Bottom banner layout - Two Rows ==========
  bottomPanelPadding = 36;
  bottomPanelSpacing = 40;
  frameHeight = 320;
  bottomPanelRowSpacing = 80; // Vertical spacing between rows (taller banner)

  // Row 1: Rheology, Gel, Well Configuration, Enhanced Hydraulics
  frameY = well.y + well.h + 90;
  const row1Weights = { rheo: 1.6, gel: 0.85, well: 1.15, enh: 0.9 };
  const row1PanelCount = Object.keys(row1Weights).length;
  const row1Width = W - 2 * bottomPanelPadding - bottomPanelSpacing * (row1PanelCount - 1);
  const row1WeightSum = Object.values(row1Weights).reduce((a, b) => a + b, 0);
  const row1UnitWidth = row1Width / Math.max(row1WeightSum, 1e-6);

  const ensureWidth = (candidate, minW) => Math.max(candidate, minW);

  rheoFrameW = ensureWidth(row1UnitWidth * row1Weights.rheo, 640);
  gelFrameW = ensureWidth(row1UnitWidth * row1Weights.gel, 240);
  configFrameW = ensureWidth(row1UnitWidth * row1Weights.well, 360);
  enhFrameW = ensureWidth(row1UnitWidth * row1Weights.enh, 320);

  rheoFrameX = bottomPanelPadding;
  gelFrameX = rheoFrameX + rheoFrameW + bottomPanelSpacing;
  configFrameX = gelFrameX + gelFrameW + bottomPanelSpacing;
  enhFrameX = configFrameX + configFrameW + bottomPanelSpacing;

  // Row 2: Losses, Kicks, BOP (wide), Diagnostics
  frameY2 = frameY + frameHeight + bottomPanelRowSpacing;
  const row2Weights = { loss: 1.0, kick: 1.0, bop: 1.5, diag: 0.85 };
  const row2PanelCount = Object.keys(row2Weights).length;
  const row2Width = W - 2 * bottomPanelPadding - bottomPanelSpacing * (row2PanelCount - 1);
  const row2WeightSum = Object.values(row2Weights).reduce((a, b) => a + b, 0);
  const row2UnitWidth = row2Width / Math.max(row2WeightSum, 1e-6);

  lossFrameW = row2UnitWidth * row2Weights.loss;
  kickFrameW = row2UnitWidth * row2Weights.kick;
  bopFrameW = row2UnitWidth * row2Weights.bop;
  diagFrameW = row2UnitWidth * row2Weights.diag;

  lossFrameX = bottomPanelPadding;
  kickFrameX = lossFrameX + lossFrameW + bottomPanelSpacing;
  bopFrameX = kickFrameX + kickFrameW + bottomPanelSpacing;
  diagFrameX = bopFrameX + bopFrameW + bottomPanelSpacing;

  bottomPanelW = Math.min(lossFrameW, kickFrameW); // Reference width for row 2 cards
  bopPanelW = bopFrameW;

  // Convert inches to meters
  riser_ID_m    = riser_ID_in    * 0.0254;
  casing_ID_m   = casing_ID_in   * 0.0254;
  openhole_ODm  = openhole_OD_in * 0.0254;
  ds_OD_m       = ds_OD_in       * 0.0254;
  ds_ID_m       = ds_ID_in       * 0.0254;
  booster_ID_m  = booster_ID_in  * 0.0254;
  CHOKE_LINE_ID_m = CHOKE_LINE_ID_in * 0.0254;
  KILL_LINE_ID_m  = KILL_LINE_ID_in  * 0.0254;

  // Initialize choke and kill line grids (BOP to surface, same length as riser)
  chokeGrid = new Array(N_ABV).fill(MW_CHOKE);
  killGrid = new Array(N_ABV).fill(MW_KILL);

  // Ensure choke and kill lines start completely full
  levelDeficit_choke_m = 0;
  levelDeficit_kill_m = 0;

  // ========== Top: 2 compact rows ==========
  const rowY1 = 75;
  const rowY2 = 20;
  const slotW = 240;

  let xPos = 16;

  // Top-right time scale + transport controls
  const tsSelectWidth = 150;
  const tsPanelRight = width - 24;
  const tsPanelX = tsPanelRight - tsSelectWidth;
  const tsPanelY = 10;
  createDiv('Time Scale')
    .position(tsPanelX, tsPanelY)
    .size(tsSelectWidth, 16)
    .style('color', '#EEE')
    .style('text-align', 'center')
    .style('font-size', '12px')
    .style('font-weight', 'bold');
  timeScaleSelect = createSelect()
    .position(tsPanelX, tsPanelY + 20)
    .size(tsSelectWidth, 26)
    .style('background', '#1f2937')
    .style('color', '#fff')
    .style('border', '1px solid #4ade80')
    .style('font-weight', 'bold');
  TIME_SCALE_ORDER.forEach(key => {
    const preset = TIME_SCALE_PRESETS[key];
    if (preset) timeScaleSelect.option(preset.label, key);
  });
  timeScaleSelect.changed(() => setTimeScale(timeScaleSelect.value()));
  syncTimeScaleControl();

  const procLabelY = tsPanelY + 46;
  createDiv('Processing Passes')
    .position(tsPanelX, procLabelY)
    .size(tsSelectWidth, 16)
    .style('color', '#EEE')
    .style('text-align', 'center')
    .style('font-size', '12px')
    .style('font-weight', 'bold');
  processingSelect = createSelect()
    .position(tsPanelX, procLabelY + 20)
    .size(tsSelectWidth, 26)
    .style('background', '#1f2937')
    .style('color', '#fff')
    .style('border', '1px solid #38bdf8')
    .style('font-weight', 'bold');
  PROCESSING_ORDER.forEach(key => {
    const preset = PROCESSING_PRESETS[key];
    if (preset) processingSelect.option(preset.label, key);
  });
  processingSelect.changed(() => setProcessingPreset(processingSelect.value()));
  syncProcessingControl();

  const btnRowY = procLabelY + 54;
  const btnSpacing = 6;
  const btnWidth = Math.floor((tsSelectWidth - btnSpacing * 2) / 3);
  playButton = createButton('PLAY')
    .position(tsPanelX, btnRowY)
    .size(btnWidth, 28)
    .style('background', '#1f2937')
    .style('color', '#f8fafc')
    .style('border', '1px solid #4ade80')
    .style('font-weight', 'bold')
    .mousePressed(resumeSimulation);
  pauseButton = createButton('PAUSE')
    .position(tsPanelX + btnWidth + btnSpacing, btnRowY)
    .size(btnWidth, 28)
    .style('background', '#1f2937')
    .style('color', '#f8fafc')
    .style('border', '1px solid #4ade80')
    .style('font-weight', 'bold')
    .mousePressed(pauseSimulation);
  resetButton = createButton('RESET')
    .position(tsPanelX + 2 * (btnWidth + btnSpacing), btnRowY)
    .size(btnWidth, 28)
    .style('background', '#1f2937')
    .style('color', '#f8fafc')
    .style('border', '1px solid #4ade80')
    .style('font-weight', 'bold')
    .mousePressed(resetSimulation);

  simClockDiv = createDiv('Day 0 ¬∑ 00:00:00')
    .position(tsPanelX, btnRowY + 36)
    .size(tsSelectWidth, 26)
    .style('color', '#f8fafc')
    .style('background', '#0f172a')
    .style('border', '1px solid #4ade80')
    .style('border-radius', '4px')
    .style('font-family', 'monospace')
    .style('font-size', '14px')
    .style('text-align', 'center')
    .style('line-height', '26px');
  syncSimControlButtons();
  updateSimClockDisplay();



  // Row 1: All sliders in ONE row
  mkLabel("DS MW", xPos, rowY1 - 14);
  dsMWSlider = createSlider(MW_MIN, MW_MAX, MW_DS, MW_STEP).position(xPos, rowY1).style('width', '160px');
  dsMWInput  = createInput(nf(MW_DS, 1, 1), 'number').position(xPos + 170, rowY1).size(55);
  xPos += slotW;

  mkLabel("DS Flow", xPos, rowY1 - 14);
  dsQSlider = createSlider(Q_MIN, Q_MAX, Q_DS, Q_STEP).position(xPos, rowY1).style('width', '160px');
  dsQInput  = createInput(nf(Q_DS, 1, 0), 'number').position(xPos + 170, rowY1).size(55);
  xPos += slotW;

  mkLabel("Bo MW", xPos, rowY1 - 14);
  boMWSlider = createSlider(MW_MIN, MW_MAX, MW_BO, MW_STEP).position(xPos, rowY1).style('width', '160px');
  boMWInput  = createInput(nf(MW_BO, 1, 1), 'number').position(xPos + 170, rowY1).size(55);
  xPos += slotW;

  mkLabel("Bo Flow", xPos, rowY1 - 14);
  boQSlider = createSlider(Q_MIN, Q_MAX, Q_BO, Q_STEP).position(xPos, rowY1).style('width', '160px');
  boQInput  = createInput(nf(Q_BO, 1, 0), 'number').position(xPos + 170, rowY1).size(55);
  xPos += slotW;

  mkLabel("Friction k", xPos, rowY1 - 14);
  kSlider = createSlider(0.0, 0.0002, K_FAC, 0.000005).position(xPos, rowY1).style('width', '160px');
  kInput  = createInput(nf(K_FAC, 1, 6), 'number').position(xPos + 170, rowY1).size(70);
  xPos += slotW + 20;

  mkLabel("SBP", xPos, rowY1 - 14);
  sbpSlider = createSlider(0, 3000, SBP_MANUAL, 10).position(xPos, rowY1).style('width', '160px');
  sbpInput  = createInput(nf(SBP_MANUAL, 1, 0), 'number').position(xPos + 170, rowY1).size(55);
  xPos += slotW;

  mkLabel("RPM", xPos, rowY1 - 14);
  rpmSlider = createSlider(0, 220, RPM, 5).position(xPos, rowY1).style('width', '160px');
  rpmInput  = createInput(String(RPM), 'number').position(xPos + 170, rowY1).size(55);
  xPos += slotW;

  mkLabel("CML Flow", xPos, rowY1 - 14);
  cmlQSlider = createSlider(Q_MIN, Q_MAX, Q_CML, Q_STEP).position(xPos, rowY1).style('width', '160px');
  cmlQInput  = createInput(nf(Q_CML || 0, 1, 0), 'number').position(xPos + 170, rowY1).size(55);

  // Row 2: Buttons and anchor inputs
  xPos = 16;

  mkLabel("CML AP Depth", xPos, rowY2 - 14);
  cmlApDepthInput = createInput('', 'number').position(xPos, rowY2).size(80);
  xPos += 90;

  // --- CML AP ECD (2 decimals, 0.01 step) ---
  cmlApEcdInput = makeTwoDecimalInput("CML AP ECD", xPos, rowY2, 0);
  xPos += 90;

  mkLabel("SBP AP Depth", xPos, rowY2 - 14);
  apDepthInput = createInput('', 'number').position(xPos, rowY2).size(80);
  xPos += 90;

  // --- SBP AP ECD (2 decimals, 0.01 step) ---
  apEcdInput = makeTwoDecimalInput("SBP AP ECD", xPos, rowY2, 0);
  xPos += 90;

  mkLabel("CML Depth", xPos, rowY2 - 14);
  cmlDepthInput = createInput(nf(CML_DEPTH || 0, 1, 0), 'number').position(xPos, rowY2).size(80);
  xPos += 100;

  // Buttons
  mpdBtn = createButton(MPD_ON ? 'MPD: ON' : 'MPD: OFF').size(90, 22).position(xPos, rowY2);
  xPos += 100;

  sbpModeBtn = createButton('SBP: ' + (SBP_MODE === 'manual' ? 'Manual' : 'Anchor')).size(110, 22).position(xPos, rowY2);
  xPos += 120;

  const mpdChokeLabel = () => MPD_CHOKE_LOCKED_CLOSED ? 'MPD Choke: CLOSED' : 'MPD Choke: AUTO';
  mpdChokeBtn = createButton(mpdChokeLabel()).size(140, 22).position(xPos, rowY2);
  xPos += 150;

  const rcdLabel = () => RCD_CLOSED ? 'RCD: CLOSED' : 'RCD: OPEN';
  rcdBtn = createButton(rcdLabel()).size(110, 22).position(xPos, rowY2);
  xPos += 120;

  cmlBtn = createButton(CML_ON ? 'CML: ON' : 'CML: OFF').size(90, 22).position(xPos, rowY2)
    .style('background', '#ffe74a').style('font-weight', 'bold');
  xPos += 100;

  cmlAutoBtn = createButton(AUTO_CML_ON ? 'Auto CML: ON' : 'Auto CML: OFF').size(120, 22).position(xPos, rowY2)
    .style('background', '#ffe74a').style('font-weight', 'bold');
  xPos += 130;

  captureBtn = createButton('Capture State').size(100, 22).position(xPos, rowY2);
  xPos += 110;

  displayBtn = createButton(showCaptured ? 'Display: ON' : 'Display: OFF').size(100, 22).position(xPos, rowY2);
  xPos += 110;
  // Add UI controls in setup() near CML controls:
mkLabel("Top Fill Flow", xPos, rowY2 - 14);
const topfillQInput = createInput('0', 'number').position(xPos, rowY2).size(80);
topfillQInput.input(() => { Q_TOPFILL = clamp(num(topfillQInput.value()), 0, Q_MAX); });
xPos += 90;

mkLabel("Top Fill MW", xPos, rowY2 - 14);
const topfillMWInput = createInput('9.5', 'number').position(xPos, rowY2).size(80);
topfillMWInput.input(() => { MW_TOPFILL = clamp(num(topfillMWInput.value()), MW_MIN, MW_MAX); });
xPos += 90;

const topfillBtn = createButton('Top Fill: OFF').size(100, 22).position(xPos, rowY2);
topfillBtn.mousePressed(() => {
  TOPFILL_ON = !TOPFILL_ON;
  topfillBtn.html(TOPFILL_ON ? 'Top Fill: ON' : 'Top Fill: OFF');
});
xPos += 110;

// ========== DIAGNOSTIC LOGGING BUTTONS ==========
mkLabel("Diagnostic Log", xPos, rowY2 - 14);
logStartBtn = createButton('START').size(70, 22).position(xPos, rowY2)
  .style('background', '#4ade80').style('font-weight', 'bold');
logStartBtn.mousePressed(() => {
  diagnosticLog.recording = true;
  diagnosticLog.data = [];
  diagnosticLog.startTime = millis();
  diagnosticLog.lastLogFrame = frameCount;
  logStartBtn.attribute('disabled', '');
  logStopBtn.removeAttribute('disabled');
});

logStopBtn = createButton('STOP').size(70, 22).position(xPos + 75, rowY2)
  .style('background', '#f87171').style('font-weight', 'bold');
logStopBtn.attribute('disabled', '');
logStopBtn.mousePressed(() => {
  diagnosticLog.recording = false;
  logStopBtn.attribute('disabled', '');
  logDownloadBtn.removeAttribute('disabled');
  logStartBtn.removeAttribute('disabled');
});

logDownloadBtn = createButton('SAVE').size(70, 22).position(xPos + 150, rowY2)
  .style('background', '#60a5fa').style('font-weight', 'bold');
logDownloadBtn.attribute('disabled', '');
logDownloadBtn.mousePressed(() => {
  saveDiagnosticLog();
});

    // small local helper (scoped to setup) to make 2-decimal number inputs
  function makeTwoDecimalInput(label, x, y, initial = 0) {
    mkLabel(label, x, y - 14);
    const input = createInput(nf(initial, 1, 2), 'number')
      .position(x, y)
      .size(80);
    input.attribute('step', '0.01');
    input.attribute('min', '0');              // optional
    input.attribute('inputmode', 'decimal');  // nicer mobile keyboard
    input.elt.addEventListener('change', () => {
      const v = Number(input.value());
      if (Number.isFinite(v)) input.value(v.toFixed(2));
    });
    return input;
  }
  // ========== Build bottom panels ==========
  buildRheologyUI(rheoFrameX + 16, frameY + 40);
  buildGelUI(gelFrameX + 16, frameY + 40);
  buildWellConfigurationUI(configFrameX + 16, frameY + 40);
  buildEnhancedHydraulicsPanel();
  doRheologyFit();
    publishRheoToGlobals(); //
  
  // Value bindings
  dsMWSlider.input(() => setDSMW(dsMWSlider.value()));
  dsMWInput.input(() => setDSMW(num(dsMWInput.value())));
  dsQSlider.input(() => setDSQ(dsQSlider.value()));
  dsQInput.input(() => setDSQ(num(dsQInput.value())));
  boMWSlider.input(() => setBOMW(boMWSlider.value()));
  boMWInput.input(() => setBOMW(num(boMWInput.value())));
  boQSlider.input(() => setBOQ(boQSlider.value()));
  boQInput.input(() => setBOQ(num(boQInput.value())));
  kSlider.input(() => setK(kSlider.value()));
  kInput.input(() => setK(num(kInput.value())));
  sbpSlider.input(() => { SBP_MANUAL = Number(sbpSlider.value()); sbpInput.value(nf(SBP_MANUAL,1,0)); });
  sbpInput.input(() => { SBP_MANUAL = Math.max(0, Number(sbpInput.value())||0); sbpSlider.value(SBP_MANUAL); });
  rpmSlider.input(() => setRPM(rpmSlider.value()));
  rpmInput.input(() => setRPM(Number(rpmInput.value())||0));
  apDepthInput.input(() => { ANCHOR_DEPTH = Math.max(0, num(apDepthInput.value())); });
  apEcdInput.input(() => { ANCHOR_ECD = Math.max(0, num(apEcdInput.value())); });
  cmlApDepthInput.input(() => { CML_AP_DEPTH = Math.max(0, num(cmlApDepthInput.value())); });
  cmlApEcdInput.input(() => { CML_AP_ECD = Math.max(0, num(cmlApEcdInput.value())); });
  cmlQSlider.input(() => { if (!AUTO_CML_ON){ Q_CML = cmlQSlider.value(); cmlQInput.value(nf(Q_CML,1,0)); }});
  cmlQInput.input(() => { if (!AUTO_CML_ON){ Q_CML = clamp(num(cmlQInput.value()), Q_MIN, Q_MAX); cmlQSlider.value(Q_CML); }});
  cmlDepthInput.input(() => { CML_DEPTH = clamp(num(cmlDepthInput.value()), 0, BOP_DEPTH); });
  
  mpdBtn.mousePressed(() => { MPD_ON = !MPD_ON; mpdBtn.html(MPD_ON ? 'MPD: ON' : 'MPD: OFF'); });
  mpdChokeBtn.mousePressed(() => {
    MPD_CHOKE_LOCKED_CLOSED = !MPD_CHOKE_LOCKED_CLOSED;
    mpdChokeBtn.html(MPD_CHOKE_LOCKED_CLOSED ? 'MPD Choke: CLOSED' : 'MPD Choke: AUTO');
  });
  rcdBtn.mousePressed(() => {
    RCD_CLOSED = !RCD_CLOSED;
    rcdBtn.html(RCD_CLOSED ? 'RCD: CLOSED' : 'RCD: OPEN');
  });
  sbpModeBtn.mousePressed(() => {
    SBP_MODE = (SBP_MODE === 'manual') ? 'anchor' : 'manual';
    sbpModeBtn.html(SBP_MODE === 'manual' ? 'SBP: Manual' : 'SBP: Anchor');
  });
  cmlBtn.mousePressed(() => {
    CML_ON = !CML_ON;
    if (!CML_ON) { CML_TOP_DEPTH = 0; }
    cmlBtn.html(CML_ON ? 'CML: ON' : 'CML: OFF');
  });
  cmlAutoBtn.mousePressed(() => {
    AUTO_CML_ON = !AUTO_CML_ON;
    cmlAutoBtn.html(AUTO_CML_ON ? 'Auto CML: ON' : 'Auto CML: OFF');
  });
  captureBtn.mousePressed(captureState);
  displayBtn.mousePressed(() => { 
    showCaptured = !showCaptured; 
    displayBtn.html(showCaptured ? 'Display: ON' : 'Display: OFF'); 
  });
  
  buildLossesUI();
  buildKicksUI();
  buildBOPWellControlUI();
  buildDiagnosticsUI();

  // Initialize formation fluid cells
  initializeFormationFluidCells();
}

function buildGelUI(x, y){
  mkLabel("Gel œÑ (Pa)", x, y-18);
  const gelIn = createInput(String(gel_Pa), 'number').position(x, y).size(70);
  gelIn.input(() => { gel_Pa = num(gelIn.value()); });

  const gelBtn = createButton(use_gel ? 'Gel: ON' : 'Gel: OFF').position(x+80, y).size(70,22);
  gelBtn.mousePressed(() => { use_gel = !use_gel; gelBtn.html(use_gel ? 'Gel: ON' : 'Gel: OFF'); });

  let y2 = y + 40;
  mkLabel("G10s", x, y2-16);
  rheoPanel.G10s = createInput(String(rheoDefaults.G10s),'number').position(x, y2).size(65);
  mkLabel("G10m", x+75, y2-16);
  rheoPanel.G10m = createInput(String(rheoDefaults.G10m),'number').position(x+75, y2).size(65);
  mkLabel("G30m", x+150, y2-16);
  rheoPanel.G30m = createInput(String(rheoDefaults.G30m),'number').position(x+150, y2).size(65);
}

function buildWellConfigurationUI(x, y){
  const colGap = 160;
  const col2X = x + colGap;
  let yRow = y;

  mkLabel("Riser ID (in)", x, yRow-16);
  const risIn = createInput(String(riser_ID_in),'number').position(x, yRow).size(70);
  risIn.input(() => { riser_ID_in = num(risIn.value()); riser_ID_m = riser_ID_in * 0.0254; });

  mkLabel("DS OD (in)", col2X, yRow-16);
  const dsoIn = createInput(String(ds_OD_in),'number').position(col2X, yRow).size(70);
  dsoIn.input(() => { ds_OD_in = num(dsoIn.value()); ds_OD_m = ds_OD_in * 0.0254; });

  yRow += 40;
  mkLabel("Casing ID (in)", x, yRow-16);
  const casIn = createInput(String(casing_ID_in),'number').position(x, yRow).size(70);
  casIn.input(() => { casing_ID_in = num(casIn.value()); casing_ID_m = casing_ID_in * 0.0254; });

  mkLabel("OH OD (in)", col2X, yRow-16);
  const ohIn = createInput(String(openhole_OD_in),'number').position(col2X, yRow).size(70);
  ohIn.input(() => { openhole_OD_in = num(ohIn.value()); openhole_ODm = openhole_OD_in * 0.0254; });

  yRow += 40;
  mkLabel("DS ID (in)", x, yRow-16);
  const dsiIn = createInput(String(ds_ID_in),'number').position(x, yRow).size(70);
  dsiIn.input(() => { ds_ID_in = num(dsiIn.value()); ds_ID_m = ds_ID_in * 0.0254; });

  mkLabel("Booster ID (in)", col2X, yRow-16);
  const boosterIdIn = createInput(String(booster_ID_in),'number').position(col2X, yRow).size(70);
  boosterIdIn.input(() => { booster_ID_in = num(boosterIdIn.value()); booster_ID_m = booster_ID_in * 0.0254; });

  yRow += 40;
  mkLabel("Choke ID (in)", x, yRow-16);
  const chokeIdIn = createInput(String(CHOKE_LINE_ID_in),'number').position(x, yRow).size(70);
  chokeIdIn.input(() => { CHOKE_LINE_ID_in = num(chokeIdIn.value()); CHOKE_LINE_ID_m = CHOKE_LINE_ID_in * 0.0254; });

  mkLabel("Kill ID (in)", col2X, yRow-16);
  const killIdIn = createInput(String(KILL_LINE_ID_in),'number').position(col2X, yRow).size(70);
  killIdIn.input(() => { KILL_LINE_ID_in = num(killIdIn.value()); KILL_LINE_ID_m = KILL_LINE_ID_in * 0.0254; });
}

if (typeof window.__qAnnAbove_m3s !== 'number' || typeof window.__qAnnBelow_m3s !== 'number') {
  if (typeof recomputeAnnulusSectionFlowsForLosses === 'function') {
    recomputeAnnulusSectionFlowsForLosses();
  }
}

// ========================================================================
// DIAGNOSTIC LOGGING FUNCTIONS
// ========================================================================
function captureDiagnosticData() {
  const timestamp = ((millis() - diagnosticLog.startTime) / 1000).toFixed(2);
  const fluidTop = annulusTopDepthGlobal();

  // Get average MW values
  const MW_DS_avg = dsAvgPPG ? dsAvgPPG() : (MW_DS || 0);
  const MW_BO_avg = boosterAvgPPG ? boosterAvgPPG() : (MW_BO || 0);

  // Flow routing values
  const qDS_m3s = (Q_DS || 0) / 15850.323;
  const qBO_m3s = (Q_BO || 0) / 15850.323;
  const qAnnUp_m3s = window.__qAnnUp_m3s || window.__qAnnAbove_m3s || 0;
  const qAnnDown_m3s = window.__qAnnDown_m3s || 0;
  const qAnnBelow_m3s = window.__qAnnBelow_m3s || 0;
  const qAnnAbove_m3s = window.__qAnnAbove_m3s || 0;

  // Build row
  const row = {
    time_s: timestamp,
    frameCount: frameCount,

    // Fluid properties
    MW_DS: MW_DS_avg.toFixed(2),
    MW_BO: MW_BO_avg.toFixed(2),

    // Flow rates
    Q_DS_gpm: (Q_DS || 0).toFixed(1),
    Q_BO_gpm: (Q_BO || 0).toFixed(1),
    Q_TF_gpm: (TOPFILL_ON ? (Q_TOPFILL || 0) : 0).toFixed(1),
    Q_CML_gpm: (Q_CML || 0).toFixed(1),
    FLOW_OUT_gpm: (FLOW_OUT_gpm || 0).toFixed(1),

    // Fluid level
    fluidTop_m: fluidTop.toFixed(1),
    riserFull: (fluidTop <= 0.5) ? 'YES' : 'NO',

    // Flow routing (section flows)
    qAnnUp_gpm: (qAnnUp_m3s * 15850.323).toFixed(1),
    qAnnDown_gpm: (qAnnDown_m3s * 15850.323).toFixed(1),
    qAnnBelow_gpm: (qAnnBelow_m3s * 15850.323).toFixed(1),
    qAnnAbove_gpm: (qAnnAbove_m3s * 15850.323).toFixed(1),

    // SBP
    SBP_psi: sbpAppliedPsi().toFixed(0),
    MPD_ON: MPD_ON ? 'YES' : 'NO'
  };

  // Loss zones data
  if (LOSSES_ON && Array.isArray(lossZones)) {
    for (let i = 0; i < lossZones.length; i++) {
      const z = lossZones[i];
      if (!z || !z.enabled) continue;

      const zoneNum = i + 1;
      const P_calc = pressureAtDepth(z.depth_m);
      const P_frac = z.fracPressure_psi || 0;
      const dP = P_calc - P_frac;
      const isWet = z.depth_m > fluidTop;
      const isActive = z._active || false;

      row[`Z${zoneNum}_depth_m`] = z.depth_m.toFixed(0);
      row[`Z${zoneNum}_P_calc_psi`] = P_calc.toFixed(1);
      row[`Z${zoneNum}_P_frac_psi`] = P_frac.toFixed(0);
      row[`Z${zoneNum}_dP_psi`] = dP.toFixed(1);
      row[`Z${zoneNum}_Qloss_gpm`] = (z.Qloss_gpm || 0).toFixed(1);
      row[`Z${zoneNum}_wet`] = isWet ? 'YES' : 'NO';
      row[`Z${zoneNum}_active`] = isActive ? 'YES' : 'NO';
    }
  }

  // Advection parameters (example - add what's most relevant)
  row.CELL_M = CELL_M;
  row.N_ABV = N_ABV;
  row.N_BELOW = N_BELOW;

  diagnosticLog.data.push(row);
}

function saveDiagnosticLog() {
  if (diagnosticLog.data.length === 0) {
    alert('No data to save. Start recording first.');
    return;
  }

  // Get all unique keys from all rows (for CSV header)
  const allKeys = new Set();
  diagnosticLog.data.forEach(row => {
    Object.keys(row).forEach(key => allKeys.add(key));
  });
  const headers = Array.from(allKeys);

  // Build CSV
  let csv = headers.join(',') + '\n';
  diagnosticLog.data.forEach(row => {
    const values = headers.map(h => row[h] !== undefined ? row[h] : '');
    csv += values.join(',') + '\n';
  });

  // Download
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  a.download = `diagnostic_log_${timestamp}.csv`;
  a.click();
  URL.revokeObjectURL(url);

  console.log(`Saved ${diagnosticLog.data.length} data points to CSV`);
}

function updateSBPState(){
  if (!MPD_ON){
    CURRENT_SBP = 0;
    return;
  }

  if (!sbpCanPressurizeAnnulus()){
    CURRENT_SBP = 0;
    return;
  }

  let applied = 0;
  if (SBP_MODE === "manual"){
    applied = Math.max(0, SBP_MANUAL);
  } else if (ANCHOR_DEPTH > 0 && ANCHOR_ECD > 0){
    const p_set = PSI_COEF * ANCHOR_ECD * ANCHOR_DEPTH;
    const p_actual = pressureAtDepth_noSBP(ANCHOR_DEPTH);
    applied = Math.max(0, p_set - p_actual);
  }

  CURRENT_SBP = applied;

  if (SBP_MODE === 'anchor'){
    if (sbpSlider) sbpSlider.value(CURRENT_SBP);
    if (sbpInput) sbpInput.value(nf(CURRENT_SBP, 1, 0));
  }
}

// ================================ DRAW =================================
function draw(){
  background(0,0,12);
  // Panels background bands
  noStroke();
  fill(210, 80, 30);
  rect(0, 0, width, 120);

  const middleBandBottom = (typeof frameY === 'number') ? Math.max(frameY - 40, 160) : height - 200;
  fill(30, 60, 20);
  rect(0, 120, width, middleBandBottom - 120);

  const bottomBandY = middleBandBottom;
  fill(210, 8, 26);
  rect(0, bottomBandY, width, height - bottomBandY);

  // Bottom frames (visual only; your UI inputs sit on top of these)
  drawBottomFrames();

  // ‚úÖ CRITICAL FIX: Update annulus flows BEFORE any pressure/friction calculations
  // The SBP logic below calls pressureAtDepth_noSBP() which needs friction which
  // needs window.__qAnnBelow_m3s. Update flows first to avoid 1-frame lag!
  // Call with dt_s=0 to just update flow variables without advancing simulation time
  updateLinePressureAnchors();
  routeAnnulusFlowsWithLosses(0);

  if (!BOP_CLOSED) {
    const refPsi = pressureAtDepth(BOP_DEPTH);
    if (isFinite(refPsi)) {
      lastOpenAnnulusPressure_psi = refPsi;
    }
    trappedAnnulusBasePressure_psi = null;
  }

  updateSBPState();
  // Update CML level and (if enabled) Auto-CML flow command BEFORE pressures are used
  updateCMLLevelAndControl();
  // Update BOP flow displays based on direction (UP = calculated/read-only, DOWN = user-editable)
  updateBOPFlowDisplays();
  updateBOPMWDisplays();
  // Well visuals and charts
  drawWellAndFluids();
  drawFractureSymbols();
  drawKickSymbols();
  drawDepthGrid();
  drawReferenceBadges();
  drawGaugesAndCharts();
 
  
// Time series logging (right before stepAdvection)
tsFrame++;
if (tsFrame % TS_STRIDE === 0){
  const totalIn = Q_DS + Q_BO;
  
  // Push to beginning (right-to-left display)
  tsData.totalFlowIn.unshift(totalIn);
  tsData.dsFlow.unshift(Q_DS);
  tsData.cmlFlow.unshift(Q_CML || 0);
  tsData.spp.unshift(lastSPP);
  tsData.sbpApplied.unshift(sbpAppliedPsi());
  
  
// Flow Out line (0‚ÄìQMAX)
const QMAX = (typeof Q_MAX !== 'undefined' && Q_MAX > 0) ? Q_MAX : 1000;
plotTimeSeriesLine(tsFlowOut_gpm, 0, QMAX, null);

// Choke line (0‚Äì100%)
plotTimeSeriesLine(tsChoke_pct, 0, 100, null);


  
  // SBP setpoint
  const sbpSet = (SBP_MODE === 'anchor' && ANCHOR_DEPTH > 0 && ANCHOR_ECD > 0) 
    ? (PSI_COEF * ANCHOR_ECD * ANCHOR_DEPTH) : NaN;
  tsData.sbpSetpoint.unshift(sbpSet);
  
  // CML anchor setpoint & actual
  const cmlSet = (AUTO_CML_ON && CML_AP_DEPTH > 0 && CML_AP_ECD > 0)
    ? (PSI_COEF * CML_AP_ECD * CML_AP_DEPTH) : NaN;
  const cmlAct = (AUTO_CML_ON && CML_AP_DEPTH > 0)
    ? pressureAtDepth(CML_AP_DEPTH) : NaN;
  tsData.cmlAnchorSet.unshift(cmlSet);
  tsData.cmlAnchorActual.unshift(cmlAct);
  
  // SBP anchor point setpoint & actual
  const sbpAPSet = (ANCHOR_DEPTH > 0 && ANCHOR_ECD > 0)
    ? (PSI_COEF * ANCHOR_ECD * ANCHOR_DEPTH) : NaN;
  const sbpAPAct = (ANCHOR_DEPTH > 0)
    ? pressureAtDepth(ANCHOR_DEPTH) : NaN;
  tsData.sbpAPSet.unshift(sbpAPSet);
  tsData.sbpAPActual.unshift(sbpAPAct);
  
  // Trim to max length
  for (let key in tsData) {
    if (tsData[key].length > TS_MAX) tsData[key].pop();
  }
}
  
  
  // Advection last (after SPP/levels reflect current step)
// ---- LOSSES ‚Üí FO ‚Üí CHOKE ‚Üí ADVECT ‚Üí LEVEL ----
// ---- PHYSICS UPDATE ORDER (Pattern A) ----
const dt_frame = frameSeconds();
window.dt_s = dt_frame;
if (!simulationPaused && dt_frame > 0){
  simElapsedSeconds += dt_frame;
  runProcessingPasses(dt_frame);
}

// 11. UI updates
refreshLossesUIFromModel();
updateDiagnosticsUI(dt_frame);
updateBOPPressureDisplays();
updateSimClockDisplay();

  // ========== DIAGNOSTIC LOGGING ==========
  // Capture data at regular intervals when recording
  if (diagnosticLog.recording && (frameCount - diagnosticLog.lastLogFrame) >= diagnosticLog.LOG_INTERVAL) {
    captureDiagnosticData();
    diagnosticLog.lastLogFrame = frameCount;
  }

  // Footer labels
  fill(0,0,95); textSize(12);
  text("Rheology/Hydraulics controls at bottom-left; SBP/MPD top-right.", width/2, height-16);
}

function lossAdaptiveIterationCount(){
  if (!LOSSES_ON) return 1;
  const totalLoss = (typeof totalLossRate_gpm === 'function') ? totalLossRate_gpm() : 0;
  const totalFlow = (Q_DS || 0) + (Q_BO || 0);
  const lossRatio = totalFlow > 10 ? totalLoss / Math.max(totalFlow, 1e-6) : 0;
  return (lossRatio > 0.3 || totalLoss > 500) ? 3 : 2;
}

function runSingleSimulationPass(dt_sub){
  computeImbalanceFlows();
  const adaptiveIters = lossAdaptiveIterationCount();
  equilibrateFluidLevel(dt_sub, adaptiveIters);
  updateSurfaceConnectedLevels(dt_sub);

  if (MPD_ON) updateChokeFromFO();

  stepAdvection();
  if (formationFluidEnabled) {
    updateFormationFluidMigration(dt_sub);
  }
  gravityDensitySwap();
}

function runProcessingPasses(totalDt){
  if (!(totalDt > 0)) return;
  const passes = Math.max(1, currentProcessingIterations());
  const dtPerPass = totalDt / passes;
  const prevDt = window.dt_s;
  for (let i = 0; i < passes; i++){
    window.dt_s = dtPerPass;
    withFrameDtOverride(dtPerPass, () => runSingleSimulationPass(dtPerPass));
  }
  window.dt_s = prevDt;
}



// ============================== DRAW HELPERS ===========================
function drawWellAndFluids(){
  const px = well.x + (well.w - dp.w) / 2;
  stroke(0, 0, 95); strokeWeight(2.5); noFill(); rect(well.x, well.y, well.w, well.h, 8);
  stroke(0, 0, 80); strokeWeight(5);
  line(px, well.y, px, well.y + well.h);
  line(px + dp.w, well.y, px + dp.w, well.y + well.h);
  noStroke();

  const yBOP = mapDepthToY(BOP_DEPTH);
  const boosterW = 12, boosterX = well.x - 20; // Moved booster further left for better spacing
  stroke(0, 0, 50, 160); strokeWeight(1.5); noFill(); rect(boosterX - boosterW/2, well.y, boosterW, yBOP - well.y, 3);

  const yTopWetBo = clipFillY_forBooster();
  const lvl_bo_m = clamp(levelDeficit_bo_m, 0, BOP_DEPTH);
  for (let i = 0; i < N_ABV; i++) {
    const dTop_m = i * CELL_M;
    const dBot_m = Math.min((i + 1) * CELL_M, BOP_DEPTH);
    if (dBot_m <= lvl_bo_m) continue;
    const yTop = mapDepthToY(Math.max(dTop_m, lvl_bo_m));
    const yBot = mapDepthToY(dBot_m);
    const hue = remap(boosterGrid[i], MW_MIN, MW_MAX, 170, 355);
    noStroke(); fill(hue, 70, 70, 210);
    rect(boosterX - boosterW/2 + 1, Math.max(yTop, yTopWetBo), boosterW - 2, yBot - Math.max(yTop, yTopWetBo));
  }

  if (levelDeficit_bo_m > 0.01) {
    const levelY_bo = mapDepthToY(Math.min(levelDeficit_bo_m, BOP_DEPTH));
    noStroke(); fill(0, 0, 0, 80); rect(boosterX - boosterW/2 + 1, well.y, boosterW - 2, levelY_bo - well.y);
    stroke(55, 80, 90); strokeWeight(2); line(boosterX - boosterW/2 + 3, levelY_bo, boosterX + boosterW/2 - 3, levelY_bo);
    noStroke(); fill(0, 0, 95); textAlign(RIGHT, CENTER); textSize(11);
    text(`Bo level ‚Üì ${nf(levelDeficit_bo_m,1,1)} m`, boosterX - boosterW/2 , levelY_bo);
    textAlign(CENTER, CENTER);
  }

  noStroke(); fill(0,0,80); triangle(boosterX + 1, yBOP - 16, boosterX + 1, yBOP - 4, boosterX + 12, yBOP - 10);
  push(); translate(boosterX - boosterW/2 - 10, (well.y + yBOP) / 2); rotate(-HALF_PI); fill(0, 0, 80); textSize(11); textAlign(CENTER, CENTER); text("Booster Line", 0, 0); pop();

  const xLeftAnn = well.x + 1;
  const xRightAnn = px + dp.w + 1;
  const wLeftAnn = Math.max(0, px - xLeftAnn - 1);
  const wRightAnn = Math.max(0, (well.x + well.w - 1) - xRightAnn);

  // ===== DRILLSTRING (INSIDE) =====
  const lvl_m = clamp(levelDeficit_m, 0, TD_DEPTH);
  const yTopWetDS = clipFillY_forDS();
  for (let i = 0; i < N_DS; i++) {
    const dTop_m = i * CELL_M;
    const dBot_m = Math.min((i + 1) * CELL_M, TD_DEPTH);
    if (dBot_m <= lvl_m) continue;
    const yTop = mapDepthToY(Math.max(dTop_m, lvl_m));
    const yBot = mapDepthToY(dBot_m);
    const hue = remap(dsGrid[i], MW_MIN, MW_MAX, 170, 355);
    fill(hue, 70, 70, 220); rect(px + 1, Math.max(yTop, yTopWetDS), dp.w - 2, yBot - Math.max(yTop, yTopWetDS));
  }

  if (levelDeficit_m > 0.01) {
    const levelY = mapDepthToY(Math.min(levelDeficit_m, TD_DEPTH));
    noStroke(); fill(0, 0, 0, 80); rect(px + 1, well.y, dp.w - 2, levelY - well.y);
    stroke(55, 80, 90); strokeWeight(2); line(px + 3, levelY, px + dp.w - 3, levelY);
    noStroke(); fill(0, 0, 95); textAlign(LEFT, CENTER); textSize(11);
    text(`DS level ‚Üì ${nf(levelDeficit_m, 1, 1)} m`, px + dp.w , levelY );
    textAlign(CENTER, CENTER);
  }

// ===== ANNULUS RISER (above BOP) =====
const annulusTop = annulusTopDepthGlobal(); // Global top (max of CML and loss)
const yTopWetRis = mapDepthToY(Math.min(annulusTop, BOP_DEPTH));

// Draw riser annulus cells (skip dry cells above annulusTop)
for (let i = 0; i < N_ABV; i++) {
  const dTop_m = i * CELL_M;
  const dBot_m = Math.min((i + 1) * CELL_M, BOP_DEPTH);
  
  // Skip completely dry cells
  if (dBot_m <= annulusTop) continue;
  
  const yTop = mapDepthToY(dTop_m);
  const yBot = mapDepthToY(dBot_m);
    const effMW = effectiveCellDensity_ppg(annAboveGrid[i] || MW_DS, i, true);
    const hue = remap(effMW, MW_MIN, MW_MAX, 170, 355);
  fill(hue, 70, 70, 190);
  const clippedTop = Math.max(yTop, yTopWetRis);
  const cellHeight = yBot - clippedTop;
  if (cellHeight > 0) {
    if (wLeftAnn > 0) rect(xLeftAnn, clippedTop, wLeftAnn, cellHeight);
    if (wRightAnn > 0) rect(xRightAnn, clippedTop, wRightAnn, cellHeight);
  }
}

// ===== ANNULUS BELOW BOP (casing + openhole) =====
const annulusBelowTop = Math.max(BOP_DEPTH, annulusTop);
for (let i = 0; i < N_BELOW; i++) {
  const dTop_m = BOP_DEPTH + i * CELL_M;
  const dBot_m = Math.min(BOP_DEPTH + (i + 1) * CELL_M, TD_DEPTH);
  
  // Skip cells above the wet top
  if (dBot_m <= annulusBelowTop) continue;
  
  const yTop = mapDepthToY(Math.max(dTop_m, annulusBelowTop));
  const yBot = mapDepthToY(dBot_m);
    const effMW = effectiveCellDensity_ppg(annBelowGrid[i] || MW_DS, i, false);
    const hue = remap(effMW, MW_MIN, MW_MAX, 170, 355);
  fill(hue, 70, 70, 210);
  if (wLeftAnn > 0) rect(xLeftAnn, yTop, wLeftAnn, yBot - yTop);
  if (wRightAnn > 0) rect(xRightAnn, yTop, wRightAnn, yBot - yTop);
}

// ===== FORMATION FLUIDS VISUALIZATION (LEFT SIDE) =====
// Extends from surface to TD, showing formation fluids in all regions
if (formationFluidEnabled) {
  const formFluidBarX = well.x - 110; // Further left to avoid clashing with depth ticks
  const formFluidBarW = 18;

  // Draw background bar (surface to TD)
  stroke(0, 0, 30); strokeWeight(1); fill(0, 0, 10, 150);
  rect(formFluidBarX, well.y, formFluidBarW, mapDepthToY(TD_DEPTH) - well.y, 3);

  // Draw formation fluid cells in RISER (above BOP)
  for (let i = 0; i < N_ABV; i++) {
    const dTop_m = i * CELL_M;
    const dBot_m = Math.min((i + 1) * CELL_M, BOP_DEPTH);

    const gasAmt = gasPhaseFrom_above[i] || 0;
    const oilAmt = oilPhaseFrom_above[i] || 0;
    const waterAmt = waterPhaseFrom_above[i] || 0;
    const totalFormFluid = gasAmt + oilAmt + waterAmt;

    if (totalFormFluid > 0.001) {
      const yTop = mapDepthToY(dTop_m);
      const yBot = mapDepthToY(dBot_m);
      const cellH = yBot - yTop;

      // Stack formation fluids (gas on top, then oil, then water)
      let yOffset = 0;

      if (gasAmt > 0.001) {
        const gasH = cellH * (gasAmt / totalFormFluid);
        const gasColor = FORMATION_FLUID_TYPES.GAS.color;
        noStroke(); fill(gasColor[0], gasColor[1], gasColor[2], 220);
        rect(formFluidBarX + 2, yTop + yOffset, formFluidBarW - 4, gasH);
        yOffset += gasH;
      }

      if (oilAmt > 0.001) {
        const oilH = cellH * (oilAmt / totalFormFluid);
        const oilColor = formationFluidType === 'BLACKOIL'
          ? FORMATION_FLUID_TYPES.BLACKOIL.color
          : FORMATION_FLUID_TYPES.OIL.color;
        noStroke(); fill(oilColor[0], oilColor[1], oilColor[2], 220);
        rect(formFluidBarX + 2, yTop + yOffset, formFluidBarW - 4, oilH);
        yOffset += oilH;
      }

      if (waterAmt > 0.001) {
        const waterH = cellH * (waterAmt / totalFormFluid);
        const waterColor = FORMATION_FLUID_TYPES.WATER.color;
        noStroke(); fill(waterColor[0], waterColor[1], waterColor[2], 220);
        rect(formFluidBarX + 2, yTop + yOffset, formFluidBarW - 4, waterH);
      }
    }
  }

  // Draw formation fluid cells in BELOW BOP (annulus below BOP)
  for (let i = 0; i < N_BELOW; i++) {
    const dTop_m = BOP_DEPTH + i * CELL_M;
    const dBot_m = Math.min(BOP_DEPTH + (i + 1) * CELL_M, TD_DEPTH);

    const gasAmt = gasPhaseFrom_below[i] || 0;
    const oilAmt = oilPhaseFrom_below[i] || 0;
    const waterAmt = waterPhaseFrom_below[i] || 0;
    const totalFormFluid = gasAmt + oilAmt + waterAmt;

    if (totalFormFluid > 0.001) {
      const yTop = mapDepthToY(dTop_m);
      const yBot = mapDepthToY(dBot_m);
      const cellH = yBot - yTop;

      // Stack formation fluids (gas on top, then oil, then water)
      let yOffset = 0;

      if (gasAmt > 0.001) {
        const gasH = cellH * (gasAmt / totalFormFluid);
        const gasColor = FORMATION_FLUID_TYPES.GAS.color;
        noStroke(); fill(gasColor[0], gasColor[1], gasColor[2], 220);
        rect(formFluidBarX + 2, yTop + yOffset, formFluidBarW - 4, gasH);
        yOffset += gasH;
      }

      if (oilAmt > 0.001) {
        const oilH = cellH * (oilAmt / totalFormFluid);
        const oilColor = formationFluidType === 'BLACKOIL'
          ? FORMATION_FLUID_TYPES.BLACKOIL.color
          : FORMATION_FLUID_TYPES.OIL.color;
        noStroke(); fill(oilColor[0], oilColor[1], oilColor[2], 220);
        rect(formFluidBarX + 2, yTop + yOffset, formFluidBarW - 4, oilH);
        yOffset += oilH;
      }

      if (waterAmt > 0.001) {
        const waterH = cellH * (waterAmt / totalFormFluid);
        const waterColor = FORMATION_FLUID_TYPES.WATER.color;
        noStroke(); fill(waterColor[0], waterColor[1], waterColor[2], 220);
        rect(formFluidBarX + 2, yTop + yOffset, formFluidBarW - 4, waterH);
      }
    }
  }

  // Label
  push();
  translate(formFluidBarX + formFluidBarW/2, (well.y + mapDepthToY(TD_DEPTH))/2);
  rotate(-HALF_PI);
  fill(0, 0, 90); textSize(10); textAlign(CENTER, CENTER);
  text("Formation Fluids", 0, 0);
  pop();
}

  // ===== DRY OVERLAYS & LABELS (UNIFIED WHEN EQUAL) =====

const cmlActive = CML_ON && CML_TOP_DEPTH > 0.01;
const lossActive = LOSSES_ON && LOSS_TOP_DEPTH_m > 0.01;
const topsDiffer = Math.abs((CML_TOP_DEPTH || 0) - (LOSS_TOP_DEPTH_m || 0)) > 10;
const canUnifyLevels = !BOP_CLOSED && cmlActive && lossActive && !topsDiffer;

if (canUnifyLevels) {
  // ‚úÖ UNIFIED: Both active and at same depth
  const levelY = mapDepthToY(Math.min(LOSS_TOP_DEPTH_m, TD_DEPTH));
  
  noStroke(); fill(0, 0, 0, 80);
  if (LOSS_TOP_DEPTH_m <= BOP_DEPTH) {
    if (wLeftAnn > 0) rect(xLeftAnn, well.y, wLeftAnn, levelY - well.y);
    if (wRightAnn > 0) rect(xRightAnn, well.y, wRightAnn, levelY - well.y);
  } else {
    const yBOP = mapDepthToY(BOP_DEPTH);
    if (wLeftAnn > 0) rect(xLeftAnn, yBOP, wLeftAnn, levelY - yBOP);
    if (wRightAnn > 0) rect(xRightAnn, yBOP, wRightAnn, levelY - yBOP);
  }
  
  stroke(30, 100, 90); strokeWeight(2); // Orange (CML+Loss)
  if (wLeftAnn > 0) line(xLeftAnn + 3, levelY, xLeftAnn + wLeftAnn - 3, levelY);
  if (wRightAnn > 0) line(xRightAnn + 3, levelY, xRightAnn + wRightAnn - 3, levelY);
  
  noStroke(); fill(30, 100, 95); textAlign(LEFT, CENTER); textSize(11);
  text(`Fluid top ‚Üì ${nf(LOSS_TOP_DEPTH_m,1,1)} m (CML+Loss)`, xRightAnn + 6, levelY);
  textAlign(CENTER, CENTER);
  
} else {
  // ‚úÖ SEPARATE: Show individually if different
  
  if (cmlActive) {
    const levelY_cml = mapDepthToY(Math.min(CML_TOP_DEPTH, BOP_DEPTH));
    noStroke(); fill(0, 0, 0, 80);
    if (wLeftAnn > 0) rect(xLeftAnn, well.y, wLeftAnn, levelY_cml - well.y);
    if (wRightAnn > 0) rect(xRightAnn, well.y, wRightAnn, levelY_cml - well.y);
    
    stroke(180, 80, 90); strokeWeight(2);
    if (wLeftAnn > 0) line(xLeftAnn + 3, levelY_cml, xLeftAnn + wLeftAnn - 3, levelY_cml);
    if (wRightAnn > 0) line(xRightAnn + 3, levelY_cml, xRightAnn + wRightAnn - 3, levelY_cml);
    
    noStroke(); fill(180, 80, 95); textAlign(LEFT, CENTER); textSize(11);
    text(`CML top ‚Üì ${nf(CML_TOP_DEPTH,1,1)} m`, xRightAnn + 6, levelY_cml);
    textAlign(CENTER, CENTER);
  }
  
  if (lossActive && (!canUnifyLevels)) {
    const levelY_loss = mapDepthToY(Math.min(LOSS_TOP_DEPTH_m, TD_DEPTH));
    noStroke(); fill(0, 0, 0, 60);

    if (LOSS_TOP_DEPTH_m <= BOP_DEPTH && !BOP_CLOSED) {
      if (wLeftAnn > 0) rect(xLeftAnn, well.y, wLeftAnn, levelY_loss - well.y);
      if (wRightAnn > 0) rect(xRightAnn, well.y, wRightAnn, levelY_loss - well.y);
    } else {
      const yBOP = mapDepthToY(BOP_DEPTH);
      if (wLeftAnn > 0) rect(xLeftAnn, yBOP, wLeftAnn, levelY_loss - yBOP);
      if (wRightAnn > 0) rect(xRightAnn, yBOP, wRightAnn, levelY_loss - yBOP);
    }
    
    stroke(0, 100, 90); strokeWeight(2);
    if (wLeftAnn > 0) line(xLeftAnn + 3, levelY_loss, xLeftAnn + wLeftAnn - 3, levelY_loss);
    if (wRightAnn > 0) line(xRightAnn + 3, levelY_loss, xRightAnn + wRightAnn - 3, levelY_loss);
    
    noStroke(); fill(0, 100, 95); textAlign(LEFT, CENTER); textSize(11);
    text(`Loss top ‚Üì ${nf(LOSS_TOP_DEPTH_m,1,1)} m`, xRightAnn + 6, levelY_loss);
    textAlign(CENTER, CENTER);
  }
}



// ===== BOP INDICATOR =====
// Draw BOP visual at BOP_DEPTH position
if (BOP_DEPTH > 0 && BOP_DEPTH <= TD_DEPTH) {
  const yBOP_vis = mapDepthToY(BOP_DEPTH);
  const bopWidth = well.w + 24; // Extends slightly beyond well
  const bopHeight = 12;
  const bopX = well.x - 12;

  if (BOP_CLOSED) {
    // Closed BOP - solid red rectangle
    noStroke();
    fill(0, 100, 85, 230); // Red in HSB
    rect(bopX, yBOP_vis - bopHeight/2, bopWidth, bopHeight, 2);

    // Label
    fill(0, 0, 100); // White text
    textSize(11);
    textAlign(CENTER, CENTER);
    text("BOP CLOSED", well.x + well.w/2, yBOP_vis);
  } else {
    // Open BOP - green outline
    stroke(120, 80, 90, 230); // Green in HSB
    strokeWeight(3);
    noFill();
    rect(bopX, yBOP_vis - bopHeight/2, bopWidth, bopHeight, 2);

    // Label
    noStroke();
    fill(120, 80, 95); // Green text
    textSize(11);
    textAlign(CENTER, CENTER);
    text("BOP OPEN", well.x + well.w/2, yBOP_vis);
  }
  textAlign(CENTER, CENTER); // Reset
}

// ===== KILL LINE VISUALIZATION (LEFT SIDE, NEXT TO BOOSTER) =====
// Always visible, positioned next to booster line
{
  const killLineW = 10;
  const boosterX = well.x - 20; // Match booster position
  const boosterW = 12;
  const killLineX = boosterX - boosterW/2 - 14; // Equal spacing as well-to-booster
  const yTop = well.y; // Surface
  const yBot = mapDepthToY(BOP_DEPTH); // BOP depth

  // Draw line pipe outline
  stroke(0, 0, 60, 180);
  strokeWeight(2);
  noFill();
  rect(killLineX - killLineW/2, yTop, killLineW, yBot - yTop, 3);

  // Draw fluid tracking cells (always visible, like booster line)
  const lvl_kill_m = clamp(levelDeficit_kill_m, 0, BOP_DEPTH);
  const yTopWetKill = mapDepthToY(Math.min(lvl_kill_m, BOP_DEPTH));

  for (let i = 0; i < N_ABV; i++) {
    const dTop_m = i * CELL_M;
    const dBot_m = Math.min((i + 1) * CELL_M, BOP_DEPTH);
    if (dBot_m <= lvl_kill_m) continue;
    const yTopCell = mapDepthToY(Math.max(dTop_m, lvl_kill_m));
    const yBotCell = mapDepthToY(dBot_m);
    const cellMW = killGrid[i] || MW_KILL;
    const hue = remap(cellMW, MW_MIN, MW_MAX, 170, 355);
    noStroke();
    fill(hue, 70, 70, 210);
    rect(killLineX - killLineW/2 + 1, Math.max(yTopCell, yTopWetKill), killLineW - 2, yBotCell - Math.max(yTopCell, yTopWetKill));
  }

  // Draw level deficit overlay if present
  if (levelDeficit_kill_m > 0.01) {
    const levelY_kill = mapDepthToY(Math.min(levelDeficit_kill_m, BOP_DEPTH));
    noStroke();
    fill(0, 0, 0, 80);
    rect(killLineX - killLineW/2 + 1, well.y, killLineW - 2, levelY_kill - well.y);
    stroke(55, 80, 90);
    strokeWeight(2);
    line(killLineX - killLineW/2 + 3, levelY_kill, killLineX + killLineW/2 - 3, levelY_kill);
  }

  // Draw flow arrows if flowing
  const killIsFlowing = Q_KILL > 0 && KILL_LINE_OPEN;
  if (killIsFlowing) {
    // Arrow color based on direction
    let arrowHue, arrowSat;
    if (KILL_DIRECTION === "DOWN") {
      arrowHue = 30; arrowSat = 90; // Orange for DOWN (pumping)
    } else {
      arrowHue = 200; arrowSat = 80; // Blue for UP (return)
    }

    noFill();
    stroke(arrowHue, arrowSat, 100, 255);
    strokeWeight(2);
    const numArrows = 3;
    const arrowSpacing = (yBot - yTop) / (numArrows + 1);
    for (let i = 1; i <= numArrows; i++) {
      const arrowY = KILL_DIRECTION === "DOWN"
        ? yTop + i * arrowSpacing
        : yBot - i * arrowSpacing;
      const arrowDir = KILL_DIRECTION === "DOWN" ? 1 : -1;
      const arrowSize = 6;

      // Main arrow shaft
      line(killLineX, arrowY - arrowDir * arrowSize, killLineX, arrowY + arrowDir * arrowSize);
      // Arrowhead barbs (point in direction of flow)
      line(killLineX, arrowY + arrowDir * arrowSize, killLineX - 3, arrowY + arrowDir * arrowSize - arrowDir * 3);
      line(killLineX, arrowY + arrowDir * arrowSize, killLineX + 3, arrowY + arrowDir * arrowSize - arrowDir * 3);
    }
  }

  // Label
  push();
  translate(killLineX - killLineW/2 - 10, (yTop + yBot)/2);
  rotate(-HALF_PI);
  noStroke();
  textSize(10);
  textAlign(CENTER, CENTER);
  if (killIsFlowing) {
    // Color based on direction
    if (KILL_DIRECTION === "DOWN") {
      fill(30, 90, 95); // Orange for DOWN
    } else {
      fill(200, 80, 95); // Blue for UP
    }
    text(`KILL ${nf(Q_KILL, 0, 0)} gpm ${KILL_DIRECTION}`, 0, 0);
  } else if (!KILL_LINE_OPEN) {
    fill(0, 0, 80);
    text(`KILL LINE (CLOSED)`, 0, 0);
  } else {
    fill(0, 0, 80);
    text(`KILL LINE`, 0, 0);
  }
  pop();

  // Valve indicator at surface
  const valveW = 14;
  const valveH = 8;
  const valveY = yTop + 15;
  if (KILL_LINE_OPEN) {
    // Open - green
    noStroke();
    fill(120, 80, 90, 200); // Green
  } else {
    // Closed - red
    noStroke();
    fill(0, 100, 85, 200); // Red
  }
  rect(killLineX - valveW/2, valveY - valveH/2, valveW, valveH, 2);
  // Valve indicator line
  stroke(0, 0, 100, 150);
  strokeWeight(1);
  line(killLineX - valveW/2 - 2, valveY, killLineX + valveW/2 + 2, valveY);
}

// ===== CHOKE LINE VISUALIZATION (RIGHT SIDE) =====
// Always visible, positioned on right side of well
{
  const chokeLineW = 10;
  const chokeLineX = well.x + well.w + 16; // Right side of well
  const yTop = well.y; // Surface
  const yBot = mapDepthToY(BOP_DEPTH); // BOP depth

  // Draw line pipe outline
  stroke(0, 0, 60, 180);
  strokeWeight(2);
  noFill();
  rect(chokeLineX - chokeLineW/2, yTop, chokeLineW, yBot - yTop, 3);

  // Draw fluid tracking cells (always visible, like booster line)
  const lvl_choke_m = clamp(levelDeficit_choke_m, 0, BOP_DEPTH);
  const yTopWetChoke = mapDepthToY(Math.min(lvl_choke_m, BOP_DEPTH));

  for (let i = 0; i < N_ABV; i++) {
    const dTop_m = i * CELL_M;
    const dBot_m = Math.min((i + 1) * CELL_M, BOP_DEPTH);
    if (dBot_m <= lvl_choke_m) continue;
    const yTopCell = mapDepthToY(Math.max(dTop_m, lvl_choke_m));
    const yBotCell = mapDepthToY(dBot_m);
    const cellMW = chokeGrid[i] || MW_CHOKE;
    const hue = remap(cellMW, MW_MIN, MW_MAX, 170, 355);
    noStroke();
    fill(hue, 70, 70, 210);
    rect(chokeLineX - chokeLineW/2 + 1, Math.max(yTopCell, yTopWetChoke), chokeLineW - 2, yBotCell - Math.max(yTopCell, yTopWetChoke));
  }

  // Draw level deficit overlay if present
  if (levelDeficit_choke_m > 0.01) {
    const levelY_choke = mapDepthToY(Math.min(levelDeficit_choke_m, BOP_DEPTH));
    noStroke();
    fill(0, 0, 0, 80);
    rect(chokeLineX - chokeLineW/2 + 1, well.y, chokeLineW - 2, levelY_choke - well.y);
    stroke(55, 80, 90);
    strokeWeight(2);
    line(chokeLineX - chokeLineW/2 + 3, levelY_choke, chokeLineX + chokeLineW/2 - 3, levelY_choke);
  }

  // Draw flow arrows if flowing
  const chokeIsFlowing = Q_CHOKE > 0 && CHOKE_LINE_OPEN;
  if (chokeIsFlowing) {
    // Arrow color based on direction
    let arrowHue, arrowSat;
    if (CHOKE_DIRECTION === "DOWN") {
      arrowHue = 30; arrowSat = 90; // Orange for DOWN (pumping)
    } else {
      arrowHue = 200; arrowSat = 80; // Blue for UP (return)
    }

    noFill();
    stroke(arrowHue, arrowSat, 100, 255);
    strokeWeight(2);
    const numArrows = 3;
    const arrowSpacing = (yBot - yTop) / (numArrows + 1);
    for (let i = 1; i <= numArrows; i++) {
      const arrowY = CHOKE_DIRECTION === "DOWN"
        ? yTop + i * arrowSpacing
        : yBot - i * arrowSpacing;
      const arrowDir = CHOKE_DIRECTION === "DOWN" ? 1 : -1;
      const arrowSize = 6;

      // Main arrow shaft
      line(chokeLineX, arrowY - arrowDir * arrowSize, chokeLineX, arrowY + arrowDir * arrowSize);
      // Arrowhead barbs (point in direction of flow)
      line(chokeLineX, arrowY + arrowDir * arrowSize, chokeLineX - 3, arrowY + arrowDir * arrowSize - arrowDir * 3);
      line(chokeLineX, arrowY + arrowDir * arrowSize, chokeLineX + 3, arrowY + arrowDir * arrowSize - arrowDir * 3);
    }
  }

  // Label
  push();
  translate(chokeLineX + chokeLineW/2 + 12, (yTop + yBot)/2);
  rotate(-HALF_PI);
  noStroke();
  textSize(10);
  textAlign(CENTER, CENTER);
  if (chokeIsFlowing) {
    // Color based on direction
    if (CHOKE_DIRECTION === "DOWN") {
      fill(30, 90, 95); // Orange for DOWN
    } else {
      fill(200, 80, 95); // Blue for UP
    }
    text(`CHOKE ${nf(Q_CHOKE, 0, 0)} gpm ${CHOKE_DIRECTION}`, 0, 0);
  } else if (!CHOKE_LINE_OPEN) {
    fill(0, 0, 80);
    text(`CHOKE LINE (CLOSED)`, 0, 0);
  } else {
    fill(0, 0, 80);
    text(`CHOKE LINE`, 0, 0);
  }
  pop();

  // Valve indicator at surface
  const valveW = 14;
  const valveH = 8;
  const valveY = yTop + 15;
  if (CHOKE_LINE_OPEN) {
    // Open - green
    noStroke();
    fill(120, 80, 90, 200); // Green
  } else {
    // Closed - red
    noStroke();
    fill(0, 100, 85, 200); // Red
  }
  rect(chokeLineX - valveW/2, valveY - valveH/2, valveW, valveH, 2);
  // Valve indicator line
  stroke(0, 0, 100, 150);
  strokeWeight(1);
  line(chokeLineX - valveW/2 - 2, valveY, chokeLineX + valveW/2 + 2, valveY);
}

// MPD RCD cap
if (MPD_ON && RCD_CLOSED){
  const capY = well.y - 8;
  const xL = well.x + 2;
  const xR = well.x + well.w - 2;
  noStroke();
  fill(0, 80, 80, 230);
  rect(xL, capY, xR - xL, 14, 3);
  fill(0,0,100);
  textSize(12);
  textAlign(CENTER, BASELINE);
  text("RCD", (xL + xR)/2, capY + 12);
  textAlign(CENTER, CENTER);
}

drawCMLVisual();
}

function drawFractureSymbols(){
  if (!LOSSES_ON || !Array.isArray(lossZones)) return;
  
  const symbolSize = 24;
  const xPos = well.x + well.w + 30; // To the right of the well
  
  for (const z of lossZones) {
    if (!z || !z.enabled || !(z.depth_m > 0)) continue;
    
    const y = mapDepthToY(z.depth_m);
    const zoneFracPsi = z.fracPressure_psi || 0;
    const bhpAtZone = pressureAtDepth(z.depth_m);
    const overbalancePsi = bhpAtZone - zoneFracPsi;
    const isActive = overbalancePsi > 1; // Treat as active whenever BHP exceeds fracture pressure
    
    push();
    translate(xPos, y);
    
    // Draw explosion/burst symbol
    if (isActive) {
      // Active fracture - animated burst
      const pulsePhase = (frameCount % 30) / 30;
      const pulse = 1 + 0.3 * Math.sin(pulsePhase * TWO_PI);
      
      // Bright red/orange burst
      fill(0, 100, 100, 200); // Red in HSB
      stroke(30, 100, 100, 255); // Orange
      strokeWeight(2);
      
      // Draw starburst
      for (let i = 0; i < 8; i++) {
        const angle = (i * TWO_PI / 8) + pulsePhase * PI;
        const r1 = symbolSize * 0.3 * pulse;
        const r2 = symbolSize * 0.6 * pulse;
        line(
          cos(angle) * r1, sin(angle) * r1,
          cos(angle) * r2, sin(angle) * r2
        );
      }
      
      // Center circle
      noStroke();
      fill(0, 100, 100, 255);
      circle(0, 0, symbolSize * 0.4 * pulse);
      
    } else {
      // Dormant fracture - static crack symbol
      stroke(0, 0, 60, 180); // Gray
      strokeWeight(2);
      noFill();
      
      // Draw crack lines
      beginShape();
      vertex(-symbolSize/3, -symbolSize/3);
      vertex(0, 0);
      vertex(symbolSize/3, -symbolSize/4);
      endShape();
      
      beginShape();
      vertex(0, 0);
      vertex(-symbolSize/4, symbolSize/3);
      endShape();
      
      beginShape();
      vertex(0, 0);
      vertex(symbolSize/4, symbolSize/4);
      endShape();
    }
    
    // Label
    noStroke();
    fill(isActive ? color(0, 100, 100) : color(0, 0, 80));
    textSize(10);
    textAlign(LEFT, CENTER);
    const qStr = isActive ? ` (${nf(z.Qloss_gpm, 1, 0)} gpm)` : '';
    text(`${nf(z.depth_m, 1, 0)}m${qStr}`, symbolSize/2 + 8, 0);
    
    pop();
  }
}

function drawKickSymbols(){
  if (!formationFluidEnabled || formationFluidDepth_m <= 0) return;

  const symbolSize = 20;
  const xPos = well.x - 40; // To the left of the well to avoid chart overlap

  const y = mapDepthToY(formationFluidDepth_m);

  // Calculate influx rate to determine if active
  let influxRate_gpm = 0;
  if (kickMode === 'MANUAL') {
    influxRate_gpm = formationFluidRate_gpm;
  } else if (kickMode === 'PRESSURE_DRIVEN') {
    const BHP_psi = pressureAtDepth(formationFluidDepth_m);
    const deltaP = Math.max(0, porePressure_psi - BHP_psi);
    influxRate_gpm = productivityIndex_gpm_psi * deltaP;
  }

  const isActive = influxRate_gpm > 1; // Active if influx >1 gpm

  push();
  translate(xPos, y);

  // Draw triangle symbol
  if (isActive) {
    // Active kick - pulsing triangle
    const pulsePhase = (frameCount % 40) / 40;
    const pulse = 1 + 0.2 * Math.sin(pulsePhase * TWO_PI);

    // Bright color based on fluid type
    const fluidProps = FORMATION_FLUID_TYPES[formationFluidType];
    const fluidColor = fluidProps ? fluidProps.color : [0, 100, 100];

    fill(fluidColor[0], fluidColor[1], fluidColor[2], 200);
    stroke(fluidColor[0], Math.min(100, fluidColor[1] + 20), Math.min(100, fluidColor[2] + 20), 255);
    strokeWeight(2);

    // Draw upward-pointing triangle (indicating influx rising)
    const size = symbolSize * pulse;
    beginShape();
    vertex(0, -size * 0.6);           // Top point
    vertex(-size * 0.5, size * 0.4);  // Bottom left
    vertex(size * 0.5, size * 0.4);   // Bottom right
    endShape(CLOSE);

    // Add small arrows inside to show upward movement
    stroke(0, 0, 100, 200);
    strokeWeight(1.5);
    const arrowY = size * 0.1 * (1 - pulsePhase);
    line(0, arrowY, 0, arrowY - size * 0.25);
    line(0, arrowY - size * 0.25, -size * 0.1, arrowY - size * 0.15);
    line(0, arrowY - size * 0.25, size * 0.1, arrowY - size * 0.15);

  } else {
    // Dormant kick zone - static triangle outline
    const fluidProps = FORMATION_FLUID_TYPES[formationFluidType];
    const fluidColor = fluidProps ? fluidProps.color : [0, 60, 60];

    stroke(fluidColor[0], fluidColor[1] * 0.6, fluidColor[2] * 0.6, 150);
    strokeWeight(1.5);
    noFill();

    // Draw upward-pointing triangle
    beginShape();
    vertex(0, -symbolSize * 0.6);
    vertex(-symbolSize * 0.5, symbolSize * 0.4);
    vertex(symbolSize * 0.5, symbolSize * 0.4);
    endShape(CLOSE);
  }

  // Label
  noStroke();
  const fluidProps = FORMATION_FLUID_TYPES[formationFluidType];
  const fluidColor = fluidProps ? fluidProps.color : [0, 100, 100];
  fill(isActive ? color(fluidColor[0], fluidColor[1], fluidColor[2]) : color(0, 0, 70));
  textSize(10);
  textAlign(LEFT, CENTER);
  const qStr = isActive ? ` (${nf(influxRate_gpm, 1, 0)} gpm)` : '';
  const typeStr = fluidProps ? ` ${fluidProps.name}` : '';
  text(`${nf(formationFluidDepth_m, 1, 0)}m${typeStr}${qStr}`, symbolSize/2 + 12, 0);

  pop();
}

function drawCMLVisual(){
  if (!CML_ON) return;
  const yPump = mapDepthToY(CML_DEPTH);
  const chokeLineX = well.x + well.w + 16;
  const pumpSize = 16;
  const pumpX = chokeLineX + 44;
  noStroke(); fill(55, 100, 100, 240);
  rect(pumpX, yPump - pumpSize/2, pumpSize, pumpSize, 3);

  const pipeW = 12;
  const pipeX = pumpX + pumpSize + 12;
  stroke(0,0,50,160); noFill();
  const yTop = well.y;
  rect(pipeX - pipeW/2, yTop, pipeW, yPump - yTop, 3);
  noStroke();
  for (let i = 0; i < N_ABV; i++){
    const dTop = i * CELL_M;
    const dBot = Math.min((i+1) * CELL_M, BOP_DEPTH);
    if (dTop >= CML_DEPTH) break;
    const segTop = mapDepthToY(dTop);
    const segBot = mapDepthToY(Math.min(dBot, CML_DEPTH));
    const hue = remap(cmlPipeGrid[i], MW_MIN, MW_MAX, 170, 355);
    fill(hue, 70, 70, 210);
    rect(pipeX - pipeW/2 + 1, segTop, pipeW - 2, segBot - segTop);
  }
  stroke(55,100,100); strokeWeight(2);
  line(pipeX, yTop + 8, pipeX, yTop + 28);
  line(pipeX - 5, yTop + 14, pipeX, yTop + 8);
  line(pipeX + 5, yTop + 14, pipeX, yTop + 8);
}

function drawBottomFrames(){
  const row1Panels = [
    { x: rheoFrameX,   w: rheoFrameW,   y: frameY, label: "Rheology" },
    { x: gelFrameX,    w: gelFrameW,    y: frameY, label: "Gel Configuration" },
    { x: configFrameX, w: configFrameW, y: frameY, label: "Well Configuration" },
    { x: enhFrameX,    w: enhFrameW,    y: frameY, label: "Enhanced Hydraulics" }
  ];

  const row2Panels = [
    { x: lossFrameX, w: lossFrameW, y: frameY2, label: "Losses" },
    { x: kickFrameX, w: kickFrameW, y: frameY2, label: "Kick Control" },
    { x: bopFrameX,  w: bopFrameW,  y: frameY2, label: "BOP Well Control" },
    { x: diagFrameX, w: diagFrameW, y: frameY2, label: "Diagnostics" }
  ];

  const bannerInset = 24;
  const bannerX = bottomPanelPadding - bannerInset;
  const bannerW = W - 2 * (bottomPanelPadding - bannerInset);
  const bannerY = frameY - 40;
  const bannerH = frameHeight * 2 + bottomPanelRowSpacing + 90;

  push();
  noStroke();
  fill(210, 10, 15, 140);
  rect(bannerX, bannerY + 6, bannerW, bannerH, 28);
  fill(210, 25, 12, 160);
  rect(bannerX, bannerY, bannerW, bannerH, 28);
  pop();

  const drawPanel = (panel) => {
    push();
    const x = panel.x, y = panel.y, w = panel.w, h = frameHeight;
    stroke(200, 10, 70, 160);
    strokeWeight(2);
    fill(210, 20, 12, 190);
    rect(x, y, w, h, 14);
    noStroke();
    fill(0, 0, 95);
    textAlign(LEFT, TOP);
    textSize(13);
    text(panel.label, x + 16, y + 14);
    pop();
  };

  row1Panels.forEach(drawPanel);
  row2Panels.forEach(drawPanel);

  // Friction status badge anchored to BOP panel (row 2)
  const badgeWidth = (typeof bopPanelW === 'number') ? bopPanelW : 450;
  const badgeX = bopFrameX + badgeWidth/2;
  const badgeY = frameY2 + 28;
  drawBadge(badgeX, badgeY, `Friction: ${FRICTION_MODE}`, `Model: ${HYDRAULICS_MODEL} ‚Ä¢ Rheo: ${ACTIVE_RHEO_MODEL}`);
}




function drawDepthGrid(){
  fill(0,0,80); noStroke(); textSize(12);
  for (let d=0; d<=MAX_DEPTH; d+=1000){
    const y = mapDepthToY(d);
    text(d+" m", well.x -75, y);
    stroke(0,0,60,120); line(well.x-40, y, well.x+well.w+40, y); noStroke();
  }
}

function drawReferenceBadges(){
  const starX = well.x - 40;
  for (const m of MARKS){
    let y = mapDepthToY(m.d);

    // Offset badge if at BOP depth to avoid overlap with BOP indicator
    const yBOP = mapDepthToY(BOP_DEPTH);
    if (m.d === BOP_DEPTH && BOP_CLOSED) {
      y = y + 25; // Offset down when BOP closed
    }

    drawStar(starX, y);
    const p = pressureAtDepth(m.d);
    const ecdEff = ecdWithSBPAtDepth(m.d);
    drawBadgeSm(well.x + well.w/2, y, `${m.name} ‚Ä¢ ${nf(p,0,0)} psi`, `Eff. ECD ‚Ä¢ ${nf(ecdEff,1,2)} ppg`);
  }
}

// Smaller badge for reference marks (reduced size to avoid clutter)
function drawBadgeSm(cx, cy, line1, line2){
  push(); translate(cx,cy);
  const boxW=160, boxH=32; // Reduced from 190x38
  fill(0,0,20,200); rect(-boxW/2,-boxH/2,boxW,boxH,5);
  fill(0,0,95); textAlign(CENTER,CENTER); textSize(10); text(line1,0,-5);
  textSize(9); fill(0,0,80); text(line2,0,9);
  pop();
}

function drawGaugesAndCharts(){
  const layoutCenter = well.x + well.w / 2;
  const gaugeGap = (R * 2) + 450; // Increased gap to push gauges far outside the well
  const cxSPP = layoutCenter - gaugeGap / 2;
  const cxBo  = layoutCenter + gaugeGap / 2;
  const cyTop = well.y + 48;

  const vSPPraw = surfacePumpPressure();
  lastSPP = updateSPP(vSPPraw);
  drawGauge(cxSPP, cyTop, lastSPP, 16000, "SPP", "psi", R, "left");
  if (levelDeficit_m > 0.01){
    textAlign(LEFT, CENTER); textSize(11); fill(0,0,95);
    text(`DS level ‚Üì ${nf(levelDeficit_m,1,1)} m`, cxSPP - 48, cyTop + 40);
    textAlign(CENTER, CENTER);
  }

  const vBo = updateBoosterSPP(boosterPumpPressure());
  drawGauge(cxBo, cyTop, vBo, 16000, "Booster SPP", "psi", R, "right");
  if (levelDeficit_bo_m > 0.01){
    textAlign(LEFT, CENTER); textSize(11); fill(0,0,95);
    text(`Bo level ‚Üì ${nf(levelDeficit_bo_m,1,1)} m`, cxBo - 32 , cyTop + 40);
    textAlign(CENTER, CENTER);
  }

  // Depth gauges anchored beneath the top gauges
  const depthLevels = [
    { depth: BOP_DEPTH,  label: "BOP" },
    { depth: SHOE_DEPTH, label: "Shoe" },
    { depth: TD_DEPTH,   label: "TD" }
  ];

  depthLevels.forEach(level => {
    const yPos = mapDepthToY(level.depth);
    drawGauge(cxSPP, yPos, pressureAtDepth(level.depth), 16000, level.label, "psi", R, "left");
    drawGauge(cxBo,  yPos, ecdWithSBPAtDepth(level.depth), 18, level.label, "ppg", R, "right");
  });

  const chartTop = Math.max(140, well.y - 10);
  const chartHeight = 420;
  // Align depth charts to end at the BOP panel right edge
  const chartsTotalWidth = 70 + 260 + 40 + 340; // dx + wP + gap + wE = 710
  const gaugeRightEdge = Math.max(cxSPP, cxBo) + R;
  const desiredChartStart = gaugeRightEdge + 40;
  const maxChartStart = width - chartsTotalWidth - 40;
  const depthChartStart = constrain(desiredChartStart, 40, Math.max(40, maxChartStart));
  drawCharts(depthChartStart, chartTop, chartHeight);

  const timeChartWidth = 640;
  const timeChartX = rheoFrameX; // Align with rheology frame on the left
  drawTimeChart(timeChartX, chartTop, timeChartWidth, chartHeight);

  drawModeStatusPanel();
}

// === Loss-zone markers on depth charts ===
function drawLossMarkersOnPressure(px, py, w, h, padL, padR, padT, padB, xMinPsi, xMaxPsi, col) {
  if (!LOSSES_ON) return;
  push();
  stroke(col || color(60, 100, 0));
  strokeWeight(1.5);
  fill(255, 200);
  textSize(10);
  textAlign(LEFT, CENTER);

  const x0 = px + padL, x1 = px + w - padR;
  const y0 = py + padT, y1 = py + h - padB;

  for (const z of lossZones) {
    if (!z.enabled || z.depth_m <= 0 || z.fracPressure_psi <= 0) continue;
    // map depth -> y (0 at surface at top of chart)
    const y = map(z.depth_m, 0, TD_DEPTH, y0, y1);
    // map fracture pressure -> x
    const x = map(z.fracPressure_psi, xMinPsi, xMaxPsi, x0, x1);

    // crosshair
    stroke(255, 120, 120, 200);
    line(x - 6, y, x + 6, y);
    line(x, y - 6, x, y + 6);

    // label
    noStroke();
    fill(255, 180);
    text(`${nf(z.fracPressure_psi,1,0)} psi @ ${nf(z.depth_m,1,0)} m`, x + 8, y);
  }
  pop();
}

function drawLossMarkersOnECD(px, py, w, h, padL, padR, padT, padB, xMinPpg, xMaxPpg, col) {
  if (!LOSSES_ON) return;
  push();
  stroke(col || color(0, 80, 80));
  strokeWeight(1.5);
  fill(255, 200);
  textSize(10);
  textAlign(LEFT, CENTER);

  const x0 = px + padL, x1 = px + w - padR;
  const y0 = py + padT, y1 = py + h - padB;

  for (const z of lossZones) {
    if (!z.enabled || z.depth_m <= 0 || z.fracPressure_psi <= 0) continue;

    // Convert fracture pressure at that depth to "fracture gradient" in ppg for the ECD panel
    // FG_ppg = P_frac / (PSI_COEF * depth)
    const fg_ppg = z.depth_m > 0 ? (z.fracPressure_psi / (PSI_COEF * z.depth_m)) : NaN;
    if (!isFinite(fg_ppg)) continue;

    const y = map(z.depth_m, 0, TD_DEPTH, y0, y1);
    const x = map(fg_ppg, xMinPpg, xMaxPpg, x0, x1);

    // crosshair
    stroke(255, 120, 120, 200);
    line(x - 6, y, x + 6, y);
    line(x, y - 6, x, y + 6);

    // label
    noStroke();
    fill(255, 180);
    text(`${nf(fg_ppg,1,2)} ppg @ ${nf(z.depth_m,1,0)} m`, x + 8, y);
  }
  pop();
}

function drawModeStatusPanel(){
  const blockW = Math.min(Math.max(well.w + 120, 380), 560);
  const blockX = well.x + (well.w - blockW) / 2;
  const blockY = well.y + well.h + 16;
  const lineSpacing = 18;

  push();
  noStroke();
  fill(210, 15, 12, 170);
  rect(blockX, blockY, blockW, 92, 12);
  fill(0, 0, 95);
  textAlign(LEFT, TOP);
  textSize(12);

  const mwAbove = average(annAboveGrid);
  let cursorY = blockY + 10;
  text(`Annulus MW above BOP: ${nf(mwAbove, 1, 2)} ppg`, blockX + 14, cursorY);

  cursorY += lineSpacing;
  text(`SBP: ${nf(sbpAppliedPsi(),1,0)} psi (${SBP_MODE.toUpperCase()})`, blockX + 14, cursorY);

  if (ANCHOR_DEPTH > 0 && ANCHOR_ECD > 0) {
    cursorY += lineSpacing;
    text(`SBP Anchor: ${nf(ANCHOR_DEPTH,1,0)} m @ ${nf(ANCHOR_ECD,1,2)} ppg`, blockX + 14, cursorY);
  }

  const cmlMode = AUTO_CML_ON ? 'AUTO' : 'MANUAL';
  const topDepth = riserTopDepth();
  let cmlAnchor = '';
  if (AUTO_CML_ON && CML_AP_DEPTH > 0 && CML_AP_ECD > 0) {
    cmlAnchor = ` | Anchor ${nf(CML_AP_DEPTH,1,0)} m @ ${nf(CML_AP_ECD,1,2)} ppg`;
  }

  cursorY += lineSpacing;
  text(`CML: ${cmlMode} @ ${nf(CML_DEPTH,1,0)} m${cmlAnchor}`, blockX + 14, cursorY);

  cursorY += lineSpacing;
  text(`Q_out ${nf(Q_CML,1,0)} gpm | Riser top ${nf(topDepth,1,1)} m`, blockX + 14, cursorY);
  pop();
}

// === Panel-aware polyline plotter for time-series (newest at left index 0) ===
function plotSeriesInPanel(px, py, w, h, padL, padR, padT, padB, data, ymin, ymax, col) {
  if (!data || !data.length) return;
  const x0 = px + padL, x1 = px + w - padR;
  const y0 = py + padT, y1 = py + h - padB;
  push();
  if (col) stroke(col); else stroke(255);
  noFill();
  beginShape();
  const N = data.length;
  for (let i = 0; i < N; i++) {
    const x = map(i, 0, N - 1, x0, x1);                 // oldest on right
    const yv = constrain(data[i], ymin, ymax);
    const y = map(yv, ymin, ymax, y1, y0);
    vertex(x, y);
  }
  endShape();
  pop();
}


function drawCharts(x0, top = 150, h = 420){
  const wP = 260, wE = 340, gap = 40;
  const padL = 54, padR = 18, padT = 28, padB = 42;
  const axisCol = color(0, 0, 95);
  const gridCol = color(0, 0, 60, 120);
  const lineColP = color(0, 80, 80);

  const dx = 70;

  // -------- Pressure-depth (psi) --------
  const px = x0 + dx, py = top;
  drawChartPanel(px, py, wP, h, "Pressure (psi)");
  drawChartGrid(px, py, wP, h, padL, padR, padT, padB, gridCol);
  if (BOP_CLOSED) {
    const appliedColor = lineColP;
    const riserDashColor = color(hue(lineColP), saturation(lineColP), brightness(lineColP), 150);
    const activeBopSeg = (typeof dominantBopLineSegment === 'function') ? dominantBopLineSegment() : null;
    const useIsolatedRiserTop = !activeBopSeg;
    let isolatedRiserTop = NaN;
    if (useIsolatedRiserTop) {
      const globalTop = (typeof annulusTopDepthGlobal === 'function')
        ? annulusTopDepthGlobal()
        : 0;
      isolatedRiserTop = clamp(Math.min(globalTop, BOP_DEPTH), 0, BOP_DEPTH);
    }
    const wellPressureFn = (d) => {
      if (d >= BOP_DEPTH) {
        return pressureAtDepth(d);
      }
      return bopLinePressureAboveBOP(d);
    };
    plotDepthFunctionAdvanced(px, py, wP, h, padL, padR, padT, padB,
      wellPressureFn, 0, 16000, appliedColor, { strokeWeight: 3.2 });

    const riserPressureFn = (d) => {
      if (d > BOP_DEPTH) return NaN;
      const opts = { includeBopLines: false, includeClosedWell: false };
      if (useIsolatedRiserTop && Number.isFinite(isolatedRiserTop)) {
        opts.overrideFluidTop = isolatedRiserTop;
      }
      return pressureAtDepth(d, opts);
    };
    plotDepthFunctionAdvanced(px, py, wP, h, padL, padR, padT, padB,
      riserPressureFn, 0, 16000, riserDashColor,
      { depthMax: BOP_DEPTH, dashed: true, strokeWeight: 2.2 });
  } else {
    plotDepthFunction(px, py, wP, h, padL, padR, padT, padB, d => pressureAtDepth(d), 0, 16000, lineColP);
  }
  drawAxes(px, py, wP, h, padL, padR, padT, padB, axisCol);
  drawDepthTicks(px, py, wP, h, padL, padR, padT, padB, axisCol);
  drawXTicks(px, py, wP, h, padL, padR, padT, padB, axisCol, 0, 16000, [0, 4000, 8000, 12000, 16000]);

  if (showCaptured && capturedP){
    plotDepthOverlay(px, py, wP, h, padL, padR, padT, padB, capturedP, 0, 16000, color(55,80,80));
  }
// --- Loss markers on PRESSURE chart (yellow star at Pressure√óDepth) ---
{
  const xL = px + padL, xR = px + wP - padR;
  const yT = py + padT, yB = py + h - padB;
  const pMin = 0, pMax = 16000;

  if (LOSSES_ON && Array.isArray(lossZones)) {
    for (const z of lossZones) {
      if (!z || !z.enabled || !(z.depth_m > 0) || !(z.fracPressure_psi > 0)) continue;

      const y = map(z.depth_m, 0, MAX_DEPTH, yT, yB, true);
      const x = map(z.fracPressure_psi, pMin, pMax, xL, xR, true);

      // yellow star
      if (typeof drawStar === 'function') {
        drawStar(x, y, 7, 3.5, 5, color(60, 100, 100));
      } else {
        // fallback: small yellow cross
        push(); stroke(color(60,100,100)); strokeWeight(2);
        line(x-6,y, x+6,y); line(x,y-6, x,y+6); pop();
      }

      // small label
      push();
      noStroke(); fill(0,0,95); textSize(10); textAlign(LEFT, BOTTOM);
      const q = (z.Qloss_gpm || 0);
      text(`Loss @ ${nf(z.depth_m,1,0)} m (${q>0 ? `‚âà${nf(q,1,0)} gpm` : '‚âà0 gpm'})`, x + 8, y - 2);
      pop();
    }
  }
}

// --- Kick markers on PRESSURE chart (triangle at Pore Pressure√óDepth) ---
{
  if (formationFluidEnabled && formationFluidDepth_m > 0) {
    const xL = px + padL, xR = px + wP - padR;
    const yT = py + padT, yB = py + h - padB;
    const pMin = 0, pMax = 16000;

    const y = map(formationFluidDepth_m, 0, MAX_DEPTH, yT, yB, true);

    // In pressure-driven mode, show pore pressure; in manual mode, show BHP
    let markerPressure_psi;
    if (kickMode === 'PRESSURE_DRIVEN') {
      markerPressure_psi = porePressure_psi;
    } else {
      markerPressure_psi = pressureAtDepth(formationFluidDepth_m);
    }

    const x = map(markerPressure_psi, pMin, pMax, xL, xR, true);

    // Draw triangle
    push();
    const fluidProps = FORMATION_FLUID_TYPES[formationFluidType];
    const fluidColor = fluidProps ? fluidProps.color : [0, 100, 100];
    fill(fluidColor[0], fluidColor[1], fluidColor[2], 180);
    stroke(fluidColor[0], fluidColor[1], fluidColor[2], 255);
    strokeWeight(1.5);
    const size = 8;
    beginShape();
    vertex(x, y - size);           // Top point
    vertex(x - size * 0.7, y + size * 0.5);  // Bottom left
    vertex(x + size * 0.7, y + size * 0.5);   // Bottom right
    endShape(CLOSE);

    // Label
    noStroke(); fill(fluidColor[0], fluidColor[1], fluidColor[2]);
    textSize(10); textAlign(LEFT, BOTTOM);
    const typeStr = fluidProps ? fluidProps.name : 'Kick';
    const pressureLabel = kickMode === 'PRESSURE_DRIVEN' ? `P_pore=${nf(porePressure_psi,1,0)} psi` : `BHP=${nf(markerPressure_psi,1,0)} psi`;
    text(`${typeStr} @ ${nf(formationFluidDepth_m,1,0)} m (${pressureLabel})`, x + 10, y - 2);
    pop();
  }
}




  // -------- ECD-depth (ppg) --------
  const ex = px + wP + gap, ey = top;
  drawChartPanel(ex, ey, wE, h, "ECD (ppg)");
  drawChartGrid(ex, ey, wE, h, padL, padR, padT, padB, gridCol);
  const ecdMainColor = color(0, 80, 80);
  const ecdDashColor = color(hue(ecdMainColor), saturation(ecdMainColor), brightness(ecdMainColor), 150);
  const ecdValueSafe = (val) => (isFinite(val) ? val : NaN);

  if (BOP_CLOSED) {
    const appliedEcdFn = (d) => {
      if (d >= BOP_DEPTH) {
        return ecdValueSafe(ecdWithSBPAtDepth(d));
      }
      return ecdValueSafe(bopLineEcdAtDepth(d));
    };
    plotDepthFunctionAdvanced(ex, ey, wE, h, padL, padR, padT, padB,
      appliedEcdFn, 6, 18, ecdMainColor, { strokeWeight: 3.2 });

    const riserEcdFn = (d) => (d <= BOP_DEPTH) ? ecdValueSafe(ecdWithSBPAtDepth(d)) : NaN;
    plotDepthFunctionAdvanced(ex, ey, wE, h, padL, padR, padT, padB,
      riserEcdFn, 6, 18, ecdDashColor, { depthMax: BOP_DEPTH, dashed: true, strokeWeight: 2.2 });
  } else {
    const openEcdFn = (d) => ecdValueSafe(ecdWithSBPAtDepth(d));
    plotDepthFunctionAdvanced(ex, ey, wE, h, padL, padR, padT, padB,
      openEcdFn, 6, 18, ecdMainColor, { strokeWeight: 3 });
  }
  drawAxes(ex, ey, wE, h, padL, padR, padT, padB, axisCol);
  drawDepthTicks(ex, ey, wE, h, padL, padR, padT, padB, axisCol);
  drawXTicks(ex, ey, wE, h, padL, padR, padT, padB, axisCol, 6, 18, [6, 9, 12, 15, 18]);

  if (showCaptured && capturedECD){
    plotDepthOverlayMasked(ex, ey, wE, h, padL, padR, padT, padB, capturedECD, 6, 18, color(55,80,80), v => isFinite(v) && v > 6 && v <= 18 );
  }

// --- Loss markers on ECD chart (yellow star at FG_ppg√óDepth) ---
{
  const xL = ex + padL, xR = ex + wE - padR;
  const yT = ey + padT, yB = ey + h - padB;
  const eMin = 6, eMax = 18;

  if (LOSSES_ON && Array.isArray(lossZones)) {
    for (const z of lossZones) {
      if (!z || !z.enabled || !(z.depth_m > 0) || !(z.fracPressure_psi > 0)) continue;

      // fracture gradient in ppg at the selected depth
      const fg_ppg = z.depth_m > 0 ? (z.fracPressure_psi / (PSI_COEF * z.depth_m)) : NaN;
      if (!isFinite(fg_ppg)) continue;

      const y = map(z.depth_m, 0, MAX_DEPTH, yT, yB, true);
      const x = map(fg_ppg, eMin, eMax, xL, xR, true);

      // yellow star
      if (typeof drawStar === 'function') {
        drawStar(x, y, 7, 3.5, 5, color(60, 100, 100));
      } else {
        // fallback: small yellow cross
        push(); stroke(color(60,100,100)); strokeWeight(2);
        line(x-6,y, x+6,y); line(x,y-6, x,y+6); pop();
      }

      // small label
      push();
      noStroke(); fill(0,0,95); textSize(10); textAlign(LEFT, BOTTOM);
      text(`${nf(fg_ppg,1,2)} ppg @ ${nf(z.depth_m,1,0)} m`, x + 8, y - 2);
      pop();
    }
  }
}

// --- Kick markers on ECD chart (triangle at formation fluid density√óDepth) ---
{
  if (formationFluidEnabled && formationFluidDepth_m > 0) {
    const xL = ex + padL, xR = ex + wE - padR;
    const yT = ey + padT, yB = ey + h - padB;
    const eMin = 6, eMax = 18;

    const y = map(formationFluidDepth_m, 0, MAX_DEPTH, yT, yB, true);

    const fluidProps = FORMATION_FLUID_TYPES[formationFluidType];
    const fluid_ppg = fluidProps ? fluidProps.density_ppg : 8.33;
    let eq_ppg = fluid_ppg;
    if (formationFluidDepth_m > 0 && isFinite(porePressure_psi)) {
      const denom = Math.max(PSI_COEF * formationFluidDepth_m, 1e-6);
      eq_ppg = porePressure_psi / denom;
    }

    const x = map(eq_ppg, eMin, eMax, xL, xR, true);

    // Draw triangle
    push();
    const fluidColor = fluidProps ? fluidProps.color : [0, 100, 100];
    fill(fluidColor[0], fluidColor[1], fluidColor[2], 180);
    stroke(fluidColor[0], fluidColor[1], fluidColor[2], 255);
    strokeWeight(1.5);
    const size = 8;
    beginShape();
    vertex(x, y - size);           // Top point
    vertex(x - size * 0.7, y + size * 0.5);  // Bottom left
    vertex(x + size * 0.7, y + size * 0.5);   // Bottom right
    endShape(CLOSE);

    // Label
    noStroke(); fill(fluidColor[0], fluidColor[1], fluidColor[2]);
    textSize(10); textAlign(LEFT, BOTTOM);
    const typeStr = fluidProps ? fluidProps.name : 'Kick';
    text(`${typeStr}: ${nf(eq_ppg,1,2)} ppg eq @ ${nf(formationFluidDepth_m,1,0)} m (P_pore=${nf(porePressure_psi,1,0)} psi)`, x + 10, y - 2);
    pop();
  }
}

function _tsCap(){ return (typeof TS_MAX === 'number' && TS_MAX > 0) ? TS_MAX : 600; }
// --- Losses time series (gpm) ---
if (!Array.isArray(window.tsLoss_gpm)) window.tsLoss_gpm = [];

  
  // -------- TIME SERIES panel --------
}



// ---------- Helpers used by charts ----------
function drawChartPanel(x, y, w, h, title){
  noStroke(); fill(0,0,20,200); rect(x-10, y-14, w+20, h+44, 10);
  fill(0,0,0); rect(x, y, w, h, 8);
  fill(0,0,95); noStroke(); textSize(14); textAlign(CENTER, TOP);
  text(title, x + w/2, y + h + 6);
}
function drawChartGrid(x,y,w,h,padL,padR,padT,padB,col){
  const innerW=w-padL-padR, innerH=h-padT-padB;
  const left=x+padL, top=y+padT, right=x+w-padR, bottom=y+h-padB;
  stroke(col); strokeWeight(1);
  for (let i=1; i<4; i++){ const xx = left + (innerW*i)/4; line(xx, top, xx, bottom); }
  for (let d=1000; d<MAX_DEPTH; d+=1000){
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    line(left, yy, right, yy);
  }
}
function drawAxes(x,y,w,h,padL,padR,padT,padB,col){
  const left = x + padL, top = y + padT, right = x + w - padR, bottom = y + h - padB;
  stroke(col); strokeWeight(2);
  line(left, top, left, bottom);
  line(left, bottom, right, bottom);
}
function drawDepthTicks(x,y,w,h,padL,padR,padT,padB,col){
  const innerH=h-padT-padB, left=x+padL, top=y+padT;
  fill(col); noStroke(); textSize(11); textAlign(RIGHT, CENTER);
  stroke(col); strokeWeight(1.5);
  for (let d=0; d<=MAX_DEPTH; d+=1000){
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    line(left-5, yy, left, yy);
    noStroke(); text(`${d}`, left-8, yy); stroke(col);
  }
}
function drawXTicks(x,y,w,h,padL,padR,padT,padB,col,vmin,vmax,ticks){
  const innerW=w-padL-padR, left=x+padL, bottom=y+h-padB;
  fill(col); noStroke(); textSize(11); textAlign(CENTER, TOP);
  stroke(col); strokeWeight(1.5);
  for (const t of ticks){
    const xx = left + remap(t, vmin, vmax, 0, innerW, true);
    line(xx, bottom, xx, bottom+5);
    noStroke(); text(`${t}`, xx, bottom+8); stroke(col);
  }
}

function plotDepthFunctionAdvanced(x,y,w,h,padL,padR,padT,padB,f,xmin,xmax,col, options = {}){
  const innerW=w-padL-padR, innerH=h-padT-padB;
  const left=x+padL, top=y+padT, right=x+w-padR, bottom=y+h-padB;
  const depthMin = (typeof options.depthMin === 'number') ? options.depthMin : 0;
  const depthMax = (typeof options.depthMax === 'number') ? options.depthMax : MAX_DEPTH;
  const step = options.step || 25;
  const strokeW = options.strokeWeight || 3;
  const dashed = !!options.dashed;
  const dashPattern = options.dashPattern || [8, 6];

  const ctx = drawingContext;
  if (dashed && ctx && ctx.setLineDash) ctx.setLineDash(dashPattern);

  stroke(col); strokeWeight(strokeW); noFill();
  let drawing = false;
  for (let d=0; d<=MAX_DEPTH; d+=step){
    if (d < depthMin - 1e-3 || d > depthMax + 1e-3) {
      if (drawing){ endShape(); drawing = false; }
      continue;
    }
    const val = f(d);
    if (!isFinite(val)) {
      if (drawing){ endShape(); drawing = false; }
      continue;
    }
    const xx = left + remap(val, xmin, xmax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    if (!drawing){ beginShape(); drawing = true; }
    vertex(xx, yy);
  }
  if (drawing) endShape();

  if (dashed && ctx && ctx.setLineDash) ctx.setLineDash([]);

  // TD line
  const yTD = top + innerH; // At bottom
  stroke(0,0,95); strokeWeight(2.5);
  line(left, yTD, right, yTD);
}

function plotDepthFunction(x,y,w,h,padL,padR,padT,padB,f,xmin,xmax,col){
  plotDepthFunctionAdvanced(x,y,w,h,padL,padR,padT,padB,f,xmin,xmax,col);
}

function plotDepthFunctionMasked(x,y,w,h,padL,padR,padT,padB,f,xmin,xmax,col, valid){
  const innerW=w-padL-padR, innerH=h-padT-padB;
  const left=x+padL, top=y+padT, right=x+w-padR;
  let drawing = false;
  stroke(col); strokeWeight(3); noFill();
  for (let d=0; d<=MAX_DEPTH; d+=25){
    const val = f(d), ok = valid(val);
    const xx = left + remap(val, xmin, xmax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    if (ok){
      if (!drawing){ beginShape(); drawing = true; }
      vertex(xx, yy);
    } else {
      if (drawing){ endShape(); drawing = false; }
    }
  }
  if (drawing) endShape();
  const yTD = top + remap(TD_DEPTH, 0, MAX_DEPTH, 0, innerH, true);
  stroke(0,0,95); strokeWeight(2.5); line(left, yTD, right, yTD);
}
function plotDepthOverlay(x,y,w,h,padL,padR,padT,padB,arr,ymin,ymax,col){
  const step = 25, innerW = w - padL - padR, innerH = h - padT - padB;
  const left = x + padL, top = y + padT;
  noFill(); stroke(col); strokeWeight(2); beginShape();
  for (let i=0, d=0; d<=MAX_DEPTH; i++, d+=step){
    const val = arr[i];
    const xx = left + remap(val, ymin, ymax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    vertex(xx, yy);
  } endShape();
}
function plotDepthOverlayMasked(x,y,w,h,padL,padR,padT,padB,arr,ymin,ymax,col, valid){
  const step = 25, innerW = w - padL - padR, innerH = h - padT - padB;
  const left = x + padL, top = y + padT;
  let drawing = false;
  stroke(col); strokeWeight(2); noFill();
  for (let i=0, d=0; d<=MAX_DEPTH; i++, d+=step){
    const val = arr[i], ok = valid(val);
    const xx = left + remap(val, ymin, ymax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    if (ok){
      if (!drawing){ beginShape(); drawing = true; }
      vertex(xx, yy);
    } else {
      if (drawing){ endShape(); drawing = false; }
    }
  }
  if (drawing) endShape();
}
function drawBadge(cx, cy, line1, line2, withStar=false){
  push(); translate(cx,cy);
  const boxW=190, boxH=38;
  if (withStar){ noStroke(); fill(55,80,90); star(-boxW/2-12,0,4,9,5); }
  fill(0,0,20,230); rect(-boxW/2,-boxH/2,boxW,boxH,6);
  fill(0,0,95); textAlign(CENTER,CENTER); textSize(12); text(line1,0,-6);
  textSize(10); fill(0,0,80); text(line2,0,10);
  pop();
}
function drawGauge(cx, cy, value, vMax, label, units, r, labelSide){
  noFill(); stroke(0,0,95); strokeWeight(2.5); arc(cx,cy,r*2,r*2,PI,TWO_PI);
  strokeWeight(6); stroke(120,60,80); arc(cx,cy,r*2,r*2, PI,PI+0.33*PI);
  stroke(40,70,80); arc(cx,cy,r*2,r*2, PI+0.33*PI,PI+0.66*PI);
  stroke(0,80,80); arc(cx,cy,r*2,r*2, PI+0.66*PI,TWO_PI);
  const norm = clamp(value/Math.max(1e-9,vMax),0,1);
  const ang = PI + norm*PI;
  stroke(0,0,95); strokeWeight(2.5); line(cx,cy,cx+r*cos(ang),cy+r*sin(ang));
  noStroke(); fill(0,0,95); circle(cx,cy,7);
  fill(0,0,95); textSize(Math.max(12,Math.round(r*0.26)));
  const dec=(units==='ppg'?2:0); text(`${nf(value,0,dec)} ${units}`,cx,cy+(r*0.35));
  fill(0,0,80); textSize(Math.max(10,Math.round(r*0.18)));
  textAlign(labelSide==="left"?RIGHT:LEFT,CENTER);
  const lx=labelSide==="left"?(cx-r-14):(cx+r+14);
  text(label,lx,cy);
  textAlign(CENTER,CENTER);
}
function drawStar(x,y){ push(); noStroke(); fill(55, 80, 90); star(x, y, 4, 9, 5); pop(); }
function star(x,y,r1,r2,n){
  let a=TWO_PI/n, h=a/2; beginShape();
  for(let ang=0; ang<TWO_PI; ang+=a){
    vertex(x+cos(ang)*r2, y+sin(ang)*r2);
    vertex(x+cos(ang+h)*r1, y+sin(ang+h)*r1);
  } endShape(CLOSE);
}

// ---------- Safe CML series buffers (avoid TDZ) ----------
function ensureCMLSeries(){
  if (!Array.isArray(window.tsCMLPact)) window.tsCMLPact = [];
  if (!Array.isArray(window.tsCMLPset)) window.tsCMLPset = [];
}

function drawTimeChart(x, y, w, h){
  drawChartPanel(x, y, w, h, "Time Series");

  const padL = 54, padR = 18, padT = 38, padB = 42;
  const innerW = w - padL - padR;
  const innerH = h - padT - padB;
  const left = x + padL, topI = y + padT, right = x + w - padR, bottom = y + h - padB;

  // Grid
  const gridCol = color(0, 0, 30, 120);
  stroke(gridCol); strokeWeight(1);
  for (let i=1; i<4; i++){
    const xx = left + innerW*i/4;
    line(xx, topI, xx, bottom);
  }
  for (let i=1; i<6; i++){
    const yy = topI + innerH*i/6;
    line(left, yy, right, yy);
  }

  // Axes
  stroke(0, 0, 95); strokeWeight(2);
  line(left, topI, left, bottom);
  line(left, bottom, right, bottom);

  // Scales
  const maxQ = Math.max(100, (typeof Q_MAX!=='undefined' && Q_MAX>0 ? Q_MAX : 1000) * 1.1);
  const maxP = 16000;

  // Panel-aware plot util (newest sample at index 0 ‚Üí right side)
  const plotSeriesLHS = (data, col, maxVal) => {
    if (!data || !data.length) return;
    noFill(); stroke(col); strokeWeight(2);
    beginShape();
    const N = Math.min(data.length, (typeof TS_MAX!=='undefined'?TS_MAX:600));
    for (let i=0; i<N; i++){
      const val = data[i];
      if (!isFinite(val)) continue;
      const t = i / Math.max(1, N - 1);
      const xx = right - t * innerW;            // right-to-left time
      const yy = bottom - remap(val, 0, maxVal, 0, innerH, true);
      vertex(xx, yy);
    }
    endShape();
  };

  // Core series (left scale for flow, right now we just use left-scale)
  plotSeriesLHS(tsData.totalFlowIn || [], color(180, 60, 90), maxQ);
  plotSeriesLHS(tsData.dsFlow       || [], color(200, 70, 85), maxQ);
  plotSeriesLHS(tsData.cmlFlow      || [], color(50,  80, 80), maxQ);
  // Losses (left scale, gpm) ‚Äî use the same flow scale (maxQ or QMAX)
plotSeriesLHS(window.tsLoss_gpm || [], color(340, 75, 90), maxQ);


  // Pressure series (left scale = makes them small visually; if you want a true RHS, we can add it)
  plotSeriesLHS(tsData.spp          || [], color(30,  80, 90), maxP);
  plotSeriesLHS(tsData.sbpSetpoint  || [], color(280, 70, 85), maxP);
  plotSeriesLHS(tsData.sbpApplied   || [], color(300, 70, 80), maxP);
  plotSeriesLHS(tsData.cmlAnchorSet || [], color(210, 85, 85), maxP);
  plotSeriesLHS(tsData.cmlAnchorActual||[], color(25,  85, 90), maxP);
  plotSeriesLHS(tsData.sbpAPSet     || [], color(55,  100,80), maxP);
  plotSeriesLHS(tsData.sbpAPActual  || [], color(120, 60, 80), maxP);

  // === Overlays: Flow Out & Choke, inside this panel ===
  const QMAX = (typeof Q_MAX !== 'undefined' && Q_MAX > 0) ? Q_MAX : 1000;

  // Flow Out (left scale, gpm)
  if (Array.isArray(tsFlowOut_gpm)) {
    plotSeriesLHS(tsFlowOut_gpm, color(200, 60, 95), QMAX);
  }

  // Choke Position (%) ‚Äî map to left scale for now (0‚Äì100 ‚Üí 0‚ÄìQMAX)
  if (Array.isArray(tsChoke_pct)) {
    const mapped = tsChoke_pct.map(v => v * QMAX / 100);
    plotSeriesLHS(mapped, color(40, 90, 85), QMAX);
  }

  // Legends (panel-local)
  const legend = [
    {label: 'Total Flow In', col: color(180, 60, 90)},
    {label: 'DS Flow', col: color(200, 70, 85)},
    {label: 'CML Flow', col: color(50, 80, 80)},
    {label: 'SPP', col: color(30, 80, 90)},
    {label: 'SBP Setpoint', col: color(280, 70, 85)},
    {label: 'SBP Applied', col: color(300, 70, 80)},
    {label: 'CML Anchor Set', col: color(210, 85, 85)},
    {label: 'CML Anchor Actual', col: color(25, 85, 90)},
    {label: 'SBP AP Set', col: color(55, 100, 80)},
    {label: 'SBP AP Actual', col: color(120, 60, 80)},
    {label: 'Losses (gpm)', col: color(340, 75, 90) },
    {label: 'Flow Out (gpm)', col: color(200, 60, 95)},
    {label: 'Choke Position (%)', col: color(40, 90, 85)}

  ];

  const lgX = right - 200, lgY = topI + 10;
  const lgW = 190, lgH = legend.length * 16 + 10;

  noStroke(); fill(0, 0, 10, 230);
  rect(lgX, lgY, lgW, lgH, 4);

  textAlign(LEFT, CENTER); textSize(10);
  for (let i=0; i<legend.length; i++){
    const yy = lgY + 8 + i*16;
    fill(legend[i].col);
    rect(lgX + 6, yy-4, 20, 8, 2);
    fill(0, 0, 95);
    text(legend[i].label, lgX + 30, yy);
  }
}

// Panel-aware polyline plotter (newest sample at index 0)
function plotSeriesInPanel(px, py, w, h, padL, padR, padT, padB, data, ymin, ymax, col) {
  if (!data || !data.length) return;
  const x0 = px + padL, x1 = px + w - padR;
  const y0 = py + padT, y1 = py + h - padB;
  push();
  if (col) stroke(col); else stroke(255);
  noFill();
  beginShape();
  const N = data.length;
  for (let i = 0; i < N; i++) {
    const x = map(i, 0, N - 1, x0, x1);
    const yv = constrain(data[i], ymin, ymax);
    const y = map(yv, ymin, ymax, y1, y0);
    vertex(x, y);
  }
  endShape();
  pop();
}


// --------- UI BUILDERS ---------
function buildRheologyUI(x, y){
  const mk = (lbl, key, def, dx=0, w=70) => {
    mkLabel(lbl, x + dx, y - 18);
    const el = createInput(String(def), 'number').position(x + dx, y).size(w);
    rheoPanel[key] = el;
    return el;
  };
  // Fann dial set + PV/YP
  let dx = 0, step = 70, block = 90;
  mk("R600", "R600", rheoDefaults.R600, dx); dx+=step;
  mk("R300", "R300", rheoDefaults.R300, dx); dx+=step;
  mk("R200", "R200", rheoDefaults.R200, dx); dx+=step;
  mk("R100", "R100", rheoDefaults.R100, dx); dx+=step;
  mk("R6",   "R6",   rheoDefaults.R6,   dx); dx+=step;
  mk("R3",   "R3",   rheoDefaults.R3,   dx); dx+=step;
  mk("R1",   "R1",   rheoDefaults.R1,   dx); dx+=block;

  mk("PV (cP)", "PV", rheoDefaults.PV, dx); dx+=step+10;
  mk("YP (lbf/100ft¬≤)", "YP", rheoDefaults.YP, dx, 90);

  // Model toggle + Fit + Show
  const btnY = y + 36;
  const modelBtn = createButton(`Model: ${ACTIVE_RHEO_MODEL}`).position(x, btnY).size(130, 26);
  modelBtn.mousePressed(()=>{
    ACTIVE_RHEO_MODEL = (ACTIVE_RHEO_MODEL === "HB") ? "PowerLaw" :
                        (ACTIVE_RHEO_MODEL === "PowerLaw") ? "Bingham" : "HB";
    modelBtn.html(`Model: ${ACTIVE_RHEO_MODEL}`);
  });

  const fitBtn = createButton("Fit rheology").position(x+140, btnY).size(110,26);
  fitBtn.mousePressed(doRheologyFit);

  const showBtn = createButton("Show params").position(x+260, btnY).size(110,26);
  showBtn.mousePressed(showFittedParams);

  // Status DIV
  rheoPanel.statusDiv = createDiv("").position(x, btnY + 34).style("color","#EEE").style("font-size","12px");
}

function buildEnhancedHydraulicsUI(parentDiv){
  if (!parentDiv) return;

  parentDiv
    .style('display', 'flex')
    .style('flex-direction', 'column')
    .style('gap', '8px');

  const mkToggleRow = (key, label) => {
    const row = createDiv('').parent(parentDiv)
      .style('display', 'flex')
      .style('align-items', 'center')
      .style('gap', '10px')
      .style('margin-bottom', '10px');

    const btn = createButton(`${label}: ${EH[key].on ? 'ON' : 'OFF'}`)
      .parent(row)
      .style('width', '150px')
      .style('height', '26px')
      .style('font-size', '11px')
      .mousePressed(() => {
        EH[key].on = !EH[key].on;
        btn.html(`${label}: ${EH[key].on ? 'ON' : 'OFF'}`);
      });

    const slider = createSlider(-1, 1, EH[key].s, 0.01)
      .parent(row)
      .style('width', '160px');

    slider.input(() => {
      EH[key].s = slider.value();
    });
  };

  mkToggleRow('ECC', 'Eccentric Annulus');
  mkToggleRow('ROUGH', 'Roughness');
  mkToggleRow('KLOSS', 'Local K-Losses');

  const pOnlyRow = createDiv('').parent(parentDiv)
    .style('display', 'grid')
    .style('grid-template-columns', '160px 1fr 120px')
    .style('align-items', 'center')
    .style('gap', '10px')
    .style('margin-bottom', '10px');

  const pBtn = createButton(`P-only: ${EH.PCOR.on ? 'ON' : 'OFF'}`)
    .parent(pOnlyRow)
    .style('height', '26px')
    .mousePressed(() => {
      EH.PCOR.on = !EH.PCOR.on;
      pBtn.html(`P-only: ${EH.PCOR.on ? 'ON' : 'OFF'}`);
    });

  const pSlider = createSlider(-1, 1, EH.PCOR.s, 0.01)
    .parent(pOnlyRow)
    .style('width', '160px');

  pSlider.input(() => {
    EH.PCOR.s = pSlider.value();
  });

  const fluidSelect = createSelect().parent(pOnlyRow)
    .style('height', '26px');
  ['WBM', 'OBM', 'Diesel'].forEach(f => fluidSelect.option(f));
  fluidSelect.value(EH.PCOR.fluid);
  fluidSelect.changed(() => {
    EH.PCOR.fluid = fluidSelect.value();
  });

  const gravRow = createDiv('').parent(parentDiv)
    .style('display', 'flex')
    .style('align-items', 'center')
    .style('gap', '10px');

  createButton(`Gravity Swap: ${EH.GRAV.on ? 'ON' : 'OFF'}`)
    .parent(gravRow)
    .style('width', '150px')
    .style('height', '26px')
    .mousePressed(function() {
      EH.GRAV.on = !EH.GRAV.on;
      this.html(`Gravity Swap: ${EH.GRAV.on ? 'ON' : 'OFF'}`);
    });

  createDiv('Density-driven settling (slow)').parent(gravRow)
    .style('font-size', '11px')
    .style('opacity', '0.8');
}

function buildEnhancedHydraulicsPanel() {
  const pos = enhancedHydraulicsUIPosition();
  const panelWidth = bottomPanelCardWidth(enhFrameW);
  const root = styleBottomPanelCard(createDiv('').position(pos.x, pos.y), '#1c3248', enhFrameW)
    .style('width', `${panelWidth}px`);

  createDiv('Enhanced Hydraulics Controls').parent(root)
    .style('font-weight', 'bold')
    .style('color', '#8cd7ff')
    .style('margin-bottom', '8px');

  buildEnhancedHydraulicsUI(root);
}
// ------------------------- Build Losses UI -------------------------
function buildLossesUI() {
  const pos = lossesUIPosition();

  const panelWidth = bottomPanelCardWidth(lossFrameW);

  uiLosses.root = styleBottomPanelCard(createDiv('').position(pos.x, pos.y), '#2f4a5f', lossFrameW)
    .style('width', `${panelWidth}px`);

  uiLosses.title = createDiv('Losses (Œ≤, ŒîP, Coupled)').parent(uiLosses.root)
    .style('font-weight', 'bold')
    .style('color', '#8cd7ff')
    .style('margin-bottom', '6px');

  uiLosses.toggleBtn = createButton(LOSSES_ON ? 'Losses: ON' : 'Losses: OFF')
    .parent(uiLosses.root)
    .mousePressed(() => {
      LOSSES_ON = !LOSSES_ON;
      uiLosses.toggleBtn.html(LOSSES_ON ? 'Losses: ON' : 'Losses: OFF');
    });

  const hdr = createDiv('').parent(uiLosses.root).style('margin-top', '8px');
// header row HTML
hdr.html(`<div style="display:grid;grid-template-columns:80px 100px 90px 90px 70px 90px;gap:6px;font-size:11px;opacity:.8">
  <div>Depth (m)</div>
  <div>Frac P (psi)</div>
  <div>Qref (gpm)</div>
  <div>ŒîPref (psi)</div>
  <div>n</div>
  <div>PI (gpm/psi^n)</div>
</div>`);


  for (let i=0;i<3;i++){
    const row = createDiv('').parent(uiLosses.root)
      .style('display', 'grid')
      .style('grid-template-columns', '80px 100px 90px 90px 50px')
      .style('gap', '6px')
      .style('margin-top', '4px');

    const depth = createInput('', 'number').parent(row).attribute('placeholder', 'e.g., 2950');
    const fracP = createInput('', 'number').parent(row).attribute('placeholder', 'e.g., 6500');
    const qref  = createInput('', 'number').parent(row).attribute('placeholder', 'e.g., 500');
    const dpref = createInput('', 'number').parent(row).attribute('placeholder', 'e.g., 200');
    const n     = createInput('1.0', 'number').parent(row);

    [depth, fracP, qref, dpref, n].forEach(inp => {
      inp.style('background', 'rgba(255,255,255,0.07)')
         .style('color', '#EEE')
         .style('border', '1px solid rgba(255,255,255,0.12)')
         .style('height', '22px')
         .style('padding', '0 6px')
         .style('border-radius', '6px')
         .style('font-size', '12px');
    });

    depth.input(() => { const v = Number(depth.value()); lossZones[i].enabled = !isNaN(v) && v>0; lossZones[i].depth_m = isNaN(v) ? 0 : v; });
    fracP.input(() => { lossZones[i].fracPressure_psi = Number(fracP.value()) || 0; });
    qref.input (() => { lossZones[i].Qref_gpm        = Number(qref.value())  || 0; });
    dpref.input(()=> { lossZones[i].DPref_psi        = Number(dpref.value()) || 0; });
    n.input    (() => { const nv = Number(n.value()); lossZones[i].n = (!isNaN(nv) && nv>0) ? nv : 1.0; });

    uiLosses.rows[i] = { depth, fracP, qref, dpref, n };
  }

  uiLosses.help = createDiv(
    `<div style="margin-top:8px;font-size:11px;opacity:.8">
      <b>Model:</b> Q<sub>loss</sub>=C<sub>L</sub>(ŒîP)<sup>n</sup>, C<sub>L</sub>=Q<sub>ref</sub>/ŒîP<sub>ref</sub><sup>n</sup>.<br/>
      Loss fluid is extracted from the cell at depth (composition-aware). Coupled iteration adjusts P at each zone.<br/>
      Riser must be full to see Flow Out at surface; compressibility uses wet volume compliance.
    </div>`
  ).parent(uiLosses.root);
}
// ==================== BOP WELL CONTROL UI ====================
let uiBOP = {
  root: null,
  chokeFlowSlider: null, chokeFlowInput: null,
  chokeMWSlider: null, chokeMWInput: null,
  chokePressSlider: null, chokePressInput: null,
  chokeDirUpBtn: null, chokeDirDownBtn: null, chokeOpenBtn: null,
  killFlowSlider: null, killFlowInput: null,
  killMWSlider: null, killMWInput: null,
  killPressSlider: null, killPressInput: null,
  killDirUpBtn: null, killDirDownBtn: null, killOpenBtn: null
};
let chokePressureInputMode = null;
let killPressureInputMode = null;

function bopUIPosition() {
  const x = (typeof bopFrameX === 'number') ? bopFrameX + 18 : 780;
  const yBase = (typeof frameY2 === 'number') ? frameY2 + 40 : (height - 200);
  const y = Math.min(height - 200, Math.max(20, yBase));
  return { x, y };
}

function bottomPanelCardWidth(panelW = bottomPanelW) {
  const base = (typeof panelW === 'number') ? panelW : 420;
  const candidate = Math.min(base - 24, 420);
  return Math.max(candidate, 320);
}

function styleBottomPanelCard(div, accent = null, panelW = bottomPanelW) {
  const widthPx = bottomPanelCardWidth(panelW);
  div
    .style('padding', '12px')
    .style('border', '1px solid rgba(100,200,255,0.25)')
    .style('border-radius', '10px')
    .style('background', 'rgba(10,20,35,0.72)')
    .style('backdrop-filter', 'blur(4px)')
    .style('color', '#EEE')
    .style('width', `${widthPx}px`);

  if (accent) {
    div.style('box-shadow', `0 0 0 1px ${accent} inset`);
  }

  return div;
}


function buildBOPWellControlUI() {
  const pos = bopUIPosition();
  const panelWidth = Math.max(bottomPanelCardWidth(bopPanelW), 580);

  uiBOP.root = styleBottomPanelCard(createDiv('').position(pos.x, pos.y), '#1f3b57', bopPanelW)
    .style('width', `${panelWidth}px`);

  createDiv('BOP Well Control').parent(uiBOP.root)
    .style('font-weight', 'bold')
    .style('font-size', '14px')
    .style('margin-bottom', '10px')
    .style('color', '#7fd5ff');

  const stateRow = createDiv('').parent(uiBOP.root)
    .style('display', 'flex')
    .style('align-items', 'center')
    .style('justify-content', 'space-between')
    .style('margin-bottom', '12px');

  uiBOP.bopBtn = createButton(BOP_CLOSED ? 'BOP: CLOSED' : 'BOP: OPEN')
    .parent(stateRow)
    .style('width', '140px')
    .style('height', '28px')
    .style('font-weight', 'bold')
    .style('border', 'none')
    .style('color', '#0b1725')
    .style('background', BOP_CLOSED ? '#ff6b6b' : '#4ade80')
    .mousePressed(() => {
      if (!BOP_CLOSED) {
        const refPsi = pressureAtDepth(BOP_DEPTH);
        if (isFinite(refPsi)) {
          trappedAnnulusBasePressure_psi = refPsi;
          lastOpenAnnulusPressure_psi = refPsi;
        } else {
          trappedAnnulusBasePressure_psi = lastOpenAnnulusPressure_psi;
        }
      } else {
        trappedAnnulusBasePressure_psi = null;
      }

      BOP_CLOSED = !BOP_CLOSED;
      uiBOP.bopBtn.html(BOP_CLOSED ? 'BOP: CLOSED' : 'BOP: OPEN');
      uiBOP.bopBtn.style('background', BOP_CLOSED ? '#ff6b6b' : '#4ade80');
      if (!BOP_CLOSED) {
        closedWellPressureBoost_psi = 0;
        trappedAnnulusBasePressure_psi = null;
      }
      if (uiBOP.stateLabel) {
        uiBOP.stateLabel.html(BOP_CLOSED ? 'Annulus isolated to surface' : 'Annulus communicating with riser');
      }
    });

  uiBOP.stateLabel = createDiv(BOP_CLOSED ? 'Annulus isolated to surface' : 'Annulus communicating with riser')
    .parent(stateRow)
    .style('font-size', '11px')
    .style('opacity', '0.85');

  const grid = createDiv('').parent(uiBOP.root)
    .style('display', 'grid')
    .style('grid-template-columns', 'repeat(auto-fit, minmax(260px, 1fr))')
    .style('gap', '16px');

  const makeSliderRow = (parent, label, min, max, value, step, decimals) => {
    const row = createDiv('').parent(parent)
      .style('display', 'flex')
      .style('flex-direction', 'column')
      .style('gap', '4px')
      .style('margin-bottom', '10px');

    createDiv(label).parent(row)
      .style('font-size', '11px')
      .style('opacity', '0.85');

    const sliderWrap = createDiv('').parent(row)
      .style('display', 'flex')
      .style('align-items', 'center')
      .style('gap', '10px');

    const slider = createSlider(min, max, value, step)
      .parent(sliderWrap)
      .style('flex', '0 0 160px')
      .style('width', '160px');

    const input = createInput(nf(value, 1, decimals), 'number')
      .parent(sliderWrap)
      .size(60)
      .style('height', '22px')
      .style('border-radius', '4px')
      .style('border', '1px solid rgba(100,200,255,0.25)')
      .style('background', 'rgba(255,255,255,0.07)')
      .style('color', '#EEE')
      .style('text-align', 'right')
      .style('padding', '0 6px')
      .style('font-size', '11px');

    return { slider, input, setValue: (val) => { slider.value(val); input.value(nf(val, 1, decimals)); } };
  };

  const chokeCard = createDiv('').parent(grid)
    .style('padding', '10px')
    .style('border-radius', '8px')
    .style('background', 'rgba(14,28,42,0.65)');

  createDiv('Choke Line').parent(chokeCard)
    .style('font-weight', 'bold')
    .style('color', '#88ccff')
    .style('margin-bottom', '6px');

  const chokeFlow = makeSliderRow(chokeCard, 'Flow (gpm)', 0, 1000, Q_CHOKE, 10, 0);
  uiBOP.chokeFlowSlider = chokeFlow.slider;
  uiBOP.chokeFlowInput = chokeFlow.input;
  chokeFlow.slider.input(() => {
    Q_CHOKE = uiBOP.chokeFlowSlider.value();
    uiBOP.chokeFlowInput.value(nf(Q_CHOKE, 1, 0));
  });
  chokeFlow.input.input(() => {
    Q_CHOKE = Math.max(0, Number(uiBOP.chokeFlowInput.value()) || 0);
    uiBOP.chokeFlowSlider.value(Q_CHOKE);
  });

  const chokeMW = makeSliderRow(chokeCard, 'MW (ppg)', MW_MIN, MW_MAX, MW_CHOKE, MW_STEP, 1);
  uiBOP.chokeMWSlider = chokeMW.slider;
  uiBOP.chokeMWInput = chokeMW.input;
  chokeMW.slider.input(() => {
    MW_CHOKE = uiBOP.chokeMWSlider.value();
    uiBOP.chokeMWInput.value(nf(MW_CHOKE, 1, 1));
  });
  chokeMW.input.input(() => {
    MW_CHOKE = clamp(Number(uiBOP.chokeMWInput.value()) || MW_CHOKE, MW_MIN, MW_MAX);
    uiBOP.chokeMWSlider.value(MW_CHOKE);
  });

  const chokePress = makeSliderRow(chokeCard, 'Pressure (psi)', 0, 5000, CHOKE_PRESSURE_TARGET_psi, 50, 0);
  uiBOP.chokePressSlider = chokePress.slider;
  uiBOP.chokePressInput = chokePress.input;
  chokePress.slider.input(() => {
    const val = uiBOP.chokePressSlider.value();
    setChokePressureTarget(val);
    uiBOP.chokePressInput.value(nf(CHOKE_PRESSURE_TARGET_psi, 1, 0));
  });
  chokePress.input.input(() => {
    const val = Math.max(0, Number(uiBOP.chokePressInput.value()) || 0);
    setChokePressureTarget(val);
    uiBOP.chokePressSlider.value(CHOKE_PRESSURE_TARGET_psi);
  });

  const chokeBtns = createDiv('').parent(chokeCard)
    .style('display', 'flex')
    .style('align-items', 'center')
    .style('gap', '10px')
    .style('margin-top', '10px');

  createDiv('Direction:').parent(chokeBtns)
    .style('font-size', '11px')
    .style('opacity', '0.85');

  uiBOP.chokeDirUpBtn = createButton('UP')
    .parent(chokeBtns)
    .style('width', '54px')
    .style('height', '26px')
    .style('font-size', '11px')
    .mousePressed(() => {
      CHOKE_DIRECTION = 'UP';
      updateChokeDirectionButtons();
      updateChokePressureInputState();
    });

  uiBOP.chokeDirDownBtn = createButton('DOWN')
    .parent(chokeBtns)
    .style('width', '54px')
    .style('height', '26px')
    .style('font-size', '11px')
    .mousePressed(() => {
      CHOKE_DIRECTION = 'DOWN';
      updateChokeDirectionButtons();
      updateChokePressureInputState();
    });

  uiBOP.chokeOpenBtn = createButton(CHOKE_LINE_OPEN ? 'OPEN' : 'CLOSED')
    .parent(chokeBtns)
    .style('width', '90px')
    .style('height', '26px')
    .style('font-size', '11px')
    .style('font-weight', 'bold')
    .style('background', CHOKE_LINE_OPEN ? '#4ade80' : '#ff6b6b')
    .mousePressed(() => {
      CHOKE_LINE_OPEN = !CHOKE_LINE_OPEN;
      uiBOP.chokeOpenBtn.html(CHOKE_LINE_OPEN ? 'OPEN' : 'CLOSED');
      uiBOP.chokeOpenBtn.style('background', CHOKE_LINE_OPEN ? '#4ade80' : '#ff6b6b');
    });

  const killCard = createDiv('').parent(grid)
    .style('padding', '10px')
    .style('border-radius', '8px')
    .style('background', 'rgba(32,24,18,0.65)');

  createDiv('Kill Line').parent(killCard)
    .style('font-weight', 'bold')
    .style('color', '#ffb677')
    .style('margin-bottom', '6px');

  const killFlow = makeSliderRow(killCard, 'Flow (gpm)', 0, 1000, Q_KILL, 10, 0);
  uiBOP.killFlowSlider = killFlow.slider;
  uiBOP.killFlowInput = killFlow.input;
  killFlow.slider.input(() => {
    Q_KILL = uiBOP.killFlowSlider.value();
    uiBOP.killFlowInput.value(nf(Q_KILL, 1, 0));
  });
  killFlow.input.input(() => {
    Q_KILL = Math.max(0, Number(uiBOP.killFlowInput.value()) || 0);
    uiBOP.killFlowSlider.value(Q_KILL);
  });

  const killMW = makeSliderRow(killCard, 'MW (ppg)', MW_MIN, MW_MAX, MW_KILL, MW_STEP, 1);
  uiBOP.killMWSlider = killMW.slider;
  uiBOP.killMWInput = killMW.input;
  killMW.slider.input(() => {
    MW_KILL = uiBOP.killMWSlider.value();
    uiBOP.killMWInput.value(nf(MW_KILL, 1, 1));
  });
  killMW.input.input(() => {
    MW_KILL = clamp(Number(uiBOP.killMWInput.value()) || MW_KILL, MW_MIN, MW_MAX);
    uiBOP.killMWSlider.value(MW_KILL);
  });

  const killPress = makeSliderRow(killCard, 'Pressure (psi)', 0, 5000, KILL_PRESSURE_TARGET_psi, 50, 0);
  uiBOP.killPressSlider = killPress.slider;
  uiBOP.killPressInput = killPress.input;
  killPress.slider.input(() => {
    const val = uiBOP.killPressSlider.value();
    setKillPressureTarget(val);
    uiBOP.killPressInput.value(nf(KILL_PRESSURE_TARGET_psi, 1, 0));
  });
  killPress.input.input(() => {
    const val = Math.max(0, Number(uiBOP.killPressInput.value()) || 0);
    setKillPressureTarget(val);
    uiBOP.killPressSlider.value(KILL_PRESSURE_TARGET_psi);
  });

  const killBtns = createDiv('').parent(killCard)
    .style('display', 'flex')
    .style('align-items', 'center')
    .style('gap', '10px')
    .style('margin-top', '10px');

  createDiv('Direction:').parent(killBtns)
    .style('font-size', '11px')
    .style('opacity', '0.85');

  uiBOP.killDirUpBtn = createButton('UP')
    .parent(killBtns)
    .style('width', '54px')
    .style('height', '26px')
    .style('font-size', '11px')
    .mousePressed(() => {
      KILL_DIRECTION = 'UP';
      updateKillDirectionButtons();
      updateKillPressureInputState();
    });

  uiBOP.killDirDownBtn = createButton('DOWN')
    .parent(killBtns)
    .style('width', '54px')
    .style('height', '26px')
    .style('font-size', '11px')
    .mousePressed(() => {
      KILL_DIRECTION = 'DOWN';
      updateKillDirectionButtons();
      updateKillPressureInputState();
    });

  uiBOP.killOpenBtn = createButton(KILL_LINE_OPEN ? 'OPEN' : 'CLOSED')
    .parent(killBtns)
    .style('width', '90px')
    .style('height', '26px')
    .style('font-size', '11px')
    .style('font-weight', 'bold')
    .style('background', KILL_LINE_OPEN ? '#4ade80' : '#ff6b6b')
    .mousePressed(() => {
      KILL_LINE_OPEN = !KILL_LINE_OPEN;
      uiBOP.killOpenBtn.html(KILL_LINE_OPEN ? 'OPEN' : 'CLOSED');
      uiBOP.killOpenBtn.style('background', KILL_LINE_OPEN ? '#4ade80' : '#ff6b6b');
    });

  createDiv('UP: Calculated return flow. DOWN: User-defined pumping. Sliders match top-panel sizing for consistency.')
    .parent(uiBOP.root)
    .style('font-size', '10px')
    .style('opacity', '0.7')
    .style('margin-top', '10px');

  updateChokeDirectionButtons();
  updateKillDirectionButtons();
  updateChokePressureInputState(true);
  updateKillPressureInputState(true);
  updateBOPMWDisplays();
}

// Update choke pressure input state based on direction
function updateChokePressureInputState(force=false) {
  if (!uiBOP.chokePressInput || !uiBOP.chokePressSlider) return;

  const mode = chokePressureControlMode();
  if (mode === 'down') {
    uiBOP.chokePressInput.attribute('readonly', true);
    uiBOP.chokePressInput.style('background', 'rgba(100,150,200,0.15)');
    uiBOP.chokePressInput.style('cursor', 'not-allowed');
    uiBOP.chokePressInput.style('opacity', '0.7');
    uiBOP.chokePressSlider.attribute('disabled', true);
    uiBOP.chokePressSlider.style('opacity', '0.5');
  } else if (mode === 'up-passive') {
    uiBOP.chokePressInput.attribute('readonly', true);
    uiBOP.chokePressInput.style('background', 'rgba(255,180,120,0.15)');
    uiBOP.chokePressInput.style('cursor', 'not-allowed');
    uiBOP.chokePressInput.style('opacity', '0.8');
    uiBOP.chokePressSlider.attribute('disabled', true);
    uiBOP.chokePressSlider.style('opacity', '0.5');
  } else {
    uiBOP.chokePressInput.removeAttribute('readonly');
    uiBOP.chokePressInput.style('background', 'rgba(255,255,255,0.07)');
    uiBOP.chokePressInput.style('cursor', 'text');
    uiBOP.chokePressInput.style('opacity', '1');
    uiBOP.chokePressSlider.removeAttribute('disabled');
    uiBOP.chokePressSlider.style('opacity', '1');
  }

  const modeChanged = (mode !== chokePressureInputMode);
  if (mode === 'down' && (modeChanged || force)) {
    uiBOP.chokePressInput.value(nf(CHOKE_PRESSURE_psi, 0, 1));
    uiBOP.chokePressSlider.value(CHOKE_PRESSURE_psi);
  } else if (mode === 'up-passive') {
    const display = isFinite(chokeSurfacePressure_calc_psi)
      ? chokeSurfacePressure_calc_psi
      : CHOKE_PRESSURE_psi;
    uiBOP.chokePressInput.value(nf(display, 0, 1));
    uiBOP.chokePressSlider.value(display);
  } else if (mode === 'up-control' && (modeChanged || force)) {
    uiBOP.chokePressInput.value(nf(CHOKE_PRESSURE_TARGET_psi, 0, 1));
    uiBOP.chokePressSlider.value(CHOKE_PRESSURE_TARGET_psi);
  }

  chokePressureInputMode = mode;
}

function updateKillPressureInputState(force=false) {
  if (!uiBOP.killPressInput || !uiBOP.killPressSlider) return;

  const mode = killPressureControlMode();
  if (mode === 'down') {
    uiBOP.killPressInput.attribute('readonly', true);
    uiBOP.killPressInput.style('background', 'rgba(100,150,200,0.15)');
    uiBOP.killPressInput.style('cursor', 'not-allowed');
    uiBOP.killPressInput.style('opacity', '0.7');
    uiBOP.killPressSlider.attribute('disabled', true);
    uiBOP.killPressSlider.style('opacity', '0.5');
  } else if (mode === 'up-passive') {
    uiBOP.killPressInput.attribute('readonly', true);
    uiBOP.killPressInput.style('background', 'rgba(255,180,120,0.15)');
    uiBOP.killPressInput.style('cursor', 'not-allowed');
    uiBOP.killPressInput.style('opacity', '0.8');
    uiBOP.killPressSlider.attribute('disabled', true);
    uiBOP.killPressSlider.style('opacity', '0.5');
  } else {
    uiBOP.killPressInput.removeAttribute('readonly');
    uiBOP.killPressInput.style('background', 'rgba(255,255,255,0.07)');
    uiBOP.killPressInput.style('cursor', 'text');
    uiBOP.killPressInput.style('opacity', '1');
    uiBOP.killPressSlider.removeAttribute('disabled');
    uiBOP.killPressSlider.style('opacity', '1');
  }

  const modeChanged = (mode !== killPressureInputMode);
  if (mode === 'down' && (modeChanged || force)) {
    uiBOP.killPressInput.value(nf(KILL_PRESSURE_psi, 0, 1));
    uiBOP.killPressSlider.value(KILL_PRESSURE_psi);
  } else if (mode === 'up-passive') {
    const display = isFinite(killSurfacePressure_calc_psi)
      ? killSurfacePressure_calc_psi
      : KILL_PRESSURE_psi;
    uiBOP.killPressInput.value(nf(display, 0, 1));
    uiBOP.killPressSlider.value(display);
  } else if (mode === 'up-control' && (modeChanged || force)) {
    uiBOP.killPressInput.value(nf(KILL_PRESSURE_TARGET_psi, 0, 1));
    uiBOP.killPressSlider.value(KILL_PRESSURE_TARGET_psi);
  }

  killPressureInputMode = mode;
}

// Update choke direction button highlighting
function updateChokeDirectionButtons() {
  if (!uiBOP.chokeDirUpBtn || !uiBOP.chokeDirDownBtn) return;

  if (CHOKE_DIRECTION === 'UP') {
    uiBOP.chokeDirUpBtn.style('background', '#4ade80');
    uiBOP.chokeDirUpBtn.style('font-weight', 'bold');
    uiBOP.chokeDirDownBtn.style('background', 'rgba(255,255,255,0.1)');
    uiBOP.chokeDirDownBtn.style('font-weight', 'normal');
  } else {
    uiBOP.chokeDirUpBtn.style('background', 'rgba(255,255,255,0.1)');
    uiBOP.chokeDirUpBtn.style('font-weight', 'normal');
    uiBOP.chokeDirDownBtn.style('background', '#4ade80');
    uiBOP.chokeDirDownBtn.style('font-weight', 'bold');
  }
}

// Update kill direction button highlighting
function updateKillDirectionButtons() {
  if (!uiBOP.killDirUpBtn || !uiBOP.killDirDownBtn) return;

  if (KILL_DIRECTION === 'UP') {
    uiBOP.killDirUpBtn.style('background', '#4ade80');
    uiBOP.killDirUpBtn.style('font-weight', 'bold');
    uiBOP.killDirDownBtn.style('background', 'rgba(255,255,255,0.1)');
    uiBOP.killDirDownBtn.style('font-weight', 'normal');
  } else {
    uiBOP.killDirUpBtn.style('background', 'rgba(255,255,255,0.1)');
    uiBOP.killDirUpBtn.style('font-weight', 'normal');
    uiBOP.killDirDownBtn.style('background', '#4ade80');
    uiBOP.killDirDownBtn.style('font-weight', 'bold');
  }
}

// Update BOP UI pressure displays with calculated SPP (called in draw loop)
function updateBOPPressureDisplays() {
  if (!uiBOP.chokePressInput || !uiBOP.killPressInput) return;

  // CHOKE LINE
  // ‚úÖ FIXED: Calculate SPP when flowing DOWN, regardless of BOP state
  if (CHOKE_DIRECTION === 'DOWN' && Q_CHOKE > 0 && CHOKE_LINE_OPEN) {
    // Calculate SPP for choke line (works for BOP open or closed)
    const chokeRawSPP = chokeLinePumpPressure();
    const chokeSPP = updateChokeSPP(chokeRawSPP);
    CHOKE_PRESSURE_psi = chokeSPP;
    uiBOP.chokePressInput.value(nf(chokeSPP, 0, 1));
    if (uiBOP.chokePressSlider) uiBOP.chokePressSlider.value(chokeSPP);
  } else if (CHOKE_DIRECTION === 'UP') {
    if (!chokeLineHasUserPressureControl()) {
      const display = isFinite(chokeSurfacePressure_calc_psi)
        ? chokeSurfacePressure_calc_psi
        : CHOKE_PRESSURE_psi;
      uiBOP.chokePressInput.value(nf(display, 0, 1));
      if (uiBOP.chokePressSlider) uiBOP.chokePressSlider.value(display);
    }
  }

  // KILL LINE
  // ‚úÖ FIXED: Calculate SPP when flowing DOWN, regardless of BOP state
  if (KILL_DIRECTION === 'DOWN' && Q_KILL > 0 && KILL_LINE_OPEN) {
    // Calculate SPP for kill line (works for BOP open or closed)
    const killRawSPP = killLinePumpPressure();
    const killSPP = updateKillSPP(killRawSPP);
    KILL_PRESSURE_psi = killSPP;
    uiBOP.killPressInput.value(nf(killSPP, 0, 1));
    if (uiBOP.killPressSlider) uiBOP.killPressSlider.value(killSPP);
  } else if (KILL_DIRECTION === 'UP') {
    if (!killLineHasUserPressureControl()) {
      const display = isFinite(killSurfacePressure_calc_psi)
        ? killSurfacePressure_calc_psi
        : KILL_PRESSURE_psi;
      uiBOP.killPressInput.value(nf(display, 0, 1));
      if (uiBOP.killPressSlider) uiBOP.killPressSlider.value(display);
    }
  }

  updateChokePressureInputState();
  updateKillPressureInputState();
}

// Update flow rate displays for choke/kill lines
// For UP direction: shows calculated flow (read-only)
// For DOWN direction: shows user-set flow (editable)
function updateBOPFlowDisplays() {
  if (!uiBOP.chokeFlowInput || !uiBOP.killFlowInput) return;

  // CHOKE LINE FLOW
  if (CHOKE_DIRECTION === 'UP') {
    // UP: Show calculated flow (pressure-driven)
    const calcFlow_gpm = measuredBopLineUpflow_gpm('choke');
    uiBOP.chokeFlowInput.value(nf(calcFlow_gpm, 0, 1));
    if (uiBOP.chokeFlowSlider) uiBOP.chokeFlowSlider.value(calcFlow_gpm);

    // Disable controls (flow is calculated, not user-set)
    uiBOP.chokeFlowInput.attribute('readonly', true);
    uiBOP.chokeFlowInput.style('background', 'rgba(100,150,200,0.15)');
    uiBOP.chokeFlowInput.style('cursor', 'not-allowed');
    if (uiBOP.chokeFlowSlider) {
      uiBOP.chokeFlowSlider.attribute('disabled', true);
      uiBOP.chokeFlowSlider.style('opacity', '0.5');
    }
  } else {
    // DOWN: User controls flow (editable)
    // Values are set by user input handlers
    uiBOP.chokeFlowInput.removeAttribute('readonly');
    uiBOP.chokeFlowInput.style('background', 'rgba(255,255,255,0.07)');
    uiBOP.chokeFlowInput.style('cursor', 'text');
    if (uiBOP.chokeFlowSlider) {
      uiBOP.chokeFlowSlider.removeAttribute('disabled');
      uiBOP.chokeFlowSlider.style('opacity', '1');
    }
  }

  // KILL LINE FLOW
  if (KILL_DIRECTION === 'UP') {
    // UP: Show calculated flow (pressure-driven)
    const calcFlow_gpm = measuredBopLineUpflow_gpm('kill');
    uiBOP.killFlowInput.value(nf(calcFlow_gpm, 0, 1));
    if (uiBOP.killFlowSlider) uiBOP.killFlowSlider.value(calcFlow_gpm);

    // Disable controls (flow is calculated, not user-set)
    uiBOP.killFlowInput.attribute('readonly', true);
    uiBOP.killFlowInput.style('background', 'rgba(100,150,200,0.15)');
    uiBOP.killFlowInput.style('cursor', 'not-allowed');
    if (uiBOP.killFlowSlider) {
      uiBOP.killFlowSlider.attribute('disabled', true);
      uiBOP.killFlowSlider.style('opacity', '0.5');
    }
  } else {
    // DOWN: User controls flow (editable)
    uiBOP.killFlowInput.removeAttribute('readonly');
    uiBOP.killFlowInput.style('background', 'rgba(255,255,255,0.07)');
    uiBOP.killFlowInput.style('cursor', 'text');
    if (uiBOP.killFlowSlider) {
      uiBOP.killFlowSlider.removeAttribute('disabled');
      uiBOP.killFlowSlider.style('opacity', '1');
    }
  }
}

// Update mud-weight inputs: editable only when pumping down
function updateBOPMWDisplays() {
  if (!uiBOP.chokeMWInput || !uiBOP.killMWInput) return;

  const updateLine = (direction, grid, mwValue, inputEl, sliderEl) => {
    if (!inputEl) return;
    const avgMW = (grid && grid.length > 0) ? average(grid) : mwValue;

    if (direction === 'DOWN') {
      const wasReadOnly = inputEl.elt ? inputEl.elt.hasAttribute('readonly') : false;
      const sliderWasDisabled = sliderEl && sliderEl.elt ? sliderEl.elt.hasAttribute('disabled') : false;
      inputEl.removeAttribute('readonly');
      inputEl.style('background', 'rgba(255,255,255,0.07)');
      inputEl.style('cursor', 'text');
      inputEl.style('opacity', '1');
      if (sliderEl) {
        sliderEl.removeAttribute('disabled');
        sliderEl.style('opacity', '1');
      }
      if (wasReadOnly) {
        inputEl.value(nf(mwValue, 1, 1));
      }
      if (sliderEl && sliderWasDisabled) {
        sliderEl.value(mwValue);
      }
    } else {
      inputEl.attribute('readonly', true);
      inputEl.style('background', 'rgba(100,150,200,0.15)');
      inputEl.style('cursor', 'not-allowed');
      inputEl.style('opacity', '0.7');
      inputEl.value(nf(avgMW, 1, 2));
      if (sliderEl) {
        sliderEl.attribute('disabled', true);
        sliderEl.style('opacity', '0.5');
        sliderEl.value(avgMW);
      }
    }
  };

  updateLine(CHOKE_DIRECTION, chokeGrid, MW_CHOKE, uiBOP.chokeMWInput, uiBOP.chokeMWSlider);
  updateLine(KILL_DIRECTION, killGrid, MW_KILL, uiBOP.killMWInput, uiBOP.killMWSlider);
}

function refreshLossesUIFromModel(){
  if (!uiLosses.root) return;
  for (let i=0;i<3;i++){
    const z = lossZones[i], r = uiLosses.rows[i]; if (!r) continue;
    if (z.depth_m>0 && r.depth.value()!==String(z.depth_m)) r.depth.value(String(z.depth_m));
    if (z.fracPressure_psi>0 && r.fracP.value()!==String(z.fracPressure_psi)) r.fracP.value(String(z.fracPressure_psi));
    if (z.Qref_gpm>0 && r.qref.value()!==String(z.Qref_gpm)) r.qref.value(String(z.Qref_gpm));
    if (z.DPref_psi>0 && r.dpref.value()!==String(z.DPref_psi)) r.dpref.value(String(z.DPref_psi));
    if (z.n>0 && r.n.value()!==String(z.n)) r.n.value(String(z.n));
  }
  uiLosses.toggleBtn.html(LOSSES_ON ? 'Losses: ON' : 'Losses: OFF');
}

// ------------------------- Build Diagnostics UI -------------------------
function buildDiagnosticsUI() {
  const pos = diagnosticsUIPosition();
  const panelWidth = bottomPanelCardWidth(diagFrameW);

  uiDiag.root = styleBottomPanelCard(createDiv('').position(pos.x, pos.y), '#2a3140', diagFrameW)
    .style('width', `${panelWidth}px`);

  createDiv('Diagnostics').parent(uiDiag.root)
    .style('font-weight','bold')
    .style('margin-bottom','6px');

  uiDiag.text = createDiv('').parent(uiDiag.root)
    .style('font-family','monospace')
    .style('font-size','12px')
    .style('line-height','1.25');
}


function updateDiagnosticsUI(dt_s){
  if (!uiDiag.text) return;

  const M3_PER_GPM = 1 / 15850.323;

  // Prefer values produced by the solvers; fallback to local recompute
  const loss_gpm = (typeof window !== 'undefined' && typeof window.sumLoss_gpm === 'number')
    ? window.sumLoss_gpm
    : (typeof totalLossRate_gpm === 'function' ? (totalLossRate_gpm() || 0) : 0);
  const lossDemand_gpm = (typeof window !== 'undefined' && typeof window.__qLossDemand_m3s === 'number')
    ? window.__qLossDemand_m3s * 15850.323
    : loss_gpm;
  const lossDeficit_gpm = (typeof window !== 'undefined' && typeof window.__qLossDeficit_m3s === 'number')
    ? window.__qLossDeficit_m3s * 15850.323
    : 0;

  const qCML_gpm  = (typeof effective_Q_CML_gpm === 'function' ? (effective_Q_CML_gpm() || 0) : 0);
  const qComp_gpm = (typeof compressionEquivalentFlow_gpm === 'function'
                      ? (compressionEquivalentFlow_gpm(Math.max(dt_s, 1/120)) || 0)
                      : 0);

  // Surface returns only when the column that vents to surface is "full"
  const topDepth = (typeof surfaceColumnTopDepth === 'function')
    ? surfaceColumnTopDepth()
    : ((typeof annulusTopDepthGlobal === 'function')
        ? annulusTopDepthGlobal()
        : (typeof riserTopDepth === 'function' ? riserTopDepth() : 0));
  const qOutSurf_gpm = (topDepth <= 0.5) ? (FLOW_OUT_gpm || 0) : 0;

  // Include TopFill in the inflow tally (if on)
  const qTopFill_gpm = (TOPFILL_ON ? (Q_TOPFILL || 0) : 0);
  const qIn_gpm = (Q_DS || 0) + (Q_BO || 0) + qTopFill_gpm;

  const qDS_gpm = Q_DS || 0;
  const qBO_gpm = Q_BO || 0;
  const qDS_m3s = qDS_gpm * M3_PER_GPM;
  const qAnnulusReturn_m3s = Math.max(0,
    (typeof window !== 'undefined' && typeof window.__dsFlux_m3s === 'number')
      ? window.__dsFlux_m3s
      : qDS_m3s);
  const qRiserFeed_m3s = (() => {
    if (typeof window === 'undefined') return 0;
    if (typeof window.__qBOP_annulusToRiser_m3s === 'number' && window.__qBOP_annulusToRiser_m3s > 0) {
      return window.__qBOP_annulusToRiser_m3s;
    }
    if (typeof window.__qRiserUp_m3s === 'number' && window.__qRiserUp_m3s > 0) {
      return window.__qRiserUp_m3s;
    }
    if (typeof window.__qAnnUp_m3s === 'number' && window.__qAnnUp_m3s > 0) {
      return window.__qAnnUp_m3s;
    }
    return 0;
  })();
  const dsTransit_min = estimateTransitMinutes(Math.max(TD_DEPTH, 1), qDS_m3s, A_DS());
  const annTransit_min = estimateTransitMinutes(Math.max(TD_DEPTH - BOP_DEPTH, 1), qAnnulusReturn_m3s, averageAnnulusAreaBelowBOP());
  const riserTransit_min = estimateTransitMinutes(Math.max(BOP_DEPTH, 1), qRiserFeed_m3s, A_riserAnn());
  const riserMW_ppg = averageEffectiveDensity(annAboveGrid, true);
  const chokeMW_ppg = (chokeGrid.length > 0 ? average(chokeGrid) : MW_CHOKE);
  const killMW_ppg = (killGrid.length > 0 ? average(killGrid) : MW_KILL);
  const chokeFlow_gpm = (CHOKE_DIRECTION === 'UP')
    ? measuredBopLineUpflow_gpm('choke')
    : (CHOKE_LINE_OPEN ? (Q_CHOKE || 0) : 0);
  const killFlow_gpm = (KILL_DIRECTION === 'UP')
    ? measuredBopLineUpflow_gpm('kill')
    : (KILL_LINE_OPEN ? (Q_KILL || 0) : 0);
  const bopState = BOP_CLOSED ? 'CLOSED' : 'OPEN';
  const chokeState = `${CHOKE_LINE_OPEN ? 'OPEN' : 'CLOSED'} / ${CHOKE_DIRECTION}`;
  const killState = `${KILL_LINE_OPEN ? 'OPEN' : 'CLOSED'} / ${KILL_DIRECTION}`;
  const downMix = (typeof window !== 'undefined' && window.__qAnnDown_breakdown)
    ? window.__qAnnDown_breakdown
    : { booster: 0, choke: 0, kill: 0, topfill: 0 };
  const downBo_gpm = (downMix.booster || 0) * 15850.323;
  const downCh_gpm = (downMix.choke || 0) * 15850.323;
  const downKi_gpm = (downMix.kill || 0) * 15850.323;
  const downTf_gpm = (downMix.topfill || 0) * 15850.323;
  const lossAlloc = (typeof window !== 'undefined' && window.__lossAllocation)
    ? window.__lossAllocation
    : null;
  const kickFeed_gpm = lossAlloc ? ((lossAlloc.fromKick || 0) * 15850.323) : 0;
  const storageDraw_gpm = lossAlloc ? ((lossAlloc.fromStorage || 0) * 15850.323) : 0;
  const sealedByValves = isWellShutInByValves();
  const mpdSeal = mpdSealActive();
  const closedBoost = closedWellPressureBoost_psi || 0;
  const autoKickPsi = (typeof window !== 'undefined' && typeof window.__autoKickBalancePsi === 'number')
    ? window.__autoKickBalancePsi
    : autoKickBalancePsi;
  const influxRateDiag = (typeof window !== 'undefined' && typeof window.__influxRate_gpm === 'number')
    ? window.__influxRate_gpm
    : formationFluidRate_gpm;
  const influxInventoryDiag = (typeof window !== 'undefined' && typeof window.__influxInventory_bbl === 'number')
    ? window.__influxInventory_bbl
    : 0;
  const kickFrontDepth_m = (typeof formationFluidFront_m === 'number' && isFinite(formationFluidFront_m))
    ? formationFluidFront_m
    : null;
  const overflow_bbl = formationFluidOverflow_m3 * 6.28981;

  // Prefer residual published by the level solver; else compute locally
  const resid_gpm = (typeof window !== 'undefined' && typeof window.qResid_gpm === 'number')
    ? window.qResid_gpm
    : (qIn_gpm - (qOutSurf_gpm + qCML_gpm + loss_gpm) - qComp_gpm);

  const lossInferred_gpm = Math.max(0, qIn_gpm - (qOutSurf_gpm + qCML_gpm + qComp_gpm) - resid_gpm);
  const usingInferredLoss = (loss_gpm < 0.5 && lossInferred_gpm > loss_gpm + 0.5);
  const lossDisplay_gpm = usingInferredLoss ? lossInferred_gpm : loss_gpm;

  if (typeof window !== 'undefined') {
    window.__lossInferred_gpm = lossInferred_gpm;
    window.__lossDisplay_gpm = lossDisplay_gpm;
  }

  const fmt = v => (+v).toFixed(1);
  const fmt2 = v => (+v).toFixed(2);
  const fmtTransit = v => (isFinite(v) ? (+v).toFixed(1) : '‚àû');

  const diagLines = [
    `BOP: ${bopState}`,
    `Riser Level (m): ${fmt(topDepth)} | MW: ${fmt2(riserMW_ppg)} ppg`,
    `Choke Line (${chokeState}) ‚Üí Flow: ${fmt(chokeFlow_gpm)} gpm | MW: ${fmt2(chokeMW_ppg)} ppg`,
    `Kill Line (${killState}) ‚Üí Flow: ${fmt(killFlow_gpm)} gpm | MW: ${fmt2(killMW_ppg)} ppg`,
    `Choke/Kill seal ready: ${linePressureAnchorArmed('choke') ? 'YES' : 'NO'} / ${linePressureAnchorArmed('kill') ? 'YES' : 'NO'}`,
    `DS/Booster/TopFill In (gpm): ${fmt(qDS_gpm)} / ${fmt(qBO_gpm)} / ${fmt(qTopFill_gpm)}`,
    `FO (gpm): ${fmt(FLOW_OUT_gpm)} | Œ£Loss (gpm): ${fmt(lossDisplay_gpm)}${usingInferredLoss ? ` (mass ${fmt(lossInferred_gpm)})` : ''}`,
    `Loss demand / actual / deficit (gpm): ${fmt(lossDemand_gpm)} / ${fmt(loss_gpm)} / ${fmt(lossDeficit_gpm)}`,
    `Down supply (gpm): Bo ${fmt(downBo_gpm)} | Ch ${fmt(downCh_gpm)} | Ki ${fmt(downKi_gpm)} | TF ${fmt(downTf_gpm)}`,
    `Kick feed / storage draw (gpm): ${fmt(kickFeed_gpm)} | ${fmt(storageDraw_gpm)}`,
    `Q_CML_eff (gpm): ${fmt(qCML_gpm)} | Q_comp (gpm): ${fmt(qComp_gpm)}`,
    `MassBal Resid (gpm): ${fmt(resid_gpm)}`,
    `Shut-In (valves): ${sealedByValves ? 'YES' : 'NO'} | MPD Seal: ${mpdSeal ? 'YES' : 'NO'} | Closed boost (psi): ${fmt(closedBoost)}`,
    `Auto SBP for kick balance (psi): ${fmt(autoKickPsi)}`,
    `Influx (gpm): ${fmt(influxRateDiag)} | Kick Volume (bbl): ${fmt(influxInventoryDiag)}`,
    `Transit (min) DS/Ann/Riser: ${fmtTransit(dsTransit_min)} / ${fmtTransit(annTransit_min)} / ${fmtTransit(riserTransit_min)}`,
    `Kick front depth (m): ${kickFrontDepth_m != null ? fmt(kickFrontDepth_m) : '--'} | Total kick in (bbl): ${fmt(formationFluidVolume_bbl)}`
  ];

  if (overflow_bbl > 0.01) {
    diagLines.push(`Kick overflow buffer (bbl): ${fmt(overflow_bbl)}`);
  }

  uiDiag.text.html(diagLines.join('<br/>'));
}

// ------------------------- Build Kicks UI -------------------------
function buildKicksUI() {
  const pos = kicksUIPosition();

  const panelWidth = bottomPanelCardWidth(kickFrameW);

  uiKicks.root = styleBottomPanelCard(createDiv('').position(pos.x, pos.y), '#5b2f2f', kickFrameW)
    .style('width', `${panelWidth}px`)
    .style('max-height', '85vh')
    .style('overflow-y', 'auto');

  uiKicks.title = createDiv('Kicks (Formation Fluids)').parent(uiKicks.root)
    .style('font-weight', 'bold')
    .style('color', '#ff9280')
    .style('margin-bottom', '6px');

  // Toggle button
  uiKicks.toggleBtn = createButton(formationFluidEnabled ? 'Kicks: ON' : 'Kicks: OFF')
    .parent(uiKicks.root)
    .style('background', formationFluidEnabled ? '#ff6b6b' : '#444')
    .style('font-weight', 'bold')
    .mousePressed(() => {
      formationFluidEnabled = !formationFluidEnabled;
      uiKicks.toggleBtn.html(formationFluidEnabled ? 'Kicks: ON' : 'Kicks: OFF');
      uiKicks.toggleBtn.style('background', formationFluidEnabled ? '#ff6b6b' : '#444');
    });

  // Mode button
  uiKicks.modeBtn = createButton(kickMode === 'MANUAL' ? 'Mode: Manual' : 'Mode: Pressure-Driven')
    .parent(uiKicks.root)
    .style('margin-left', '8px')
    .style('font-size', '11px')  // Smaller font
    .mousePressed(() => {
      kickMode = (kickMode === 'MANUAL') ? 'PRESSURE_DRIVEN' : 'MANUAL';
      uiKicks.modeBtn.html(kickMode === 'MANUAL' ? 'Mode: Manual' : 'Mode: Pressure-Driven');
      refreshKicksUI();
    });

  // Common parameters (always visible)
  createDiv('').parent(uiKicks.root).style('margin-top', '8px')
    .html('<div style="font-size:11px;opacity:0.8">Depth & Fluid Type:</div>');

  const commonRow = createDiv('').parent(uiKicks.root)
    .style('display', 'grid')
    .style('grid-template-columns', '1fr 1fr')
    .style('gap', '6px')
    .style('margin-top', '4px');

  const depthLabel = createDiv('').parent(commonRow).html('<label style="font-size:11px">Depth (m):</label>');
  uiKicks.depthInput = createInput(String(formationFluidDepth_m), 'number').parent(depthLabel);
  styleKicksInput(uiKicks.depthInput);
  uiKicks.depthInput.input(() => {
    formationFluidDepth_m = Math.max(BOP_DEPTH, Math.min(TD_DEPTH, Number(uiKicks.depthInput.value()) || 4500));
  });

  const fluidLabel = createDiv('').parent(commonRow).html('<label style="font-size:11px">Fluid Type:</label>');
  uiKicks.fluidTypeSelect = createSelect().parent(fluidLabel);
  uiKicks.fluidTypeSelect.option('WATER');
  uiKicks.fluidTypeSelect.option('OIL');
  uiKicks.fluidTypeSelect.option('GAS');
  uiKicks.fluidTypeSelect.option('BLACKOIL');
  uiKicks.fluidTypeSelect.selected(formationFluidType);
  styleKicksInput(uiKicks.fluidTypeSelect);
  uiKicks.fluidTypeSelect.changed(() => {
    formationFluidType = uiKicks.fluidTypeSelect.value();
  });

  // Manual mode parameters
  uiKicks.manualDiv = createDiv('').parent(uiKicks.root).style('margin-top', '8px');
  createDiv('Manual Rate:').parent(uiKicks.manualDiv).style('font-size:11px').style('opacity','0.8');

  const manualRow = createDiv('').parent(uiKicks.manualDiv)
    .style('display', 'flex')
    .style('flex-direction', 'column')
    .style('gap', '4px')
    .style('margin-top', '6px');

  createDiv('Influx Rate (gpm):').parent(manualRow)
    .style('font-size', '11px')
    .style('opacity', '0.85');

  const manualWrap = createDiv('').parent(manualRow)
    .style('display', 'flex')
    .style('align-items', 'center')
    .style('gap', '10px');

  uiKicks.manualRateSlider = createSlider(0, 500, formationFluidRate_gpm, 1)
    .parent(manualWrap)
    .style('width', '160px');

  uiKicks.manualRateInput = createInput(String(formationFluidRate_gpm), 'number')
    .parent(manualWrap)
    .size(60)
    .style('height', '22px')
    .style('border-radius', '4px')
    .style('border', '1px solid rgba(255,100,100,0.2)')
    .style('background', 'rgba(255,255,255,0.07)')
    .style('color', '#EEE')
    .style('text-align', 'right')
    .style('padding', '0 6px')
    .style('font-size', '11px');

  uiKicks.manualRateSlider.input(() => {
    formationFluidRate_gpm = uiKicks.manualRateSlider.value();
    uiKicks.manualRateInput.value(nf(formationFluidRate_gpm, 1, 0));
  });

  uiKicks.manualRateInput.input(() => {
    formationFluidRate_gpm = Math.max(0, Number(uiKicks.manualRateInput.value()) || 0);
    uiKicks.manualRateSlider.value(formationFluidRate_gpm);
  });

  // Pressure-driven mode parameters
  uiKicks.pressureDiv = createDiv('').parent(uiKicks.root).style('margin-top', '8px');
  createDiv('Pressure-Driven Parameters:').parent(uiKicks.pressureDiv).style('font-size:11px').style('opacity','0.8');

  const pressureGrid = createDiv('').parent(uiKicks.pressureDiv)
    .style('display', 'grid')
    .style('grid-template-columns', '1fr')
    .style('gap', '6px')
    .style('margin-top', '4px');

  const ppLabel = createDiv('').parent(pressureGrid).html('<label style="font-size:11px">Pore Pressure (psi):</label>');
  uiKicks.porePressureInput = createInput(String(porePressure_psi), 'number').parent(ppLabel);
  styleKicksInput(uiKicks.porePressureInput);
  uiKicks.porePressureInput.input(() => {
    porePressure_psi = Math.max(0, Number(uiKicks.porePressureInput.value()) || 7000);
  });

  const piLabel = createDiv('').parent(pressureGrid).html('<label style="font-size:11px">Productivity Index (gpm/psi):</label>');
  uiKicks.piInput = createInput(String(productivityIndex_gpm_psi), 'number').parent(piLabel);
  styleKicksInput(uiKicks.piInput);
  uiKicks.piInput.input(() => {
    productivityIndex_gpm_psi = Math.max(0, Number(uiKicks.piInput.value()) || 0.5);
  });

  // Migration model
  createDiv('').parent(uiKicks.root).style('margin-top', '8px')
    .html('<div style="font-size:11px;opacity:0.8">Migration Model:</div>');

  const migrationLabel = createDiv('').parent(uiKicks.root).style('margin-top', '4px')
    .html('<label style="font-size:11px">Model:</label>');
  uiKicks.migrationModelSelect = createSelect().parent(migrationLabel);
  uiKicks.migrationModelSelect.option('SHUTIN');
  uiKicks.migrationModelSelect.option('HARMATHY');
  uiKicks.migrationModelSelect.option('MODIFIED_HARMATHY');
  uiKicks.migrationModelSelect.selected(formationFluidMigrationModel);
  styleKicksInput(uiKicks.migrationModelSelect);
  uiKicks.migrationModelSelect.changed(() => {
    formationFluidMigrationModel = uiKicks.migrationModelSelect.value();
  });

  // Help text (more compact)
  createDiv(
    `<div style="margin-top:8px;font-size:9px;opacity:.65;line-height:1.2">
      <b>Manual:</b> Set influx rate (gpm).<br/>
      <b>Pressure:</b> Q = PI √ó (P<sub>pore</sub> - BHP).<br/>
      Triangles show kick depth on charts.
    </div>`
  ).parent(uiKicks.root);

  refreshKicksUI();
}

function styleKicksInput(inp) {
  inp.style('background', 'rgba(255,255,255,0.07)')
     .style('color', '#EEE')
     .style('border', '1px solid rgba(255,100,100,0.2)')
     .style('height', '22px')
     .style('padding', '0 6px')
     .style('border-radius', '4px')
     .style('font-size', '11px')
     .style('width', '100%');

  // Special handling for select dropdowns to fix white-on-white text issue
  // The dropdown menu has a white background, so options need dark text
  if (inp.elt && inp.elt.tagName === 'SELECT') {
    // Add CSS to make option text dark (visible on white dropdown background)
    const selectElt = inp.elt;
    const style = document.createElement('style');
    style.textContent = `
      select option {
        background-color: white !important;
        color: #222 !important;
      }
      select option:hover {
        background-color: #e0e0e0 !important;
      }
    `;
    if (!document.querySelector('style[data-select-fix]')) {
      style.setAttribute('data-select-fix', 'true');
      document.head.appendChild(style);
    }
  }
}

function refreshKicksUI() {
  if (!uiKicks.root) return;

  // Show/hide divs based on mode
  if (kickMode === 'MANUAL') {
    uiKicks.manualDiv.show();
    uiKicks.pressureDiv.hide();
  } else {
    uiKicks.manualDiv.hide();
    uiKicks.pressureDiv.show();
  }

  // Update button text
  uiKicks.modeBtn.html(kickMode === 'MANUAL' ? 'Mode: Manual' : 'Mode: Pressure-Driven');
  uiKicks.toggleBtn.html(formationFluidEnabled ? 'Kicks: ON' : 'Kicks: OFF');
}

// --------- SIMPLE BADGES / ICONS ---------
function drawBadge(x,y, line1, line2=""){
  push();
  textAlign(CENTER,CENTER); rectMode(CENTER);
  noStroke(); fill(0,0,30,200); rect(x, y, 210, 40, 8);
  fill(0,0,95); textSize(12);
  if (line2){
    text(line1, x, y-8);
    text(line2, x, y+8);
  } else {
    text(line1, x, y);
  }
  pop();
}
function drawStar(x,y){
  push(); noStroke(); fill(50,80,90);
  const r1=6,r2=3,n=5; beginShape();
  for(let i=0;i<2*n;i++){
    const a = i*PI/n;
    const r = (i%2===0)?r1:r2;
    vertex(x + r*Math.cos(a), y + r*Math.sin(a));
  } endShape(CLOSE);
  pop();
}

// --------- GAUGE ---------
function drawGauge(cx, cy, value, vMax, label, units, r, labelSide){
  noFill(); stroke(0,0,95); strokeWeight(2.5); arc(cx,cy,r*2,r*2,PI,TWO_PI);
  strokeWeight(6); stroke(120,60,80); arc(cx,cy,r*2,r*2, PI,PI+0.33*PI);
  stroke(40,70,80); arc(cx,cy,r*2,r*2, PI+0.33*PI,PI+0.66*PI);
  stroke(0,80,80); arc(cx,cy,r*2,r*2, PI+0.66*PI,TWO_PI);
  const norm = clamp(value/Math.max(1e-9,vMax),0,1);
  const ang = PI + norm*PI;
  stroke(0,0,95); strokeWeight(2.5); line(cx,cy,cx+r*cos(ang),cy+r*sin(ang));
  noStroke(); fill(0,0,95); circle(cx,cy,7);
  fill(0,0,95); textSize(Math.max(12,Math.round(r*0.26)));
  const dec=(units==='ppg'?2:0); text(`${nf(value,0,dec)} ${units}`,cx,cy+(r*0.35));
  fill(0,0,80); textSize(Math.max(10,Math.round(r*0.18)));
  textAlign(labelSide==="left"?RIGHT:LEFT,CENTER);
  const lx=labelSide==="left"?(cx-r-14):(cx+r+14);
  text(label,lx,cy);
  textAlign(CENTER,CENTER);
}

// --------- CHART PANELS + PLOTS ---------
function drawChartPanel(x, y, w, h, title){
  noStroke(); fill(0,0,20,200); rect(x-10, y-14, w+20, h+44, 10);
  fill(0,0,0); rect(x, y, w, h, 8);
  fill(0,0,95); noStroke(); textSize(14); textAlign(CENTER, TOP);
  text(title, x + w/2, y + h + 6);
}
function drawChartGrid(x,y,w,h, padL,padR,padT,padB, gridCol){
  const left = x+padL, right=x+w-padR, top=y+padT, bottom=y+h-padB;
  push();
  stroke(gridCol);
  strokeWeight(1);
  // horizontal lines
  for (let i=0; i<=6; i++){
    const yy = top + i*(bottom-top)/6;
    line(left, yy, right, yy);
  }
  // vertical lines
  for (let i=0; i<=4; i++){
    const xx = left + i*(right-left)/4;
    line(xx, top, xx, bottom);
  }
  pop();
}

function drawAxes(x,y,w,h, padL,padR,padT,padB, axisCol){
  const left = x+padL, right=x+w-padR, top=y+padT, bottom=y+h-padB;
  push(); stroke(axisCol); strokeWeight(2); line(left,top,left,bottom); line(left,bottom,right,bottom); pop();
}

function drawDepthTicks(x,y,w,h,padL,padR,padT,padB,col){
  const innerH=h-padT-padB, left=x+padL, top=y+padT;
  fill(col); noStroke(); textSize(11); textAlign(RIGHT, CENTER);
  stroke(col); strokeWeight(1.5);
  
  for (let d=0; d<=MAX_DEPTH; d+=1000){
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true); // 0 at top
    line(left-5, yy, left, yy);
    noStroke(); 
    text(`${d}`, left-8, yy); 
    stroke(col);
  }
}


function drawXTicks(x,y,w,h, padL,padR,padT,padB, axisCol, xmin,xmax, ticks){
  const left = x+padL, bottom=y+h-padB, innerW = w - padL - padR;
  push(); fill(axisCol); noStroke(); textSize(10); textAlign(CENTER,TOP);
  ticks.forEach(v=>{
    const tx = left + remap(v, xmin, xmax, 0, innerW, true);
    text(`${v}`, tx, bottom+6);
  });
  pop();
}
function plotDepthFunction(x,y,w,h, padL,padR,padT,padB, fDepth, xmin, xmax, col){
  const left = x+padL, right=x+w-padR, top=y+padT, bottom=y+h-padB;
  const innerW = right-left, innerH = bottom-top;
  push(); noFill(); stroke(col); strokeWeight(2); beginShape();
  for (let d=0; d<=MAX_DEPTH; d+=25){
    const vx = clamp(fDepth(d), xmin, xmax);
    const xx = left + remap(vx, xmin, xmax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true); // 0 at top, TD at bottom

    vertex(xx, yy);
  }
  endShape(); pop();
}
function plotDepthOverlay(x,y,w,h, padL,padR,padT,padB, arr, xmin,xmax, col){
  const left = x+padL, right=x+w-padR, top=y+padT, bottom=y+h-padB;
  const innerW = right-left, innerH = bottom-top;
  const step = Math.floor(MAX_DEPTH/ (arr.length-1));
  push(); noFill(); stroke(col); strokeWeight(1.5); beginShape();
  for (let i=0;i<arr.length;i++){
    const d = i*step;
    const v = clamp(arr[i], xmin, xmax);
    const xx = left + remap(v, xmin, xmax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true); // 0 at top, TD at bottom

    vertex(xx, yy);
  } endShape(); pop();
}
function plotDepthFunctionMasked(x,y,w,h, padL,padR,padT,padB, fDepth, xmin,xmax, col, maskFn){
  const left = x+padL, right=x+w-padR, top=y+padT, bottom=y+h-padB;
  const innerW = right-left, innerH = bottom-top;
  push(); noFill(); stroke(col); strokeWeight(2); beginShape();
  for (let d=0; d<=MAX_DEPTH; d+=25){
    const v = fDepth(d);
    if (!maskFn(v)) { endShape(); beginShape(); continue; }
    const xx = left + remap(v, xmin, xmax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true); // 0 at top, TD at bottom

    vertex(xx, yy);
  } endShape(); pop();
}
function plotDepthOverlayMasked(x,y,w,h, padL,padR,padT,padB, arr, xmin,xmax, col, maskFn){
  const left = x+padL, right=x+w-padR, top=y+padT, bottom=y+h-padB;
  const innerW = right-left, innerH = bottom-top;
  const step = Math.floor(MAX_DEPTH/ (arr.length-1));
  push(); noFill(); stroke(col); strokeWeight(1.5); beginShape();
  for (let i=0;i<arr.length;i++){
    const d = i*step, v = arr[i];
    if (!maskFn(v)) { endShape(); beginShape(); continue; }
    const xx = left + remap(v, xmin, xmax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true); // 0 at top, TD at bottom

    vertex(xx, yy);
  } endShape(); pop();
}



// ============================== RHEOLOGY UI BUILDER =============================
function buildRheologyUI(x0, y0){
  const label = (txt, x, y) =>
    createDiv(txt).position(x,y).style("color","#E6E6E6").style("font-size","12px");
  const box = (val, x, y, w=80) => {
    const el = createInput(String(val), 'number'); el.position(x,y).size(w); return el;
  };
  const SEP_Y = 50; // vertical spacing
  const COL_W = 100;
  const COL_GAP = 10;
  const xs = i => x0 + i * (COL_W + COL_GAP);
  // --- Model selector (create first, then bind) ---
  label("Rheology Model", x0, y0-30);
  rheoPanel.modelSel = createSelect();
  rheoPanel.modelSel.position(x0, y0-14).size(130, 24);
  ["HB","PowerLaw","Bingham"].forEach(o => rheoPanel.modelSel.option(o));
  rheoPanel.modelSel.selected(ACTIVE_RHEO_MODEL || "HB");
  rheoPanel.modelSel.changed(() => {
    ACTIVE_RHEO_MODEL = rheoPanel.modelSel.value();
    doRheologyFit(); // ensure PV/YP-direct or R-points apply immediately
  });

  // --- Friction Mode selector ---
  label("Friction Mode", x0+150, y0-30);
  rheoPanel.frictionSel = createSelect();
  rheoPanel.frictionSel.position(x0+150, y0-14).size(110, 24);
  ["hydraulics","generic"].forEach(o => rheoPanel.frictionSel.option(o));
  rheoPanel.frictionSel.selected(FRICTION_MODE || "hydraulics");
  rheoPanel.frictionSel.changed(() => {
    FRICTION_MODE = rheoPanel.frictionSel.value();
  });

  // --- Hydraulics Model selector ---
  label("Hydraulics Model", x0+280, y0-30);
  rheoPanel.hydraulicsSel = createSelect();
  rheoPanel.hydraulicsSel.position(x0+280, y0-14).size(110, 24);
  ["Refined","API"].forEach(o => rheoPanel.hydraulicsSel.option(o));
  rheoPanel.hydraulicsSel.selected(HYDRAULICS_MODEL || "Refined");
  rheoPanel.hydraulicsSel.changed(() => {
    HYDRAULICS_MODEL = rheoPanel.hydraulicsSel.value();
  });

  // --- Inputs ---
  let y = y0 + 90;
  label("Funnel (s/qt)", xs(0), y-18); rheoPanel.fv = box(rheoDefaults.fv, xs(0), y);
  label("Temp (¬∞C)", xs(1), y-18); rheoPanel.T = box(rheoDefaults.T, xs(1), y);
  label("R600", xs(2), y-18); rheoPanel.R600 = box(rheoDefaults.R600, xs(2), y);
  label("R300", xs(3), y-18); rheoPanel.R300 = box(rheoDefaults.R300, xs(3), y);
  label("R200", xs(4), y-18); rheoPanel.R200 = box(rheoDefaults.R200, xs(4), y);
  label("R100", xs(5), y-18); rheoPanel.R100 = box(rheoDefaults.R100, xs(5), y);
  y += SEP_Y;
  label("R6", xs(0), y-18); rheoPanel.R6 = box(rheoDefaults.R6, xs(0), y);
  label("R3", xs(1), y-18); rheoPanel.R3 = box(rheoDefaults.R3, xs(1), y);
  label("R1", xs(2), y-18); rheoPanel.R1 = box(rheoDefaults.R1, xs(2), y);
  label("PV (cP)", xs(3), y-18); rheoPanel.PV = box(rheoDefaults.PV, xs(3), y);
  label("YP (lbf/100ft¬≤)",xs(4), y-18);rheoPanel.YP = box(rheoDefaults.YP, xs(4), y, 110);
  // --- Actions & status ---
  y += SEP_Y-10;
  rheoPanel.fitBtn = createButton("Fit curves").position(x0, y).size(110, 26);
  rheoPanel.showFitBtn = createButton("Show fitted params").position(x0+120, y).size(170, 26);
  rheoPanel.fitBtn.mousePressed(() => doRheologyFit());
  rheoPanel.showFitBtn.mousePressed(() => showFittedParams());
  rheoPanel.statusDiv = createDiv("Awaiting fit.");
  rheoPanel.statusDiv.position(x0+300, y+2).style("color","#CCCCCC").style("font-size","12px");
  // Re-fit whenever any rheology input changes (incl. PV/YP)
  [
    rheoPanel.R600, rheoPanel.R300, rheoPanel.R200, rheoPanel.R100,
    rheoPanel.R6, rheoPanel.R3, rheoPanel.R1,
    rheoPanel.PV, rheoPanel.YP
  ].forEach(el => { if (el) el.input(() => doRheologyFit()); });
}


// =========================== STATE SETTERS ============================
function setDSMW(v){
  MW_DS = clamp(Number(v)||0, MW_MIN, MW_MAX);
  dsMWSlider?.value(MW_DS); dsMWInput?.value(nf(MW_DS,1,1));
  // seed the DS grid with the new MW at the inlet
  if (dsGrid && dsGrid.length){ dsGrid[0] = MW_DS; }
}
function setBOMW(v){
  MW_BO = clamp(Number(v)||0, MW_MIN, MW_MAX);
  boMWSlider?.value(MW_BO); boMWInput?.value(nf(MW_BO,1,1));
  if (boosterGrid && boosterGrid.length){ boosterGrid[0] = MW_BO; }
}
function setDSQ(v){
  Q_DS = clamp(Number(v)||0, Q_MIN, Q_MAX);
  dsQSlider?.value(Q_DS); dsQInput?.value(nf(Q_DS,1,0));
}
function setBOQ(v){
  Q_BO = clamp(Number(v)||0, Q_MIN, Q_MAX);
  boQSlider?.value(Q_BO); boQInput?.value(nf(Q_BO,1,0));
}
function setK(v){
  K_FAC = clamp(Number(v)||0, 0.0, 0.0002);
  kSlider?.value(K_FAC); kInput?.value(nf(K_FAC,1,6));
}
function setRPM(v){
  RPM = clamp(Number(v)||0, 0, 220);
  rpmSlider?.value(RPM); rpmInput?.value(String(RPM));
}
function setFrictionMode(mode){
  FRICTION_MODE = (mode==='generic') ? 'generic' : 'hydraulics';
}
window._setFric = setFrictionMode;
window._setRPM  = setRPM;
window._EH      = EH;