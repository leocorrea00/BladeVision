// ========================== CONFIG & CONSTANTS ==========================
const MAX_DEPTH = 5000; // m
const BOP_DEPTH = 2000; // m
const SHOE_DEPTH = 4000; // m
const TD_DEPTH = 5000; // m
const PSI_COEF = 0.1704; // psi per (ppg·m)
const PPG_TO_KGM3 = 119.826427; // kg/m³ per ppg
const LBF100FT2_to_Pa = 0.4788025892; // Pa per (lbf/100ft^2)
// Flow limits for UI
const MW_MIN = 7.0, MW_MAX = 18.0, MW_STEP = 0.1;
const Q_MIN = 0, Q_MAX = 1000, Q_STEP = 10;
// Discretization (for fluid tracking)
const CELL_M = 25;
const N_DS = Math.ceil(TD_DEPTH / CELL_M);
const N_ABV = Math.ceil(BOP_DEPTH / CELL_M);
const N_BELOW = Math.ceil((TD_DEPTH - BOP_DEPTH) / CELL_M);
// Advection tuning (simple, frame-based)
const Q_REF = 500;
const BASE_M_PER_FRAME = CELL_M * 0.5;
// --- Rotation coupling tunables ---
const ROT_COUPLE = 3.0; // scales how strongly rotation adds to effective shear
const TAYLOR_BOOST = { Ta_c: 1200, C0: 0.18, Cn: 0.6 }; // stronger Taylor boost
// --- Safe, non-p5 helpers (no name collisions) ---
function clamp(val, min, max){ return Math.max(min, Math.min(max, val)); }
function remap(x, inMin, inMax, outMin, outMax, withinBounds=false){ if (inMax === inMin) return outMin; // avoid /0
  const t = (x - inMin) / (inMax - inMin);
  let y = outMin + t * (outMax - outMin);
  if (withinBounds){ const lo = Math.min(outMin, outMax); const hi = Math.max(outMin, outMax); y = Math.max(lo, Math.min(hi, y)); }
  return y;
}
// Graphics (some defaults; refined in setup)
let W = 2100, H = 980;
let well = { x: 140, y: 130, w: 160, h: 420 };
let dp = { w: 60 };
const GAUGE_SCALE = 0.70, R_BASE = 65;
const R = Math.round(R_BASE * GAUGE_SCALE);
// Reference marks to annotate
const MARKS = [ { d: BOP_DEPTH, name: "BOP" }, { d: SHOE_DEPTH, name: "Casing Shoe" }, { d: TD_DEPTH, name: "TD" } ];
// ============================ GLOBAL STATE =============================
let HYDRAULICS_MODEL = "Refined"; // "API" | "Refined"
let FRICTION_MODE = "hydraulics"; // keep hydraulics by default
let ACTIVE_RHEO_MODEL = "HB"; // "HB" | "PowerLaw" | "Bingham"
let fitParams = { mu_p_Pa_s: null, tau_y_Pa: null, K_PL_Pa_s_n: null, n_PL: null, K_HB_Pa_s_n: null, n_HB: null, tau_y_HB_Pa: null };
// Fluids / flows
let MW_DS = 9.5; // ppg, drillstring
let MW_BO = 10.0; // ppg, booster line
let Q_DS = 500; // gpm
let Q_BO = 100; // gpm
// Rotational speed (affects shear)
let RPM = 80;
// Generic friction fallback (when FRICTION_MODE === "generic")
let K_FAC = 0.00005;
// Level deficits (U-tube), meters from surface
let levelDeficit_m = 0; // DS
let levelDeficit_bo_m = 0; // Booster
// Rheology / gel
let gel_Pa = 5.0;
let use_gel = true;
// Geometry (inches → meters in setup)
let riser_ID_in = 21.0;
let casing_ID_in = 9.625;
let openhole_OD_in = 8.5;
let ds_OD_in = 5.0;
let ds_ID_in = 3.75;
let booster_ID_in = 4.5;
let riser_ID_m = 0, casing_ID_m = 0, openhole_ODm = 0, ds_OD_m = 0, ds_ID_m = 0, booster_ID_m = 0;
// Segmented tracking grids
let dsGrid = new Array(N_DS).fill(MW_DS); // downwards
let annBelowGrid = new Array(N_BELOW).fill(MW_DS); // upwards (BOP→TD)
let annAboveGrid = new Array(N_ABV).fill(MW_DS); // upwards (Surf→BOP)
let boosterGrid = new Array(N_ABV).fill(MW_BO); // downwards (Surf→BOP)
// fractional advection accumulators
let accDS = 0, accBelow = 0, accAbove = 0, accBo = 0;
// MPD / SBP
let MPD_ON = false;
let SBP_MODE = "manual"; // "manual" | "anchor"
let SBP_MANUAL = 0;
let CURRENT_SBP = 0;
let ANCHOR_DEPTH = 0;
let ANCHOR_ECD = 0;
// Time series
const TS_MAX = 600, TS_STRIDE = 5;
let tsFlow = [], tsPactual = [], tsPset = [], tsSBP = [], tsSPP = [], tsFrame = 0, lastSPP = 0;
// UI refs (created in setup)
let apDepthInput, apEcdInput;
let dsMWSlider, dsMWInput, dsQSlider, dsQInput;
let boMWSlider, boMWInput, boQSlider, boQInput;
let kSlider, kInput;
let rpmSlider, rpmInput;
let sbpSlider, sbpInput;
let mpdBtn, sbpModeBtn, captureBtn, displayBtn, fricBtn, hydBtn;
let rheoPanel = {};
let frameWidth;
// Captured overlays
let capturedP = null;
let capturedECD = null;
let showCaptured = false;
// Advection coupling FIFOs (ensure arrival order)
let bitOutQ = []; // DS → TD (bit exit) → feeds annBelow bottom
let belowOutQ = []; // annBelow top → BOP → feeds annAbove
let boosterOutQ = []; // Booster bottom → BOP → feeds annAbove
// --- bottom frames (for Rheology/Gels/Geometry) ---
let frameY, frameHeight;
let rheoFrameX, rheoFrameW, gelFrameX, gelFrameW, geomFrameX, geomFrameW;
let cmlQSlider, cmlQInput, cmlDepthInput, cmlBtn, cmlAutoBtn;

// Booster SPP smoothing (top-level)
let BoosterSPP_smooth = 0;
function updateBoosterSPP(target){
  BoosterSPP_smooth = BoosterSPP_smooth + SPP_ALPHA * (target - BoosterSPP_smooth);
  return BoosterSPP_smooth;
}
// Defaults for rheology inputs
let rheoDefaults = { fv: 72, T: 49, R600: 69.4, R300: 46.3, R200: 36.3, R100: 27.6, R6: 12.0, R3: 11.9, R1: 9.5, PV: 40, YP: 22, G10s: 18.5, G10m: 26.9, G30m: 27.2 };
let ehFrameX, ehFrameW, ehFrameY, ehFrameH;
// SPP smoothing
const SPP_ALPHA = 0.15; // 0–1 (higher = faster response)
let SPP_smooth = 0;
function updateSPP(targetSPP){
  SPP_smooth = SPP_smooth + SPP_ALPHA*(targetSPP - SPP_smooth);
  return SPP_smooth;
}
// -------- Enhanced Hydraulics (flags + sliders) --------
let EH_ON = true; // master section is visible
// Each feature has: ON/OFF + slider in [-1, +1] where 0 = nominal
let EH = {
  ECC: { on: false, s: 0.0 }, // Eccentric annulus effect
  ROUGH: { on: false, s: 0.0 }, // Roughness effect (turbulent primarily)
  KLOSS: { on: false, s: 0.0 }, // Local K-losses (bit, tools) into SPP/Booster SPP
  PCOR: { on: false, s: 1.0, fluid: "WBM" }, // P-only corrections (ρ & μ) with strength scalar
};
// UI refs
let ehPanel = {};
// Optional baselines you can tune
const EH_TUNE = {
  ecc_max_gain: 0.40, // up to ±40% dp change in tight annuli due to eccentricity
  rough_max_gain: 0.60, // up to ±60% on turbulent f (stronger at high Re)
  kloss_spp_base: 250, // psi baseline extra when s=+1 (and -250 psi at s=-1)
};
// --- P-only correction knobs ---
const PSI_TO_PA = 6894.757;
// Compressibility β (1/Pa) at surface pressure (simplified constant value)
function betaCompressibility(fluid) {
  if (fluid === "WBM") return 4.5e-10; // Water-based mud
  if (fluid === "OBM") return 1.0e-9; // Oil-based mud
  if (fluid === "Diesel") return 1.4e-9; // Diesel
  return 8e-10; // Default
}
// Pressure-viscosity coefficient α (1/Pa) (simplified constant)
function alphaPV(fluid) {
  if (fluid === "WBM") return 2e-10; // Negligible for WBM
  if (fluid === "OBM") return 1.0e-8; // Moderate for OBM
  if (fluid === "Diesel") return 1.4e-8; // Higher for Diesel
  return 1e-9; // Default
}
// Hydrostatic + SBP only (NO friction) → safe for P-only rheology scaling
function pressureForPCOR(d){
  const depth = Math.max(0, d);
  const ecd = ecdAtDepth(depth); // uses only the grids, no hydraulics
  const P_hyd = PSI_COEF * ecd * depth; // psi
  const P_sbp = (CURRENT_SBP || 0); // psi
  return P_hyd + P_sbp; // psi
}
// Apply pressure-only correction at a representative depth
function applyPressureOnly(d, rho0, K0, n0, tauY0) {
  if (!EH.PCOR.on) return { rho: rho0, K: K0, n: n0, tauY: tauY0 };
  // IMPORTANT: use friction-free pressure to avoid recursion
  const P_pa = Math.max(pressureForPCOR(d), 0) * PSI_TO_PA;
  const beta = betaCompressibility(EH.PCOR.fluid) * EH.PCOR.s; // density vs P
  const alpha = alphaPV(EH.PCOR.fluid) * EH.PCOR.s; // viscosity vs P
  const deltaP = P_pa - 101325; // vs surface (Pa)
  const rhoP = rho0 * Math.exp(beta * deltaP); // corrected density
  const KP = Math.max(K0,1e-9) * Math.exp(alpha * deltaP); // corrected K
  return { rho: rhoP, K: KP, n: n0, tauY: tauY0 };
}

// ======== CML (Controlled Mud Level) ========
let CML_ON = false; // master toggle
let CML_DEPTH = 0; // m (0..BOP_DEPTH)
let Q_CML = 0; // gpm (manual command)
let AUTO_CML_ON = false; // anchor controller
let CML_AP_DEPTH = 0; // m (anchor depth for AUTO-CML)
let CML_AP_ECD = 0; // ppg (anchor ECD for AUTO-CML)
let CML_Q_MAX = 0; // dynamic: max allowed (DS+Booster)
// riser top exposed to atmosphere due to CML pump (depth from surface)
let CML_TOP_DEPTH = 0; // m (0 = riser full)
// CML pipe (visual-only) fluid tracking (upwards to surface)
let cmlPipeGrid = new Array(N_ABV).fill(MW_DS);
let accCML = 0; // advection accumulator for CML pipe
// ============================== UTILITIES ==============================
function num(v){ if (v==null) return 0; const s=String(v).trim().replace(',','.'); const x=parseFloat(s); return isFinite(x)?x:0; }
function average(arr){ if (!arr.length) return 0; return arr.reduce((a,b)=>a+b,0)/arr.length; }
function sumCells(arr,i0,i1){ if (i1<i0) return 0; i0=Math.max(0,i0); i1=Math.min(arr.length-1,i1); let s=0; for(let i=i0;i<=i1;i++) s+=arr[i]; return s; }
function area_circ(D){ return Math.PI * (D*D) / 4; }
function area_annulus(Do, Di){ return Math.max(Math.PI * (Do*Do - Di*Di) / 4, 1e-12); }
function Dh_annulus(Do, Di){ return Math.max(Do - Di, 1e-6); }
function smooth01(x){ return 1/(1+Math.exp(-8*(x-0.5))); }
function mapDepthToY(d){ return remap(d, 0, MAX_DEPTH, well.y, well.y + well.h); }
function riserTopDepth(){ return CML_ON ? Math.max(0, Math.min(CML_TOP_DEPTH, BOP_DEPTH)) : 0; }
function safeRheoVal(key, def){
  const el = rheoPanel && rheoPanel[key];
  return (el && typeof el.value === 'function') ? num(el.value()) : def;
}
// --- U-tube helper (riser leg: surface -> pump depth) ---
function dPperM_riserLeg_forUTube(Q, dTop, dPump){
  // use the same riser annulus model, but only the wet span (surface→top is "dry")
  const L = Math.max(0, Math.min(BOP_DEPTH, dPump) - Math.max(0, dTop));
  if (L <= 0) return 0;
  // Use your existing function for the riser section at current total annulus flow
  return dPperM_riserAnnulus(Q);
}
// Linearized hydraulic resistance of the leg (psi per m³/s)
function riserLegResistancePsiPer_m3s(dTop, dPump){
  const L = Math.max(0, Math.min(BOP_DEPTH, dPump) - Math.max(0, dTop));
  if (L <= 0) return 1e9; // practically infinite (no wet column)
  // Evaluate slope around a small reference flow through the leg
  const qRef = (Q_REF/15850.323); // m³/s
  const dpdl_Pa = dPperM_riserLeg_forUTube(qRef, dTop, dPump); // Pa/m
  const dp_Pa = dpdl_Pa * L; // Pa
  const dp_psi = dp_Pa * PSI_PER_PASCAL; // psi
  // “resistance” R = ΔP / Q (psi per m³/s)
  return Math.max(dp_psi / Math.max(qRef, 1e-9), 1); // avoid tiny values
}
// --- Visual column helpers (ADD near other helpers) ---
function clipFillY_forRiser(){
  const wetTop = riserTopDepth(); // 0..BOP
  return mapDepthToY(wetTop);
}
function clipFillY_forDS(){
  const dsTop = clamp(levelDeficit_m, 0, TD_DEPTH);
  return mapDepthToY(dsTop);
}
function clipFillY_forBooster(){
  const boTop = clamp(levelDeficit_bo_m, 0, BOP_DEPTH);
  return mapDepthToY(boTop);
}
// --- CML visual helpers (ADD near mapDepthToY / riserTopDepth) ---
function cmlPumpY() {
  // clamp to riser leg interval (0..BOP_DEPTH)
  const d = clamp(CML_DEPTH || 0, 0, BOP_DEPTH);
  return mapDepthToY(d);
}
// ============================ RHEOLOGY CORE ============================
function getRheoForCalc(){
  let K, n, tauY;
  if (ACTIVE_RHEO_MODEL === "Bingham"){
    K = Math.max(fitParams.mu_p_Pa_s || 0, 1e-6);
    n = 1.0;
    tauY = Math.max(fitParams.tau_y_Pa || 0, 0);
  } else if (ACTIVE_RHEO_MODEL === "PowerLaw"){
    K = Math.max(fitParams.K_PL_Pa_s_n || 0.05, 1e-6);
    n = clamp(fitParams.n_PL ?? 0.9, 0.25, 1.0);
    tauY = 0;
  } else { // HB
    K = Math.max(fitParams.K_HB_Pa_s_n || 0.05, 1e-6);
    n = clamp(fitParams.n_HB ?? 0.9, 0.25, 1.0);
    tauY = Math.max(fitParams.tau_y_HB_Pa || 0, 0);
  }
  return { K, n, tauY };
}
// Rheology fitting functions
function collectRheoPoints(){
  const rVal = (key, def) => {
    const el = rheoPanel && rheoPanel[key];
    if (el && typeof el.value === 'function') return num(el.value());
    return def;
  };
  const rows = [
    { rpm: 600, dial: rVal('R600', rheoDefaults.R600) },
    { rpm: 300, dial: rVal('R300', rheoDefaults.R300) },
    { rpm: 200, dial: rVal('R200', rheoDefaults.R200) },
    { rpm: 100, dial: rVal('R100', rheoDefaults.R100) },
    { rpm: 6, dial: rVal('R6', rheoDefaults.R6) },
    { rpm: 3, dial: rVal('R3', rheoDefaults.R3) },
    { rpm: 1, dial: rVal('R1', rheoDefaults.R1) },
  ].filter(r => r.dial > 0);
  return rows.map(r => {
    const gdot = 1.703 * r.rpm; // s^-1
    const tauPa = r.dial * LBF100FT2_to_Pa; // Pa
    return { gdot, tauPa, rpm: r.rpm, dial: r.dial };
  });
}
function fitBingham(pts){
  let Sx=0, Sy=0, Sxx=0, Sxy=0, n=0;
  for (const p of pts){
    const x=p.gdot, y=p.tauPa;
    Sx+=x; Sy+=y; Sxx+=x*x; Sxy+=x*y; n++;
  }
  if (n<2){ return {mu_p:null, tau_y:null, sse:Infinity}; }
  const denom = (n*Sxx - Sx*Sx) || 1e-12;
  const b = (n*Sxy - Sx*Sy)/denom; // μp
  const a = (Sy - b*Sx)/n; // τy
  let sse=0;
  for(const p of pts){
    const yhat=a+b*p.gdot;
    sse+=(p.tauPa-yhat)**2;
  }
  return { mu_p: Math.max(b,0), tau_y: Math.max(a,0), sse };
}
function fitPowerLaw(pts){
  let Sx=0, Sy=0, Sxx=0, Sxy=0, n=0;
  for(const p of pts){
    if (p.tauPa<=0 || p.gdot<=0) continue;
    const x=Math.log(p.gdot), y=Math.log(p.tauPa);
    Sx+=x; Sy+=y; Sxx+=x*x; Sxy+=x*y; n++;
  }
  if (n<2){ return {K:null, n:null, sse:Infinity}; }
  const denom=(n*Sxx - Sx*Sx) || 1e-12;
  const n_pl=(n*Sxy - Sx*Sy)/denom;
  const logK=(Sy - n_pl*Sx)/n;
  const K=Math.exp(logK);
  let sse=0;
  for(const p of pts){
    if (p.tauPa<=0 || p.gdot<=0) continue;
    const yhat=Math.log(K) + n_pl*Math.log(p.gdot);
    sse+=(Math.log(p.tauPa)-yhat)**2;
  }
  return {K, n: n_pl, sse};
}
function fitHB(pts){
  const taus = pts.map(p => p.tauPa);
  const tauMin = 0;
  const tauMax = Math.max(...taus) * 0.9;
  let best = { tau_y:null, K:null, n:null, sse:Infinity };
  const coarseSteps = 60; // coarse sweep
  for (let i=0; i<=coarseSteps; i++){
    const tau_y = tauMin + (tauMax - tauMin) * i / coarseSteps;
    const res = [];
    for (const p of pts){
      const tr = p.tauPa - tau_y;
      if (tr > 0 && p.gdot > 0) res.push({ gdot:p.gdot, tauR:tr, rpm:p.rpm });
    }
    if (res.length < 2) continue;
    let Sx=0, Sy=0, Sxx=0, Sxy=0, n=0;
    for (const r of res){
      const x=Math.log(r.gdot), y=Math.log(r.tauR);
      Sx+=x; Sy+=y; Sxx+=x*x; Sxy+=x*y; n++;
    }
    const denom = (n*Sxx - Sx*Sx) || 1e-12;
    const nHB = (n*Sxy - Sx*Sy)/denom;
    const logK = (Sy - nHB*Sx)/n;
    const KHB = Math.exp(logK);
    // mild weighting for low-shear points (stabilizes τy)
    let sse=0;
    for (const p of pts){
      const pred = tau_y + KHB*Math.pow(p.gdot, nHB);
      const w = (p.rpm <= 100) ? 1.5 : 1.0;
      sse += w * Math.pow(p.tauPa - pred, 2);
    }
    if (sse < best.sse) best = { tau_y, K:KHB, n:nHB, sse };
  }
  // local refine around best
  if (isFinite(best.sse) && best.tau_y != null){
    const t0 = best.tau_y;
    const lo = Math.max(0, t0*0.8), hi = t0*1.2;
    for (let i=0; i<=60; i++){
      const tau_y = lo + (hi-lo)*i/60;
      const res = [];
      for (const p of pts){
        const tr = p.tauPa - tau_y;
        if (tr>0 && p.gdot>0) res.push({ gdot:p.gdot, tauR:tr, rpm:p.rpm });
      }
      if (res.length < 2) continue;
      let Sx=0, Sy=0, Sxx=0, Sxy=0, n=0;
      for (const r of res){
        const x=Math.log(r.gdot), y=Math.log(r.tauR);
        Sx+=x; Sy+=y; Sxx+=x*x; Sxy+=x*y; n++;
      }
      const denom=(n*Sxx - Sx*Sx) || 1e-12;
      const nHB=(n*Sxy - Sx*Sy)/denom;
      const logK=(Sy - nHB*Sx)/n;
      const KHB=Math.exp(logK);
      let sse=0;
      for (const p of pts){
        const pred = tau_y + KHB*Math.pow(p.gdot, nHB);
        const w = (p.rpm <= 100) ? 1.5 : 1.0;
        sse += w * Math.pow(p.tauPa - pred, 2);
      }
      if (sse < best.sse) best = { tau_y, K:KHB, n:nHB, sse };
    }
  }
  return best;
}
function doRheologyFit(){
  const pts = collectRheoPoints();
  if (!pts.length){
    rheoPanel.statusDiv.html("No rheology points provided.");
    return;
  }
  // Direct Bingham if PV/YP are provided and Bingham is selected
 const PVcp = safeRheoVal('PV', 0); // cP
 const YPlbf = safeRheoVal('YP', 0); // lbf/100ft²
  const usePVYP = (ACTIVE_RHEO_MODEL === "Bingham") && (PVcp > 0 || YPlbf > 0);
  let b, p, h;
  if (usePVYP){
    b = { mu_p: PVcp * 1e-3, // Pa·s
         tau_y: YPlbf * LBF100FT2_to_Pa, // Pa
         sse: 0 };
  } else {
    b = fitBingham(pts);
  }
  p = fitPowerLaw(pts);
  h = fitHB(pts);
  fitParams.mu_p_Pa_s = b.mu_p ?? fitParams.mu_p_Pa_s;
  fitParams.tau_y_Pa = b.tau_y ?? fitParams.tau_y_Pa;
  fitParams.K_PL_Pa_s_n = p.K;
  fitParams.n_PL = p.n;
  fitParams.K_HB_Pa_s_n = h.K;
  fitParams.n_HB = h.n;
  fitParams.tau_y_HB_Pa = h.tau_y;
  // gel from 10s if provided
const g10s = safeRheoVal('G10s', rheoDefaults.G10s ?? 0);
if (g10s > 0) gel_Pa = g10s * LBF100FT2_to_Pa;
  const srcNote = usePVYP ? "Bingham (PV/YP direct)" : "Bingham (regressed)";
  rheoPanel.statusDiv.html(
    `Fit OK <br> ${srcNote} <br> Bingham SSE=${(b.sse??0).toFixed(3)} <br>
PL SSE=${(p.sse??0).toFixed(3)} <br>
HB SSE=${(h.sse??0).toFixed(3)}`
  );
}
function showFittedParams(){
  const s = (v, d=4) => (v == null ? "—" : Number(v).toFixed(d));
  const msg = `
    Model = ${ACTIVE_RHEO_MODEL}<br>
    + Bingham: μp = ${s(fitParams.mu_p_Pa_s)} Pa·s; τy = ${s(fitParams.tau_y_Pa)} Pa<br>
    + Power-Law: K = ${s(fitParams.K_PL_Pa_s_n)} Pa·s^n; n = ${s(fitParams.n_PL)}<br>
    + HB: K = ${s(fitParams.K_HB_Pa_s_n)} Pa·s^n; n = ${s(fitParams.n_HB)}; τy = ${s(fitParams.tau_y_HB_Pa)} Pa;
  `;
  rheoPanel.statusDiv.html(msg);
}
// =========================== HYDRAULICS CORE ===========================
// Rotation shear rates
function rotShearRateAnnulus(rpm, Di, Do){
  if (rpm <= 0) return 0;
  const omega = TWO_PI * rpm / 60;
  const Ri = Math.max(Di,1e-6) / 2;
  const gap = Math.max(Do - Di, 1e-6);
  return (omega * Ri) / gap; // s^-1
}
function rotShearRatePipe(rpm, ID){
  if (rpm <= 0) return 0;
  // near-wall added shear ~ O(ω)
  return TWO_PI * rpm / 60;
}
// Taylor-number helpers (physics-based rotation boost)
function taylorNumber(rpm, Di, Do, nu){
  const omega = TWO_PI * Math.max(rpm,0) / 60;
  const Ri = Math.max(Di,1e-6) / 2;
  const gap = Math.max(Do - Di, 1e-6);
  return (omega * Ri * gap) / Math.max(nu, 1e-12);
}
function applyTaylorBoost(base, rpm, Di, Do, mu_app, rho, n){
  const nu = Math.max(mu_app,1e-9)/Math.max(rho,1e-9);
  const omega = TWO_PI * Math.max(rpm,0) / 60;
  const Ri = Math.max(Di,1e-6) / 2;
  const gap = Math.max(Do - Di, 1e-6);
  const Ta = (omega * Ri * gap) / Math.max(nu, 1e-12);
  const { Ta_c, C0, Cn } = TAYLOR_BOOST;
  if (Ta <= Ta_c) return base;
  // stronger boost; increased sensitivity for shear-thinning (n<1)
  const C = C0 * (1 + Cn * Math.max(0, 1 - (n ?? 1)));
  return base * (1 + C * Math.sqrt(Ta/Ta_c));
}
// HB laminar formulas (slot annulus + pipe)
function mu_app_HB(gdot, K, n, tauY){
  gdot = Math.max(gdot, 1e-6);
  return tauY/gdot + K*Math.pow(gdot, n-1);
}
// Annulus laminar as slot (captures yield offset)
function dpPerM_annulusLaminar_HB(Q, rho, Do, Di, K, n, tauY, rpm){
  const A = area_annulus(Do, Di);
  const b = Math.max((Do - Di)/2, 1e-6); // half-gap
  const V = Q / Math.max(A,1e-12);
  // axial + rotational shear blended in quadrature (stronger coupling)
  const g_ax = 6 * Math.abs(V) / b;
  const g_rot = rotShearRateAnnulus(rpm, Di, Do);
  const g_eff = Math.sqrt(g_ax*g_ax + (ROT_COUPLE*g_rot)*(ROT_COUPLE*g_rot));
  const g_w = ((2*n+1)/(3*n)) * Math.max(g_eff,1e-6);
  const tau_w = tauY + K*Math.pow(g_w,n);
  let dpdl = 2*tau_w / b; // Pa/m
  const muApp = mu_app_HB(g_w, K, n, tauY);
  dpdl = applyTaylorBoost(dpdl, rpm, Di, Do, muApp, rho, n);
  dpdl *= eccMultiplier(Do, Di);
  return dpdl;
}
// Pipe laminar HB (Rabinowitsch)
function dpPerM_pipeLaminar_HB(Q, rho, ID, K, n, tauY, rpm){
  const A = Math.PI*Math.max(ID*ID,1e-12)/4;
  const V = Q / A;
  const Dh = Math.max(ID,1e-6);
  const g_ax = 8 * Math.abs(V) / Dh;
  const g_rot = rotShearRatePipe(rpm, ID);
  const g_eff = Math.sqrt(g_ax*g_ax + (ROT_COUPLE*g_rot)*(ROT_COUPLE*g_rot));
  const g_w = ((3*n+1)/(4*n)) * Math.max(g_eff,1e-6);
  const tau_w = tauY + K*Math.pow(g_w,n);
  return (4*tau_w) / Dh; // Pa/m
}
// Baseline friction models
function dpPerM_API_withRot(rho, V, Dh, K, n, tauY, gdotExtra){
  const gdot = Math.max(8*V/Math.max(Dh,1e-6) + (gdotExtra||0), 1e-6);
  const muApp = tauY/gdot + K*Math.pow(gdot, n-1);
  const Re = (rho * V * Dh) / Math.max(muApp, 1e-9);
  const f = (Re < 2100) ? 16/Math.max(Re,1e-6) : 0.079/Math.pow(Math.max(Re,1e-6),0.25);
  return f * (rho*V*V/2) / Math.max(Dh,1e-6);
}
function dpPerM_Refined_withRot(rho, V, Dh, K, n, tauY, gdotExtra){
  // Blended laminar/turbulent with mild non-Newtonian adjustments
  const gdot = Math.max(8*V/Math.max(Dh,1e-6) + (gdotExtra||0), 1e-6);
  const muApp = tauY/gdot + K*Math.pow(gdot, n-1);
  const Re = (rho * V * Dh) / Math.max(muApp, 1e-9);
  const fLam = (16/Math.max(Re,1e-6))*(1 + Math.min(0.25, tauY/(K*1e-3 + 1e-6)));
  const alpha = 0.0665 + 0.0175*n, beta = 0.365 - 0.0620*n;
  const fTur = alpha/Math.pow(Math.max(Re,1e-6), beta);
  const blend = 1/(1+Math.exp(-(Re-2500)/400));
  let f = (1-blend)*fLam + blend*fTur;
  f *= (1 - 0.05*Math.max(0,1-n)); // slight shear-thinning easing
  return f * (rho*V*V/2) / Math.max(Dh,1e-6);
}
// Yield thresholds to avoid crazy low-flow spikes
function dpMin_pipe_per_m(tauY, Dh){ return 4*Math.max(tauY, use_gel ? gel_Pa : 0)/Math.max(Dh,1e-6); }
function dpMin_ann_per_m(tauY, Do, Di){ return 2*Math.max(tauY, use_gel ? gel_Pa : 0)/Math.max(Do-Di,1e-6); }
// Unified section pressure gradient
function dP_per_m_annulus_withRPM(Q, rho, Do, Di, K, n, tauY, rpm){
  if (Q <= 0) return 0;
  // TODO (industry-grade): Excentricidade do anular (e>0)
  // Apply a vetted correlation (e.g., Kelessidis/Misra) for laminar HB in eccentric annuli. This raises losses in tight gaps and is realistic.
  // TODO: Rugosidade / ε (Dodge–Metzner com rugosidade para não-Newtoniano)
  // Extend your turbulent branch to include roughness effects for non-Newtonian fluids.
  // TODO: BHA/local losses (tool joints, stabilizers, MWD, bit/nozzles)
  // Add K-losses per element and the bit nozzle DP (this can be a separate block summed into SPP).
  // TODO: Correções T/P de reologia (K, n, τy=f(T,P))
  // Simple Arrhenius/empirical maps for temperature/pressure on rheology.
  // TODO (later): Cuttings transport
  // Don’t implement now; just leave the hook to add solids loading (effective density/viscosity, slip velocity) when drilling starts.
  // TODO: Surge & swab transients
  // If you plan to simulate trips, add unsteady terms and moving string effects later.
  const A = area_annulus(Do, Di);
  const Dh = Math.max(Do - Di, 1e-6);
  const V = Q / Math.max(A,1e-12);
  const b = Dh/2;
  const g_ax = 6 * Math.abs(V) / Math.max(b,1e-6);
  const g_rot = rotShearRateAnnulus(rpm, Di, Do);
  const g_eff = Math.sqrt(g_ax*g_ax + (ROT_COUPLE*g_rot)*(ROT_COUPLE*g_rot));
  const g_w = ((2*n+1)/(3*n)) * Math.max(g_eff,1e-6);
  const muAw = mu_app_HB(g_w, K, n, tauY);
  const Re_g = (rho * Math.max(Math.abs(V),1e-12) * Dh) / Math.max(muAw,1e-9);
  if (Re_g < 2100){
    return dpPerM_annulusLaminar_HB(Q, rho, Do, Di, K, n, tauY, rpm);
  }
  const dp_base = (HYDRAULICS_MODEL==="API")
    ? dpPerM_API_withRot(rho, V, Dh, K, n, tauY, g_rot)
    : dpPerM_Refined_withRot(rho, V, Dh, K, n, tauY, g_rot);
  let dp_turb = applyTaylorBoost(dp_base, rpm, Di, Do, muAw, rho, n);
  dp_turb *= roughMultiplier(true);
  dp_turb *= eccMultiplier(Do, Di);
  return dp_turb;
}
function dP_per_m_pipe_withRPM(Q, rho, ID, K, n, tauY, rpm){
  if (Q <= 0) return 0;
  // TODO (industry-grade): Excentricidade do anular (e>0)
  // Apply a vetted correlation (e.g., Kelessidis/Misra) for laminar HB in eccentric annuli. This raises losses in tight gaps and is realistic.
  // TODO: Rugosidade / ε (Dodge–Metzner com rugosidade para não-Newtoniano)
  // Extend your turbulent branch to include roughness effects for non-Newtonian fluids.
  // TODO: BHA/local losses (tool joints, stabilizers, MWD, bit/nozzles)
  // Add K-losses per element and the bit nozzle DP (this can be a separate block summed into SPP).
  // TODO: Correções T/P de reologia (K, n, τy=f(T,P))
  // Simple Arrhenius/empirical maps for temperature/pressure on rheology.
  // TODO (later): Cuttings transport
  // Don’t implement now; just leave the hook to add solids loading (effective density/viscosity, slip velocity) when drilling starts.
  // TODO: Surge & swab transients
  // If you plan to simulate trips, add unsteady terms and moving string effects later.
  const A = Math.PI*Math.max(ID*ID,1e-12)/4;
  const V = Q / A;
  const Dh = Math.max(ID,1e-6);
  const g_ax = 8 * Math.abs(V) / Dh;
  const g_rot = rotShearRatePipe(rpm, ID);
  const g_eff = Math.sqrt(g_ax*g_ax + (ROT_COUPLE*g_rot)*(ROT_COUPLE*g_rot));
  const g_w = ((3*n+1)/(4*n)) * Math.max(g_eff,1e-6);
  const muAw = mu_app_HB(g_w, K, n, tauY);
  const Re_g = (rho * Math.max(Math.abs(V),1e-12) * Dh) / Math.max(muAw,1e-9);
  if (Re_g < 2100){
    return dpPerM_pipeLaminar_HB(Q, rho, ID, K, n, tauY, rpm);
  }
  let dp_turb = (HYDRAULICS_MODEL==="API")
    ? dpPerM_API_withRot(rho, V, Dh, K, n, tauY, g_rot)
    : dpPerM_Refined_withRot(rho, V, Dh, K, n, tauY, g_rot);
  dp_turb *= roughMultiplier(true);
  return dp_turb;
}
function eccMultiplier(Do, Di){
  // baseline: no change
  if (!EH.ECC.on) return 1.0;
  // sensitivity: tighter annulus → stronger effect
  const gap = Math.max(Do - Di, 1e-6);
  const tight = clamp((0.25 - gap)/0.25, 0, 1); // strong when gap <~ 0.25 m
  // map slider s∈[-1,1] to gain 1 ± (gain_max * tight)
  const gmax = EH_TUNE.ecc_max_gain * tight;
  return 1 + EH.ECC.s * gmax;
}
function roughMultiplier(isTurb){
  if (!isTurb || !EH.ROUGH.on) return 1.0;
  // slider s∈[-1,1] → 1 ± rough_max_gain
  return 1 + EH.ROUGH.s * EH_TUNE.rough_max_gain;
}
function localKLossPsi(){
  if (!EH.KLOSS.on) return 0;
  // slider s∈[-1,1] maps to ± kloss_spp_base psi
  return EH_TUNE.kloss_spp_base * EH.KLOSS.s;
}
// reference velocity at Q_REF in the riser annulus
function A_riser() { return area_annulus(riser_ID_m, ds_OD_m); }
const V_REF = () => (Q_REF/15850.323) / Math.max(A_riser(), 1e-12);
// (optional) keep the sim snappy while preserving ratios
const TIME_ACCEL = 1.0; // try 2–4 later if you want it faster
// ========================== SEGMENTED ADVECTION ==========================
function stepAdvection(){
  const { qDS, qBO, qAnnBelow, qAnnAbove } = flows_m3s();
  // ----- areas -----
  const A_ds = Math.PI*Math.max(ds_ID_m*ds_ID_m,1e-12)/4; // pipe ID
  const A_bo = Math.PI*Math.max(booster_ID_m*booster_ID_m,1e-12)/4; // booster ID
  const A_above = area_annulus(riser_ID_m, ds_OD_m); // riser annulus
  // effective annulus area below BOP (length-weighted)
  const L_csg = Math.max(SHOE_DEPTH - BOP_DEPTH, 0);
  const L_oh = Math.max(TD_DEPTH - SHOE_DEPTH, 0);
  const A_csg = area_annulus(casing_ID_m, ds_OD_m);
  const A_oh = area_annulus(openhole_ODm, ds_OD_m);
  const A_below = (L_csg*A_csg + L_oh*A_oh) / Math.max(L_csg + L_oh, 1e-12);
  // ----- velocities -----
  const v_ds = qDS / Math.max(A_ds, 1e-12);
  const v_bo = qBO / Math.max(A_bo, 1e-12);
  const v_below = qAnnBelow / Math.max(A_below, 1e-12);
  const v_above = qAnnAbove / Math.max(A_above, 1e-12);
  // ----- advance per frame (m) — consistent “fast clock” via V_REF -----
  const vref = V_REF();
  const dsStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_ds / vref);
  const boStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_bo / vref);
  const belowStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_below / vref);
  const aboveStep_m = TIME_ACCEL * BASE_M_PER_FRAME * (v_above / vref);
  // ----- the rest of your function stays the same, but uses those steps -----
  accDS += dsStep_m;
  while (accDS >= CELL_M){
    const bitMW = dsGrid.pop();
    dsGrid.unshift(MW_DS);
    accDS -= CELL_M;
  }
  const dsEffluentMW = dsGrid.length ? dsGrid[dsGrid.length-1] : MW_DS;
  accBo += boStep_m;
  while (accBo >= CELL_M){
    boosterGrid.pop();
    boosterGrid.unshift(MW_BO);
    accBo -= CELL_M;
  }
  const boosterAtBOP_MW = boosterGrid.length ? boosterGrid[boosterGrid.length-1] : MW_BO;
  accBelow += belowStep_m;
  while (accBelow >= CELL_M){
    annBelowGrid.shift();
    annBelowGrid.push(dsEffluentMW);
    accBelow -= CELL_M;
  }
  if (annBelowGrid.length){
    const k = annBelowGrid.length - 1;
    annBelowGrid[k] = (1 - accBelow/CELL_M) * annBelowGrid[k] + (accBelow/CELL_M) * dsEffluentMW;
  }
  accAbove += aboveStep_m;
  while (accAbove >= CELL_M){
    annAboveGrid.shift();
    const qMixTot = Math.max(qDS + qBO, 1e-12);
    const mixMW = (qDS * (annBelowGrid.length ? annBelowGrid[0] : dsEffluentMW)
                   + qBO * boosterAtBOP_MW) / qMixTot;
    annAboveGrid.push(mixMW);
    accAbove -= CELL_M;
  }
  if (annAboveGrid.length){
    const qMixTot = Math.max(qDS + qBO, 1e-12);
    const fromBelowAtBOP_MW = (annBelowGrid.length ? annBelowGrid[0] : dsEffluentMW);
    const mixMW = (qDS * fromBelowAtBOP_MW + qBO * boosterAtBOP_MW) / qMixTot;
    const k = annAboveGrid.length - 1;
    annAboveGrid[k] = (1 - accAbove/CELL_M) * annAboveGrid[k] + (accAbove/CELL_M) * mixMW;
  }
  // ----------- CML pipe (upwards: pump depth → surface) -----------
  if (CML_ON){
    // Convert gpm → m³/s
    const qCML = (Q_CML || 0) / 15850.323; // m³/s
    const cmlStep_m = BASE_M_PER_FRAME * (qCML / (Q_REF/15850.323));
    accCML += cmlStep_m;
    // Source composition at the pump pickup depth (annulus above-BOP leg)
    const iPump = clamp(Math.floor(CML_DEPTH / CELL_M), 0, N_ABV-1);
    const srcMW = annAboveGrid[iPump] ?? annAboveGrid[annAboveGrid.length-1] ?? MW_DS;
    while (accCML >= CELL_M){
      // flow goes UP: newest slug appears near surface end of the grid
      cmlPipeGrid.shift();
      cmlPipeGrid.push(srcMW);
      accCML -= CELL_M;
    }
    // fractional mix of tail cell towards srcMW
    if (cmlPipeGrid.length){
      const frac = clamp(accCML / CELL_M, 0, 1);
      const k = cmlPipeGrid.length - 1;
      cmlPipeGrid[k] = (1 - frac) * cmlPipeGrid[k] + frac * srcMW;
    }
  }
}
// ========================= DENSITY / FLOWS =============================
function annulusAvgPPG(){ return average(annAboveGrid.concat(annBelowGrid)); }
function rhoDynamic(){ return annulusAvgPPG() * PPG_TO_KGM3; }
function rho_bo(){ return boosterAvgPPG() * PPG_TO_KGM3; }
function dsAvgPPG(){ return average(dsGrid) || MW_DS; }
function boosterAvgPPG(){ return average(boosterGrid) || MW_BO; }
function flows_m3s(){
  const qDS_m3s = (Q_DS || 0) / 15850.323; // gpm → m³/s
  const qBO_m3s = (Q_BO || 0) / 15850.323;
  return { qDS: qDS_m3s, qBO: qBO_m3s, qAnnBelow: qDS_m3s, qAnnAbove: qDS_m3s + qBO_m3s };
}
// ======================= SECTION-SPECIFIC dP/dL ========================
function dPperM_riserAnnulus(Q) {
  const base = getRheoForCalc();
  const z0 = 0, z1 = BOP_DEPTH, dz = 200;
  let dP_total = 0;
  for (let z = z0; z < z1; z += dz) {
    const rho0 = rhoDynamic();
    const adj = applyPressureOnly(z, rho0, base.K, base.n, base.tauY);
    const dpdl = dP_per_m_annulus_withRPM(Q, adj.rho, riser_ID_m, ds_OD_m, adj.K, adj.n, adj.tauY, RPM);
    dP_total += dpdl * Math.min(dz, z1 - z);
  }
  return dP_total / (z1 - z0);
}
function dPperM_casingAnnulus(Q) {
  const base = getRheoForCalc();
  const z0 = BOP_DEPTH, z1 = SHOE_DEPTH, dz = 200;
  let dP_total = 0;
  for (let z = z0; z < z1; z += dz) {
    const rho0 = rhoDynamic();
    const adj = applyPressureOnly(z, rho0, base.K, base.n, base.tauY);
    const dpdl = dP_per_m_annulus_withRPM(Q, adj.rho, casing_ID_m, ds_OD_m, adj.K, adj.n, adj.tauY, RPM);
    dP_total += dpdl * Math.min(dz, z1 - z);
  }
  return dP_total / (z1 - z0);
}
function dPperM_openholeAnnulus(Q) {
  const base = getRheoForCalc();
  const z0 = SHOE_DEPTH, z1 = TD_DEPTH, dz = 200;
  let dP_total = 0;
  for (let z = z0; z < z1; z += dz) {
    const rho0 = rhoDynamic();
    const adj = applyPressureOnly(z, rho0, base.K, base.n, base.tauY);
    const dpdl = dP_per_m_annulus_withRPM(Q, adj.rho, openhole_ODm, ds_OD_m, adj.K, adj.n, adj.tauY, RPM);
    dP_total += dpdl * Math.min(dz, z1 - z);
  }
  return dP_total / (z1 - z0);
}
function dPperM_drillstring(Q) {
  const base = getRheoForCalc();
  const z0 = 0, z1 = TD_DEPTH, dz = 200;
  let dP_total = 0;
  for (let z = z0; z < z1; z += dz) {
    const rho0 = dsAvgPPG() * PPG_TO_KGM3;
    const adj = applyPressureOnly(z, rho0, base.K, base.n, base.tauY);
    const dpdl = dP_per_m_pipe_withRPM(Q, adj.rho, ds_ID_m, adj.K, adj.n, adj.tauY, RPM);
    dP_total += dpdl * Math.min(dz, z1 - z);
  }
  return dP_total / (z1 - z0);
}
function dPperM_booster(Q) {
  const base = getRheoForCalc();
  const z0 = 0, z1 = BOP_DEPTH, dz = 200;
  let dP_total = 0;
  for (let z = z0; z < z1; z += dz) {
    const rho0 = rho_bo();
    const adj = applyPressureOnly(z, rho0, base.K, base.n, base.tauY);
    const dpdl = dP_per_m_pipe_withRPM(Q, adj.rho, booster_ID_m, adj.K, adj.n, adj.tauY, 0);
    dP_total += dpdl * Math.min(dz, z1 - z);
  }
  return dP_total / (z1 - z0);
}
// =========================== FRICTION SUMS =============================
const PSI_PER_PASCAL = 1/6894.757;
function frictionPsiAtDepth(depth_m){
  return frictionPsi_withCML(depth_m);
}
function frictionPsi_withCML(depth_m){
  const { qAnnBelow, qAnnAbove } = flows_m3s();
  const top = riserTopDepth();
  let sumPa = 0;
  // Only the wet portion of riser contributes: [top, BOP_DEPTH]
  const addSeg = (z0, z1, dPperM) => {
    if (depth_m > z0){
      const span = Math.min(Math.max(depth_m - z0, 0), z1 - z0);
      sumPa += dPperM * Math.max(span, 0);
    }
  };
  // Riser (surface→BOP) – start at 'top'
  if (depth_m > top){
    const z0 = Math.max(top, 0), z1 = Math.min(BOP_DEPTH, depth_m);
    if (z1 > z0){
      const dp = dPperM_riserAnnulus(qAnnAbove);
      sumPa += dp * (z1 - z0);
    }
  }
  // Below BOP unchanged
  addSeg(BOP_DEPTH, SHOE_DEPTH, dPperM_casingAnnulus(qAnnBelow));
  addSeg(SHOE_DEPTH, TD_DEPTH, dPperM_openholeAnnulus(qAnnBelow));
  return sumPa * PSI_PER_PASCAL;
}
function frictionPsi(depth_m){
  if (FRICTION_MODE === "hydraulics") return frictionPsiAtDepth(depth_m);
  const qTot = (Q_DS||0) + (Q_BO||0);
  const base = K_FAC * qTot * Math.max(depth_m, 0);
  return base; // no RPM boost here
}
// ====================== PRESSURE / ECD PROFILES =======================
function ecdAtDepth(d){
  const i = Math.floor(d / CELL_M);
  if (d <= BOP_DEPTH){
    return average(annAboveGrid.slice(0, i + 1));
  } else {
    const iAbv = N_ABV - 1;
    const iBlw = Math.floor((d - BOP_DEPTH) / CELL_M);
    const sumAbv = sumCells(annAboveGrid, 0, iAbv);
    const sumBlw = sumCells(annBelowGrid, 0, iBlw);
    const n = iAbv + 1 + iBlw + 1;
    return (sumAbv + sumBlw) / Math.max(n,1);
  }
}
function ecdWithSBPAtDepth(d){
  // If d is at surface (avoid divide by zero), mirror a shallow depth
  const depth = Math.max(1, d);
  const P = pressureAtDepth(depth); // already includes CML, SBP, friction, wetted top
  return P / (PSI_COEF * depth); // convert back to ppg-equivalent
}
function pressureAtDepth_noSBP(d){
  const P_hyd = PSI_COEF * ecdAtDepth(d) * d;
  const P_fric = frictionPsi(d);
  return P_hyd + P_fric;
}
function pressureAtDepth_noSBP_withCML(d){
  const top = riserTopDepth(); // 0 if full
  const baseECD = ecdAtDepth(d); // composition-based ECD
  // effective vertical fluid column from surface to depth 'd'
  let effDepth = 0;
  if (d <= BOP_DEPTH){
    effDepth = Math.max(d - top, 0);
  } else {
    effDepth = Math.max(BOP_DEPTH - top, 0) + (d - BOP_DEPTH);
  }
  const P_hyd = PSI_COEF * baseECD * effDepth;
  const P_fric = frictionPsi_withCML(d); // new version below
  return P_hyd + P_fric;
}
function pressureAtDepth(d){ return pressureAtDepth_noSBP_withCML(d) + (CURRENT_SBP || 0); }
// ================== SPP + LEVEL (smooth low-flow ramp) =================
function dsFrictionPsiLength(len_m){
  const { qDS } = flows_m3s();
  const pa_per_m = dPperM_drillstring(qDS);
  return (pa_per_m * Math.max(len_m, 0)) * PSI_PER_PASCAL;
}
function boosterFrictionPsiLength(len_m){
  const { qBO } = flows_m3s();
  const pa_per_m = dPperM_booster(qBO);
  return (pa_per_m * Math.max(len_m, 0)) * PSI_PER_PASCAL;
}
function sppAtLevel(lvl_m){
  const lvl = clamp(lvl_m, 0, TD_DEPTH);
  const filledLen = TD_DEPTH - lvl;
  const dsFricPsi = dsFrictionPsiLength(filledLen);
  const annFricPsi = frictionPsi(TD_DEPTH);
  const sbpPsi = (CURRENT_SBP || 0);
  const MWann = annulusAvgPPG();
  const MWds = dsAvgPPG();
  const hydroPsi = PSI_COEF * ( MWann * TD_DEPTH - MWds * filledLen );
  return dsFricPsi + annFricPsi + sbpPsi + hydroPsi;
}
function boSppAtLevel(lvl_m){
  const lvl = clamp(lvl_m, 0, BOP_DEPTH);
  const filledLen = BOP_DEPTH - lvl;
  const boFricPsi = boosterFrictionPsiLength(filledLen);
  const annFricAbovePsi = frictionPsi(BOP_DEPTH);
  const sbpPsi = (CURRENT_SBP || 0);
  const MWannAbv = average(annAboveGrid);
  const MWbo = boosterAvgPPG();
  const hydroPsi = PSI_COEF * ( MWannAbv * BOP_DEPTH - MWbo * filledLen );
  return boFricPsi + annFricAbovePsi + sbpPsi + hydroPsi;
}
function surfacePumpPressure(){
  // updates levelDeficit_m as side-effect
  let f0 = sppAtLevel(levelDeficit_m);
  // Not enough head → level drops (gauge stays ≈0 while dropping)
  if (f0 < 0){
    const f1 = sppAtLevel(Math.min(levelDeficit_m + 1, TD_DEPTH));
    const slope = Math.max(f1 - f0, 1e-6);
    const delta = Math.min((-f0)/slope, TD_DEPTH - levelDeficit_m);
    levelDeficit_m += delta;
    return 0;
  }
  // Have positive head; refill first
  if (levelDeficit_m > 0){
    const MWds = Math.max(dsAvgPPG(), 0.1);
    const psiPerM = PSI_COEF * MWds;
    const rise_m = Math.min(f0 / psiPerM, levelDeficit_m);
    levelDeficit_m = Math.max(levelDeficit_m - rise_m, 0);
    return f0 - rise_m * psiPerM;
  }
  return f0 + localKLossPsi();
}
function boosterPumpPressure(){
  // updates levelDeficit_bo_m
  let f0 = boSppAtLevel(levelDeficit_bo_m);
  if (f0 < 0){
    const f1 = boSppAtLevel(Math.min(levelDeficit_bo_m + 1, BOP_DEPTH));
    const slope = Math.max(f1 - f0, 1e-6);
    const delta = Math.min((-f0)/slope, BOP_DEPTH - levelDeficit_bo_m);
    levelDeficit_bo_m += delta;
    return 0;
  }
  if (levelDeficit_bo_m > 0){
    const MWbo = Math.max(boosterAvgPPG(), 0.1);
    const psiPerM = PSI_COEF * MWbo;
    const rise_m = Math.min(f0 / psiPerM, levelDeficit_bo_m);
    levelDeficit_bo_m = Math.max(levelDeficit_bo_m - rise_m, 0);
    return f0 - rise_m * psiPerM;
  }
  return f0 + localKLossPsi();
}

// ================== CML level update + simple controller ==================
function updateCMLLevelAndControl(){
  // 1) Clamp the pump pickup depth and compute the wet riser area
  CML_DEPTH = clamp(CML_DEPTH || 0, 0, BOP_DEPTH);
  const A_ris = Math.max(area_annulus(riser_ID_m, ds_OD_m), 1e-12);

  // 2) Auto mode: compute a flow command from anchor pressure error (if set)
  //    Q_CML is limited to total available annulus flow (DS+Booster)
  const { qDS, qBO } = flows_m3s();
  CML_Q_MAX = Math.max(0, (Q_DS + Q_BO)); // gpm limit for the UI
  const qMax_m3s = Math.max(qDS + qBO, 0); // physical ceiling

  if (AUTO_CML_ON && CML_AP_DEPTH > 0 && CML_AP_ECD > 0){
    // Target and actual pressures at the anchor depth (psi)
    const P_set = PSI_COEF * CML_AP_ECD * CML_AP_DEPTH;
    const P_act = pressureAtDepth_noSBP_withCML(CML_AP_DEPTH);
    const Perr = P_set - P_act; // psi we want to add (if positive) or remove

    // Convert psi error to a flow using the riser leg "resistance"
    // R ≈ ΔP / Q  (psi per m³/s), evaluated around a small reference flow
    const R_psi_per_m3s = riserLegResistancePsiPer_m3s(riserTopDepth(), CML_DEPTH);
    let q_cmd = 0;
    if (isFinite(R_psi_per_m3s) && R_psi_per_m3s > 1){
      q_cmd = clamp(Perr / R_psi_per_m3s, -qMax_m3s, qMax_m3s); // m³/s
    }
    // Map to gpm and clamp (only allow *outflow* here; negative means refill → 0)
    Q_CML = clamp(Math.max(0, q_cmd * 15850.323), 0, CML_Q_MAX);
    cmlQSlider?.value(Q_CML); cmlQInput?.value(nf(Q_CML,1,0));
  } else {
    // Manual mode: just ensure it’s within bounds
    Q_CML = clamp(Q_CML || 0, 0, CML_Q_MAX);
  }

  // 3) Evolve the wet top (CML_TOP_DEPTH) from the volumetric balance.
  //    dH = (Q_out / Area) * dt, with dt consistent with your advection "fast clock".
  const q_out = (Q_CML || 0) / 15850.323; // gpm → m³/s
  const v_ref = V_REF(); // m/s in riser annulus at Q_REF
  const dt = TIME_ACCEL * (BASE_M_PER_FRAME / Math.max(v_ref, 1e-9)); // s per frame
  const dH = (q_out / A_ris) * dt; // meters the wet top drops (depth increases)

  // 4) Update and clamp the riser wet top depth
  CML_TOP_DEPTH = clamp((CML_TOP_DEPTH || 0) + dH, 0, BOP_DEPTH);
}

// ========================== CAPTURE / OVERLAYS =========================
function captureState(){
  const step = 25;
  const n = Math.floor(MAX_DEPTH / step) + 1;
  capturedP = Array.from({ length: n }, (_, i) => pressureAtDepth(i * step));
  capturedECD = Array.from({ length: n }, (_, i) => ecdWithSBPAtDepth(i * step));
}
window.captureState = captureState; // allow console trigger
// ============================== UI HELPERS =============================
function mkLabel(txt, x, y){ createDiv(txt).position(x,y).style("color","#EEE").style("font-size","12px"); }
// ================================ SETUP ================================
function setup(){
  createCanvas(W, H);
  colorMode(HSB, 360, 100, 100, 255);
  textFont('Arial');
  textAlign(CENTER,CENTER);
  frameRate(30);
    // Bottom frame geometry (matches your screenshot proportions)
  const padding = 50;
  frameWidth = (W - 2 * padding) / 3 - 20;
  frameHeight = 300;
  frameY = well.y + well.h + 100;
  rheoFrameX = padding;
  rheoFrameW = frameWidth + 100; // +100 to fit buttons
  gelFrameX = rheoFrameX + rheoFrameW + 20;
  gelFrameW = frameWidth - 350;
  geomFrameX = gelFrameX + gelFrameW + 20;
  geomFrameW = frameWidth-400;
  // --- New EH frame under the existing three ---
  ehFrameW = geomFrameW + 420
  ehFrameX = gelFrameX + gelFrameW + gelFrameW -10;
 // In setup(), replace the ehFrameH assignment
ehFrameH = 300; // Increased to fit 4 features with 100px each + padding
  ehFrameY = frameY ;
  // Convert inches to meters
  riser_ID_m = riser_ID_in * 0.0254;
  casing_ID_m = casing_ID_in * 0.0254;
  openhole_ODm = openhole_OD_in * 0.0254;
  ds_OD_m = ds_OD_in * 0.0254;
  ds_ID_m = ds_ID_in * 0.0254;
  booster_ID_m = booster_ID_in * 0.0254;
 
   // ✅ Build bottom UIs now (p5 DOM is ready and positions exist)
  buildRheologyUI(rheoFrameX + 20, frameY + 20);
  buildEnhancedHydraulicsUI(ehFrameX + 14, ehFrameY + 14);
  // ✅ Now it’s safe to fit (inputs exist)
  doRheologyFit();
 
 
  // -------- Top-row controls (spaced like screenshot) --------
// Vertical rows
const yRow1 = 24; // buttons + AP inputs
const yRow2 = 64; // sliders
// Horizontal layout helpers
const X0 = 16; // left margin
const COL = (i, w=200, gap=40) => X0 + i * (w + gap);
// ---------- ROW 2: SLIDERS ----------
let x = 0;
// DS MW
mkLabel("DS MW (ppg)", COL(x), yRow2-18);
dsMWSlider = createSlider(MW_MIN, MW_MAX, MW_DS, MW_STEP).position(COL(x), yRow2).style('width','180px');
dsMWInput = createInput(nf(MW_DS,1,1), 'number').position(COL(x)+190, yRow2).size(60).attribute('step', MW_STEP);
x++;
// DS Flow
mkLabel("DS Flow (gpm)", COL(x), yRow2-18);
dsQSlider = createSlider(Q_MIN, Q_MAX, Q_DS, Q_STEP).position(COL(x), yRow2).style('width','180px');
dsQInput = createInput(nf(Q_DS,1,0), 'number').position(COL(x)+190, yRow2).size(60).attribute('step', Q_STEP);
x++;
// Booster MW
mkLabel("Booster MW (ppg)", COL(x), yRow2-18);
boMWSlider = createSlider(MW_MIN, MW_MAX, MW_BO, MW_STEP).position(COL(x), yRow2).style('width','180px');
boMWInput = createInput(nf(MW_BO,1,1), 'number').position(COL(x)+190, yRow2).size(60).attribute('step', MW_STEP);
x++;
// Booster Flow
mkLabel("Booster Flow (gpm)", COL(x), yRow2-18);
boQSlider = createSlider(Q_MIN, Q_MAX, Q_BO, Q_STEP).position(COL(x), yRow2).style('width','180px');
boQInput = createInput(nf(Q_BO,1,0), 'number').position(COL(x)+190, yRow2).size(60).attribute('step', Q_STEP);
x++;
// Friction k
mkLabel("Friction k (psi/m per flow)", COL(x), yRow2-18);
kSlider = createSlider(0.0, 0.0002, K_FAC, 0.000005).position(COL(x), yRow2).style('width','180px');
kInput = createInput(nf(K_FAC,1,6),'number').position(COL(x)+190, yRow2).size(90);
x++;
// SBP
mkLabel("SBP (psi)", COL(x), yRow2-18);
sbpSlider = createSlider(0, 3000, SBP_MANUAL, 10).position(COL(x), yRow2).style('width','180px');
sbpInput = createInput(nf(SBP_MANUAL,1,0),'number').position(COL(x)+190, yRow2).size(70).attribute('min','0');
x++;
// RPM
mkLabel("RPM", COL(x), yRow2-18);
rpmSlider = createSlider(0, 220, RPM, 5).position(COL(x), yRow2).style('width','180px');
rpmInput = createInput(String(RPM),'number').position(COL(x)+190, yRow2).size(70).attribute('min','0').attribute('max','220').attribute('step','1');
x++;
// *** NEW: CML Flow slider ***
mkLabel("CML Flow (gpm)", COL(x), yRow2-18);
cmlQSlider = createSlider(Q_MIN, Q_MAX, Q_CML, Q_STEP).position(COL(x), yRow2).style('width','180px');
cmlQInput = createInput(nf(Q_CML || 0, 1, 0), 'number')
  .position(COL(x)+190, yRow2).size(70).attribute('step','10').attribute('min','0');
x++;
// CML Pump Depth (textbox to keep precise control)
mkLabel("CML Pump Depth (m)", COL(x), yRow2-18);
cmlDepthInput = createInput(nf(CML_DEPTH || 0, 1, 0), 'number')
  .position(COL(x), yRow2).size(100)
  .attribute('step','1').attribute('min','0').attribute('max', String(BOP_DEPTH));
// ---------- ROW 1: BUTTONS + AP inputs (Anchor Point) ----------
// Anchor Point (Depth / ECD) – left side of the button strip
mkLabel("AP Depth (m)", COL(0), yRow1-18);
apDepthInput = createInput('', 'number').position(COL(0), yRow1).size(120)
  .attribute('placeholder','AP depth m').attribute('step','0.01');
mkLabel("AP ECD (ppg)", COL(1)-40, yRow1-18);
apEcdInput = createInput('', 'number').position(COL(1)-40, yRow1).size(120)
  .attribute('placeholder','AP ECD ppg').attribute('step','0.01');
// CML ON/OFF
cmlBtn = createButton(CML_ON ? 'CML: ON' : 'CML: OFF').size(120, 26)
  .position(COL(2), yRow1-6)
  .style('background', '#ffe74a').style('font-weight', 'bold')
  .mousePressed(() => {
    CML_ON = !CML_ON;
    if (!CML_ON) { CML_TOP_DEPTH = 0; } // riser full when off
    cmlBtn.html(CML_ON ? 'CML: ON' : 'CML: OFF');
  });
// Auto CML ON/OFF
cmlAutoBtn = createButton(AUTO_CML_ON ? 'Auto CML: ON' : 'Auto CML: OFF').size(140, 26)
  .position(COL(3), yRow1-6)
  .style('background', '#ffe74a').style('font-weight', 'bold')
  .mousePressed(() => {
    AUTO_CML_ON = !AUTO_CML_ON;
    cmlAutoBtn.html(AUTO_CML_ON ? 'Auto CML: ON' : 'Auto CML: OFF');
  });
// SBP Mode
sbpModeBtn = createButton('SBP Mode: ' + (SBP_MODE==='manual'?'Manual':'Anchor')).size(140, 26)
  .position(COL(4), yRow1-6)
  .mousePressed(() => {
    SBP_MODE = (SBP_MODE === 'manual') ? 'anchor' : 'manual';
    sbpModeBtn.html(SBP_MODE === 'manual' ? 'SBP Mode: Manual' : 'SBP Mode: Anchor');
  });
// MPD ON/OFF
mpdBtn = createButton(MPD_ON ? 'MPD: ON' : 'MPD: OFF').size(90, 26)
  .position(COL(5), yRow1-6)
  .mousePressed(() => { MPD_ON = !MPD_ON; mpdBtn.html(MPD_ON ? 'MPD: ON' : 'MPD: OFF'); });
// Capture & Display buttons
captureBtn = createButton('Capture State').size(110, 26)
  .position(COL(6), yRow1-6)
  .mousePressed(captureState);
displayBtn = createButton(showCaptured ? 'Display State: ON' : 'Display State: OFF')
  .size(160, 26).position(COL(7), yRow1-6)
  .mousePressed(() => { showCaptured = !showCaptured; displayBtn.html(showCaptured ? 'Display State: ON' : 'Display State: OFF'); });
// ---------- Value bindings ----------
dsMWSlider.input(() => setDSMW(dsMWSlider.value()));
dsMWInput.input(() => setDSMW(num(dsMWInput.value())));
dsQSlider.input(() => setDSQ(dsQSlider.value()));
dsQInput.input(() => setDSQ(num(dsQInput.value())));
boMWSlider.input(() => setBOMW(boMWSlider.value()));
boMWInput.input(() => setBOMW(num(boMWInput.value())));
boQSlider.input(() => setBOQ(boQSlider.value()));
boQInput.input(() => setBOQ(num(boQInput.value())));
kSlider.input(() => setK(kSlider.value()));
kInput.input(() => setK(num(kInput.value())));
sbpSlider.input(() => { SBP_MANUAL = Number(sbpSlider.value()); sbpInput.value(nf(SBP_MANUAL,1,0)); });
sbpInput.input(() => { SBP_MANUAL = Math.max(0, Number(sbpInput.value())||0); sbpSlider.value(SBP_MANUAL); });
rpmSlider.input(() => setRPM(rpmSlider.value()));
rpmInput.input(() => setRPM(Number(rpmInput.value())||0));
apDepthInput.input(() => { ANCHOR_DEPTH = Math.max(0, num(apDepthInput.value())); });
apEcdInput.input(() => { ANCHOR_ECD = Math.max(0, num(apEcdInput.value())); });
// CML widgets bindings
cmlQSlider.input(() => { if (!AUTO_CML_ON){ Q_CML = cmlQSlider.value(); cmlQInput.value(nf(Q_CML,1,0)); }});
cmlQInput.input(() => { if (!AUTO_CML_ON){ Q_CML = clamp(num(cmlQInput.value()), Q_MIN, Q_MAX); cmlQSlider.value(Q_CML); }});
cmlDepthInput.input(() => { CML_DEPTH = clamp(num(cmlDepthInput.value()), 0, BOP_DEPTH); });
  // Initial rheology fit
  doRheologyFit();
}
// ================================ DRAW =================================
function draw(){
  background(0,0,12);
  // Panels background bands
  noStroke();
  fill(210, 80, 30);
  rect(0, 0, width, 120);
  fill(30, 60, 20);
  rect(0, 120, width, 520);
  fill(0, 0, 20);
  rect(0, 640, width, height-640);
  // Background bands
  noStroke();
  fill(210, 80, 30);
  rect(0, 0, width, 120);
  fill(30, 60, 20);
  rect(0, 120, width, 520);
  fill(0, 0, 20);
  rect(0, 640, width, height-640);
  // ...SBP logic + well + charts...
  // Bottom frames (visual only; your UI inputs sit on top of these)
  drawBottomFrames();
  drawEnhancedHydraulicsFrame();
  // SBP logic
  if (MPD_ON){
    if (SBP_MODE === "manual"){
      CURRENT_SBP = Math.max(0, SBP_MANUAL);
    } else {
      if (ANCHOR_DEPTH > 0 && ANCHOR_ECD > 0){
        const p_set = PSI_COEF * ANCHOR_ECD * ANCHOR_DEPTH;
        const p_actual = pressureAtDepth_noSBP(ANCHOR_DEPTH);
        CURRENT_SBP = Math.max(0, p_set - p_actual);
      } else {
        CURRENT_SBP = 0;
      }
    }
  } else {
    CURRENT_SBP = 0;
  }
  // Update CML level and (if enabled) Auto-CML flow command BEFORE pressures are used
  updateCMLLevelAndControl();
  // Well visuals and charts
  drawWellAndFluids();
  drawDepthGrid();
  drawReferenceBadges();
  drawGaugesAndCharts();
  // Time series logging
  tsFrame++;
  if (tsFrame % TS_STRIDE === 0){
    tsSBP.push(CURRENT_SBP); if (tsSBP.length > TS_MAX) tsSBP.shift();
    tsFlow.push(Q_DS + Q_BO); if (tsFlow.length > TS_MAX) tsFlow.shift();
    tsPactual.push(pressureAtDepth(100)); if (tsPactual.length > TS_MAX) tsPactual.shift();
    tsSPP.push(lastSPP); if (tsSPP.length > TS_MAX) tsSPP.shift();
    const setp = (ANCHOR_DEPTH > 0 && ANCHOR_ECD > 0) ? (PSI_COEF * ANCHOR_ECD * ANCHOR_DEPTH) : NaN;
    tsPset.push(setp); if (tsPset.length > TS_MAX) tsPset.shift();
  }
  // Advection last (after SPP/levels reflect current step)
  stepAdvection();
  // Footer labels
  fill(0,0,95); textSize(12);
  text("Rheology/Hydraulics controls at bottom-left; SBP/MPD top-right.", width/2, height-16);
}
// ============================== DRAW HELPERS ===========================
function drawWellAndFluids(){
  const px = well.x + (well.w - dp.w) / 2;
  stroke(0, 0, 95); strokeWeight(2.5); noFill(); rect(well.x, well.y, well.w, well.h, 8);
  stroke(0, 0, 80); strokeWeight(5);
  line(px, well.y, px, well.y + well.h);
  line(px + dp.w, well.y, px + dp.w, well.y + well.h);
  noStroke();
  const yBOP = mapDepthToY(BOP_DEPTH);
  const boosterW = 12, boosterX = well.x - 14;
  stroke(0, 0, 50, 160); strokeWeight(1.5); noFill(); rect(boosterX - boosterW/2, well.y, boosterW, yBOP - well.y, 3);
  const yTopWetBo = clipFillY_forBooster(); // NEW
  const lvl_bo_m = clamp(levelDeficit_bo_m, 0, BOP_DEPTH);
  for (let i = 0; i < N_ABV; i++) {
    const dTop_m = i * CELL_M;
    const dBot_m = Math.min((i + 1) * CELL_M, BOP_DEPTH);
    if (dBot_m <= lvl_bo_m) continue;
    const yTop = mapDepthToY(Math.max(dTop_m, lvl_bo_m));
    const yBot = mapDepthToY(dBot_m);
    const hue = remap(boosterGrid[i], MW_MIN, MW_MAX, 170, 355);
    noStroke(); fill(hue, 70, 70, 210);
    rect(boosterX - boosterW/2 + 1, Math.max(yTop, yTopWetBo), boosterW - 2, yBot - Math.max(yTop, yTopWetBo));
  }
  if (levelDeficit_bo_m > 0.01) {
    const levelY_bo = mapDepthToY(Math.min(levelDeficit_bo_m, BOP_DEPTH));
    noStroke(); fill(0, 0, 0, 80); rect(boosterX - boosterW/2 + 1, well.y, boosterW - 2, levelY_bo - well.y);
    stroke(55, 80, 90); strokeWeight(2); line(boosterX - boosterW/2 + 3, levelY_bo, boosterX + boosterW/2 - 3, levelY_bo);
    noStroke(); fill(0, 0, 95); textAlign(RIGHT, CENTER); textSize(11);
    text(`Bo level ↓ ${nf(levelDeficit_bo_m,1,1)} m`, boosterX - boosterW/2 , levelY_bo);
    textAlign(CENTER, CENTER);
  }
  noStroke(); fill(0,0,80); triangle(boosterX + 1, yBOP - 16, boosterX + 1, yBOP - 4, boosterX + 12, yBOP - 10);
  push(); translate(boosterX - boosterW/2 - 10, (well.y + yBOP) / 2); rotate(-HALF_PI); fill(0, 0, 80); textSize(11); textAlign(CENTER, CENTER); text("Booster Line", 0, 0); pop();
  const xLeftAnn = well.x + 1;
  const xRightAnn = px + dp.w + 1;
  const wLeftAnn = Math.max(0, px - xLeftAnn - 1);
  const wRightAnn = Math.max(0, (well.x + well.w - 1) - xRightAnn);
  const lvl_m = clamp(levelDeficit_m, 0, TD_DEPTH);
  const yTopWetDS = clipFillY_forDS(); // NEW
  for (let i = 0; i < N_DS; i++) {
    const dTop_m = i * CELL_M;
    const dBot_m = Math.min((i + 1) * CELL_M, TD_DEPTH);
    if (dBot_m <= lvl_m) continue;
    const yTop = mapDepthToY(Math.max(dTop_m, lvl_m));
    const yBot = mapDepthToY(dBot_m);
    const hue = remap(dsGrid[i], MW_MIN, MW_MAX, 170, 355);
    fill(hue, 70, 70, 220); rect(px + 1, Math.max(yTop, yTopWetDS), dp.w - 2, yBot - Math.max(yTop, yTopWetDS));
  }
  const yTopWetRis = clipFillY_forRiser(); // NEW
  for (let i = 0; i < N_ABV; i++) {
    const yTop = mapDepthToY(i * CELL_M);
    const yBot = mapDepthToY(Math.min((i + 1) * CELL_M, BOP_DEPTH));
    const hue = remap(annAboveGrid[i], MW_MIN, MW_MAX, 170, 355);
    fill(hue, 70, 70, 190);
    const clippedTop = Math.max(yTop, yTopWetRis);
    if (wLeftAnn > 0) rect(xLeftAnn, clippedTop, wLeftAnn, yBot - clippedTop);
    if (wRightAnn > 0) rect(xRightAnn, clippedTop, wRightAnn, yBot - clippedTop);
  }
 
// --- NEW: draw dry overlay + interface line for CML riser top ---
 if (CML_ON && CML_TOP_DEPTH > 0.01) {
  const levelY_ris = mapDepthToY(Math.min(CML_TOP_DEPTH, BOP_DEPTH));
   // black “dry” overlay above the wet top
   noStroke(); fill(0, 0, 0, 80);
  if (wLeftAnn > 0) rect(xLeftAnn, well.y, wLeftAnn, levelY_ris - well.y);
   if (wRightAnn > 0) rect(xRightAnn, well.y, wRightAnn, levelY_ris - well.y);
   // interface line
  stroke(55, 80, 90); strokeWeight(2);
   if (wLeftAnn > 0) line(xLeftAnn + 3, levelY_ris, xLeftAnn + wLeftAnn - 3, levelY_ris);
  if (wRightAnn > 0) line(xRightAnn + 3, levelY_ris, xRightAnn + wRightAnn - 3, levelY_ris);
   // label
   noStroke(); fill(0, 0, 95); textAlign(LEFT, CENTER); textSize(11);
   text(`Riser top ↑ ${nf(CML_TOP_DEPTH,1,1)} m`, xRightAnn + 6, levelY_ris);
  textAlign(CENTER, CENTER);
 }
 
 
 
  for (let i = 0; i < N_BELOW; i++) {
    const yTop = mapDepthToY(BOP_DEPTH + i * CELL_M);
    const yBot = mapDepthToY(Math.min(BOP_DEPTH + (i + 1) * CELL_M, TD_DEPTH));
    const hue = remap(annBelowGrid[i], MW_MIN, MW_MAX, 170, 355);
    fill(hue, 70, 70, 210);
    if (wLeftAnn > 0) rect(xLeftAnn, yTop, wLeftAnn, yBot - yTop);
    if (wRightAnn > 0) rect(xRightAnn, yTop, wRightAnn, yBot - yTop);
  }
  if (levelDeficit_m > 0.01) {
    const levelY = mapDepthToY(Math.min(levelDeficit_m, TD_DEPTH));
    noStroke(); fill(0, 0, 0, 80); rect(px + 1, well.y, dp.w - 2, levelY - well.y);
    stroke(55, 80, 90); strokeWeight(2); line(px + 3, levelY, px + dp.w - 3, levelY);
    noStroke(); fill(0, 0, 95); textAlign(LEFT, CENTER); textSize(11);
    text(`DS level ↓ ${nf(levelDeficit_m, 1, 1)} m`, px + dp.w , levelY );
    textAlign(CENTER, CENTER);
  }
  if (MPD_ON){
    const capY = well.y - 8;
    const xL = well.x + 2;
    const xR = well.x + well.w - 2;
    noStroke(); fill(0, 80, 80, 230); rect(xL, capY, xR - xL, 14, 3);
    fill(0,0,100); textSize(12); textAlign(CENTER, BASELINE); text("RCD", (xL + xR)/2, capY + 12);
    textAlign(CENTER, CENTER);
  }
  drawCMLVisual();
}
function drawCMLVisual(){
  if (!CML_ON) return;
  // Geometry
  const yPump = mapDepthToY(CML_DEPTH);
  const pumpX = well.x + well.w + 8;
  const pumpSize = 16;
  // Yellow pump marker
  noStroke(); fill(55, 100, 100, 240);
  rect(pumpX, yPump - pumpSize/2, pumpSize, pumpSize, 3);
  // Vertical pipe — only visible from SURFACE down to the PUMP
  const pipeW = 12, pipeX = pumpX + pumpSize + 10;
  stroke(0,0,50,160); noFill();
  const yTop = well.y; // surface
  rect(pipeX - pipeW/2, yTop, pipeW, yPump - yTop, 3);
  // Fill only the section ABOVE the pump (surface → pump)
  noStroke();
  for (let i = 0; i < N_ABV; i++){
    const dTop = i * CELL_M;
    const dBot = Math.min((i+1) * CELL_M, BOP_DEPTH);
    // clip to [0, CML_DEPTH]
    if (dTop >= CML_DEPTH) break; // below pump → don’t draw
    const segTop = mapDepthToY(dTop);
    const segBot = mapDepthToY(Math.min(dBot, CML_DEPTH));
    const hue = remap(cmlPipeGrid[i], MW_MIN, MW_MAX, 170, 355);
    fill(hue, 70, 70, 210);
    rect(pipeX - pipeW/2 + 1, segTop, pipeW - 2, segBot - segTop);
  }
  // Flow arrow (up)
  stroke(55,100,100); strokeWeight(2);
  line(pipeX, yTop + 8, pipeX, yTop + 28);
  line(pipeX - 5, yTop + 14, pipeX, yTop + 8);
  line(pipeX + 5, yTop + 14, pipeX, yTop + 8);
}
function drawBottomFrames(){
  // white thin frames
  stroke(0,0,100); noFill();
  rect(rheoFrameX, frameY, rheoFrameW, frameHeight, 8);
  rect(gelFrameX, frameY, gelFrameW, frameHeight, 8);
  rect(geomFrameX, frameY, geomFrameW, frameHeight, 8);
  // titles under each frame
  noStroke(); fill(0,0,95); textAlign(CENTER, TOP); textSize(12);
  text("Rheology Configurations", rheoFrameX + rheoFrameW/2, frameY + frameHeight + 10);
  text("Gel Configurations", gelFrameX + gelFrameW/2, frameY + frameHeight + 10);
  text("Well Geometry", geomFrameX + geomFrameW/2, frameY + frameHeight + 10);
  // small status badge (like your screenshot) near the top-left of the Rheology frame
  const badgeX = rheoFrameX + 650;
  const badgeY = frameY + 38;
  drawBadge(badgeX, badgeY, `Friction: ${FRICTION_MODE},
Hydraulics: ${HYDRAULICS_MODEL} | Rheo: ${ACTIVE_RHEO_MODEL}`);
}
function drawEnhancedHydraulicsFrame(){
  // Frame
  stroke(0,0,100); noFill();
  rect(ehFrameX, ehFrameY, ehFrameW, ehFrameH, 8);
  // Title
  noStroke(); fill(0,0,95); textAlign(CENTER, TOP); textSize(12);
  text("Enhanced Hydraulics controls", ehFrameX + ehFrameW/2, ehFrameY + ehFrameH + 10);
  // live status line
  textAlign(LEFT, TOP); fill(0,0,95); textSize(12);
  const st = (k) => EH[k].on ? 'ON' : 'OFF';
  const sv = (k) => nf(EH[k].s, 1, 2);
const ehStatus =
  `ECC: ${st('ECC')} (s=${sv('ECC')}) | ` +
  `ROUGH: ${st('ROUGH')} (s=${sv('ROUGH')}) | ` +
  `KLOSS: ${st('KLOSS')} (s=${sv('KLOSS')}) | ` +
  `P-only: ${st('PCOR')} (s=${sv('PCOR')}) | Fluid: ${EH.PCOR.fluid}`;
text(ehStatus, ehFrameX + 12, ehFrameY + ehFrameH - 22);
  textAlign(CENTER, CENTER);
}
function drawDepthGrid(){
  fill(0,0,80); noStroke(); textSize(12);
  for (let d=0; d<=MAX_DEPTH; d+=1000){
    const y = mapDepthToY(d);
    text(d+" m", well.x -75, y);
    stroke(0,0,60,120); line(well.x-40, y, well.x+well.w+40, y); noStroke();
  }
}
function drawReferenceBadges(){
  const starX = well.x - 40;
  for (const m of MARKS){
    const y = mapDepthToY(m.d);
    drawStar(starX, y);
    const p = pressureAtDepth(m.d);
    const ecdEff = ecdWithSBPAtDepth(m.d);
    drawBadge(well.x + well.w/2, y, `${m.name} • ${nf(p,0,0)} psi`, `Eff. ECD • ${nf(ecdEff,1,2)} ppg`);
  }
}
function drawGaugesAndCharts(){
  const colGap = 48;
  const colLeft = well.x + well.w + 120;
  const colRight = colLeft + (R*2) + colGap;
  // SPP gauges at top
  const cxSPP = well.x + well.w + 110;
  const cyTop = well.y + 48;
  const vSPPraw = surfacePumpPressure();
  lastSPP = updateSPP(vSPPraw);
  drawGauge(cxSPP, cyTop, lastSPP, 16000, "SPP", "psi", R, "left");
  if (levelDeficit_m > 0.01){ textAlign(LEFT, CENTER); textSize(11); fill(0,0,95); text(`DS level ↓ ${nf(levelDeficit_m,1,1)} m`, cxSPP -30, cyTop + 40); textAlign(CENTER, CENTER); }
  const cxBo = cxSPP + 2 * R + 40;
const vBoRaw = boosterPumpPressure();
const vBo = updateBoosterSPP(vBoRaw);
drawGauge(cxBo, cyTop, vBo, 16000, "Booster SPP", "psi", R, "right");
if (levelDeficit_bo_m > 0.01){
  textAlign(LEFT, CENTER); textSize(11); fill(0,0,95);
  text(`Bo level ↓ ${nf(levelDeficit_bo_m,1,1)} m`, cxBo -30 , cyTop + 40);
  textAlign(CENTER, CENTER);
}
  // Depth gauges
  drawGauge(colLeft, mapDepthToY(BOP_DEPTH), pressureAtDepth(BOP_DEPTH), 16000, " ", "psi", R, "left");
  drawGauge(colLeft, mapDepthToY(SHOE_DEPTH), pressureAtDepth(SHOE_DEPTH), 16000, " ", "psi", R, "left");
  drawGauge(colLeft, mapDepthToY(TD_DEPTH), pressureAtDepth(TD_DEPTH), 16000, " ", "psi", R, "left");
  drawGauge(colRight, mapDepthToY(BOP_DEPTH), ecdWithSBPAtDepth(BOP_DEPTH), 18, "BOP", "ppg", R, "right");
  drawGauge(colRight, mapDepthToY(SHOE_DEPTH), ecdWithSBPAtDepth(SHOE_DEPTH),18, "Shoe","ppg", R, "right");
  drawGauge(colRight, mapDepthToY(TD_DEPTH), ecdWithSBPAtDepth(TD_DEPTH), 18, "TD", "ppg", R, "right");
  // >>> Add the status panel here <<<
  drawStatusPanelRight(colRight);
  // Charts on the far right
  const chartX = colRight + (R*2) + 20;
  drawCharts(chartX);
}
// ------------------------ Charts & Primitives --------------------------
 // ------------------------ Status panel (right of ECD gauges) ----------
function drawStatusPanelRight(colRight){
  // Place it just to the right of the right-side (ECD) gauges
  const x = colRight + R + 24; // nudge right of the gauge rim
  const y = well.y + 220; // vertical spot like in your screenshot
  textAlign(LEFT, TOP); textSize(12); fill(0,0,95);
  // Annulus average above BOP
  text(`Annulus MW above BOP: ${nf(average(annAboveGrid),1,2)} ppg`, x-220, y);
  let y2 = y + 18;
  // SBP & mode
  text(`SBP Applied: ${nf(CURRENT_SBP,1,0)} psi | Mode: ${SBP_MODE.toUpperCase()}`, x-220, y2);
  y2 += 18;
  // Anchor info (only if set)
  if (ANCHOR_DEPTH > 0 && ANCHOR_ECD > 0){
    text(`Anchor: ${ANCHOR_DEPTH} m @ ${nf(ANCHOR_ECD,1,2)} ppg`, x-220, y2);
  }
  textAlign(CENTER, CENTER); // restore default
  y2 += 18;
  // CML status
  const topDepth = riserTopDepth();
  const cmlMode = AUTO_CML_ON ? "AUTO" : "MANUAL";
  let cmlExtra = "";
  if (AUTO_CML_ON && CML_AP_DEPTH > 0 && CML_AP_ECD > 0){
    cmlExtra = ` | Anchor: ${nf(CML_AP_DEPTH,1,0)} m @ ${nf(CML_AP_ECD,1,2)} ppg`;
  }
  text(`CML: ${CML_ON ? "ON" : "OFF"} | Mode: ${cmlMode} | Pump @ ${nf(CML_DEPTH,1,0)} m | Q_out: ${nf(Q_CML,1,0)} gpm | Riser top: ${nf(topDepth,1,1)} m${cmlExtra}`,
       x-220, y2);
}
function drawCharts(x0){
  const top = 90, h = 420;
  const wP = 260, wE = 340, gap = 40;
  const padL = 54, padR = 18, padT = 28, padB = 42;
  const axisCol = color(0, 0, 95);
  const gridCol = color(0, 0, 60, 120);
  const lineColP = color(0, 80, 80);
  // Pressure chart
  const px = x0, py = top;
  drawChartPanel(px, py, wP, h, "Pressure (psi)");
  drawChartGrid(px, py, wP, h, padL, padR, padT, padB, gridCol);
  plotDepthFunction(px, py, wP, h, padL, padR, padT, padB, d => pressureAtDepth(d), 0, 16000, lineColP);
  drawAxes(px, py, wP, h, padL, padR, padT, padB, axisCol);
  drawDepthTicks(px, py, wP, h, padL, padR, padT, padB, axisCol);
  drawXTicks(px, py, wP, h, padL, padR, padT, padB, axisCol, 0, 16000, [0, 4000, 8000, 12000, 16000]);
  if (showCaptured && capturedP){ plotDepthOverlay(px, py, wP, h, padL, padR, padT, padB, capturedP, 0, 16000, color(55,80,80)); }
  // ECD chart (includes SBP)
  const ex = x0 + wP + gap, ey = top;
  drawChartPanel(ex, ey, wE, h, "ECD (ppg)");
  drawChartGrid(ex, ey, wE, h, padL, padR, padT, padB, gridCol);
  plotDepthFunctionMasked( ex, ey, wE, h, padL, padR, padT, padB, d => ecdWithSBPAtDepth(d), 6, 18, color(0, 80, 80), v => isFinite(v) && v > 6 && v <= 18 );
  drawAxes(ex, ey, wE, h, padL, padR, padT, padB, axisCol);
  drawDepthTicks(ex, ey, wE, h, padL, padR, padT, padB, axisCol);
  drawXTicks(ex, ey, wE, h, padL, padR, padT, padB, axisCol, 6, 18, [6, 9, 12, 15, 18]);
  if (showCaptured && capturedECD){ plotDepthOverlayMasked( ex, ey, wE, h, padL, padR, padT, padB, capturedECD, 6, 18, color(55,80,80), v => isFinite(v) && v > 6 && v <= 18 ); }
  // Time series
  const timeChartX = ex + wE + 40;
  drawTimeChart(timeChartX, top, 640, h);
}
function drawTimeChart(x, y, w, h){
  drawChartPanel(x, y, w, h, "Time Series");
  const padL = 54, padR = 18, padT = 28, padB = 42;
  const innerW = w - padL - padR;
  const innerH = h - padT - padB;
  const left = x + padL, topI = y + padT, right = x + w - padR, bottom = y + h - padB;
  const gridCol = color(0, 0, 60, 120);
  stroke(gridCol); strokeWeight(1);
  for (let i=1; i<4; i++){ const xx = left + innerW*i/4; line(xx, topI, xx, bottom); }
  for (let i=1; i<6; i++){ const yy = topI + innerH*i/6; line(left, yy, right, yy); }
  const axisCol = color(0, 0, 95);
  stroke(axisCol); strokeWeight(2);
  line(left, topI, left, bottom);
  line(left, bottom, right, bottom);
  const maxQ = Math.max(100, Q_MAX*1.1);
  const maxP = 16000;
  // Flow (cyan-ish)
  noFill(); stroke(180, 50, 80); strokeWeight(2); beginShape();
  for (let i=0;i<tsFlow.length;i++){
    const t = i/(TS_MAX-1); const xx = left + t*innerW;
    const yy = bottom - remap(tsFlow[i], 0, maxQ, 0, innerH, true);
    vertex(xx, yy);
  } endShape();
  // SBP (magenta)
  noFill(); stroke(300, 70, 80); strokeWeight(2); beginShape();
  for (let i=0;i<tsSBP.length;i++){
    const t = i/(TS_MAX-1); const xx = left + t*innerW;
    const yy = bottom - remap(tsSBP[i], 0, maxP, 0, innerH, true);
    vertex(xx, yy);
  } endShape();
  // Actual P (green)
  stroke(120, 60, 80); strokeWeight(2); beginShape();
  for (let i=0;i<tsPactual.length;i++){
    const t = i/(TS_MAX-1); const xx = left + t*innerW;
    const yy = bottom - remap(tsPactual[i], 0, maxP, 0, innerH, true);
    vertex(xx, yy);
  } endShape();
  // Setpoint (yellow) if anchor set
  if (ANCHOR_DEPTH > 0 && ANCHOR_ECD > 0){
    stroke(55,100,80); strokeWeight(2); beginShape();
    for (let i=0;i<tsPset.length;i++){
      if (isNaN(tsPset[i])) continue;
      const t = i/(TS_MAX-1); const xx = left + t*innerW;
      const yy = bottom - remap(tsPset[i], 0, maxP, 0, innerH, true);
      vertex(xx, yy);
    } endShape();
  }
  // SPP (orange-ish)
  noFill(); stroke(30, 80, 90); strokeWeight(2); beginShape();
  for (let i=0;i<tsSPP.length;i++){
    const t = i/(TS_MAX-1); const xx = left + t*innerW;
    const yy = bottom - remap(tsSPP[i], 0, maxP, 0, innerH, true);
    vertex(xx, yy);
  } endShape();
  const legend = [
    {label: 'Flow (Q)', col: color(180, 50, 80)},
    {label: 'Pressure (actual)', col: color(120, 60, 80)},
    {label: 'SPP', col: color(30, 80, 90)},
    {label: 'Setpoint', col: color(55, 100, 80)},
    {label: 'SBP Applied', col: color(300, 70, 80)},
  ];
  const lgPadX = 10, lgPadY = 8, sw = 24, sh = 10, rowH = 16;
  let lgW = 0; textSize(11);
  for (const it of legend) lgW = Math.max(lgW, textWidth(it.label));
  const boxW = lgPadX*2 + sw + 8 + lgW;
  const boxH = lgPadY*2 + legend.length*rowH;
  const boxX = right - boxW - 8;
  const boxY = topI + 8;
  noStroke(); fill(0,0,20,220); rect(boxX, boxY, boxW, boxH, 6);
  for (let i=0;i<legend.length;i++){
    const yy = boxY + lgPadY + i*rowH + 4;
    fill(legend[i].col); rect(boxX + lgPadX, yy-7, sw, sh, 2);
    fill(0,0,95); noStroke(); textAlign(LEFT, CENTER);
    text(legend[i].label, boxX + lgPadX + sw + 8, yy-2);
  }
  textAlign(CENTER, CENTER);
}
// ------------------------ Drawing primitives & helpers -----------------
function drawChartPanel(x, y, w, h, title){
  noStroke(); fill(0,0,20,200); rect(x-10, y-14, w+20, h+44, 10);
  fill(0,0,0); rect(x, y, w, h, 8);
  fill(0,0,95); noStroke(); textSize(14); textAlign(CENTER, TOP);
  text(title, x + w/2, y + h + 6);
}
function drawChartGrid(x,y,w,h,padL,padR,padT,padB,col){
  const innerW=w-padL-padR, innerH=h-padT-padB;
  const left=x+padL, top=y+padT, right=x+w-padR, bottom=y+h-padB;
  stroke(col); strokeWeight(1);
  for (let i=1; i<4; i++){ const xx = left + (innerW*i)/4; line(xx, top, xx, bottom); }
  for (let d=1000; d<MAX_DEPTH; d+=1000){
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    line(left, yy, right, yy);
  }
}
function drawAxes(x,y,w,h,padL,padR,padT,padB,col){
  const left = x + padL, top = y + padT, right = x + w - padR, bottom = y + h - padB;
  stroke(col); strokeWeight(2);
  line(left, top, left, bottom);
  line(left, bottom, right, bottom);
}
function drawDepthTicks(x,y,w,h,padL,padR,padT,padB,col){
  const innerH=h-padT-padB, left=x+padL, top=y+padT;
  fill(col); noStroke(); textSize(11); textAlign(RIGHT, CENTER);
  stroke(col); strokeWeight(1.5);
  for (let d=0; d<=MAX_DEPTH; d+=1000){
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    line(left-5, yy, left, yy);
    noStroke(); text(`${d}`, left-8, yy); stroke(col);
  }
}
function drawXTicks(x,y,w,h,padL,padR,padT,padB,col,vmin,vmax,ticks){
  const innerW=w-padL-padR, left=x+padL, bottom=y+h-padB;
  fill(col); noStroke(); textSize(11); textAlign(CENTER, TOP);
  stroke(col); strokeWeight(1.5);
  for (const t of ticks){
    const xx = left + remap(t, vmin, vmax, 0, innerW, true);
    line(xx, bottom, xx, bottom+5);
    noStroke(); text(`${t}`, xx, bottom+8); stroke(col);
  }
}
function plotDepthFunction(x,y,w,h,padL,padR,padT,padB,f,xmin,xmax,col){
  const innerW=w-padL-padR, innerH=h-padT-padB;
  const left=x+padL, top=y+padT, right=x+w-padR;
  noFill(); stroke(col); strokeWeight(3); beginShape();
  for (let d=0; d<=MAX_DEPTH; d+=25){
    const val = f(d);
    const xx = left + remap(val, xmin, xmax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    vertex(xx, yy);
  } endShape();
  const yTD = top + remap(TD_DEPTH, 0, MAX_DEPTH, 0, innerH, true);
  stroke(0,0,95); strokeWeight(2.5); line(left, yTD, right, yTD);
}
function plotDepthFunctionMasked(x,y,w,h,padL,padR,padT,padB,f,xmin,xmax,col, valid){
  const innerW=w-padL-padR, innerH=h-padT-padB;
  const left=x+padL, top=y+padT, right=x+w-padR;
  let drawing = false;
  stroke(col); strokeWeight(3); noFill();
  for (let d=0; d<=MAX_DEPTH; d+=25){
    const val = f(d), ok = valid(val);
    const xx = left + remap(val, xmin, xmax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    if (ok){
      if (!drawing){ beginShape(); drawing = true; }
      vertex(xx, yy);
    } else {
      if (drawing){ endShape(); drawing = false; }
    }
  }
  if (drawing) endShape();
  const yTD = top + remap(TD_DEPTH, 0, MAX_DEPTH, 0, innerH, true);
  stroke(0,0,95); strokeWeight(2.5); line(left, yTD, right, yTD);
}
function plotDepthOverlay(x,y,w,h,padL,padR,padT,padB,arr,ymin,ymax,col){
  const step = 25, innerW = w - padL - padR, innerH = h - padT - padB;
  const left = x + padL, top = y + padT;
  noFill(); stroke(col); strokeWeight(2); beginShape();
  for (let i=0, d=0; d<=MAX_DEPTH; i++, d+=step){
    const val = arr[i];
    const xx = left + remap(val, ymin, ymax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    vertex(xx, yy);
  } endShape();
}
function plotDepthOverlayMasked(x,y,w,h,padL,padR,padT,padB,arr,ymin,ymax,col, valid){
  const step = 25, innerW = w - padL - padR, innerH = h - padT - padB;
  const left = x + padL, top = y + padT;
  let drawing = false;
  stroke(col); strokeWeight(2); noFill();
  for (let i=0, d=0; d<=MAX_DEPTH; i++, d+=step){
    const val = arr[i], ok = valid(val);
    const xx = left + remap(val, ymin, ymax, 0, innerW, true);
    const yy = top + remap(d, 0, MAX_DEPTH, 0, innerH, true);
    if (ok){
      if (!drawing){ beginShape(); drawing = true; }
      vertex(xx, yy);
    } else {
      if (drawing){ endShape(); drawing = false; }
    }
  }
  if (drawing) endShape();
}
function drawBadge(cx, cy, line1, line2, withStar=false){
  push(); translate(cx,cy);
  const boxW=190, boxH=38;
  if (withStar){ noStroke(); fill(55,80,90); star(-boxW/2-12,0,4,9,5); }
  fill(0,0,20,230); rect(-boxW/2,-boxH/2,boxW,boxH,6);
  fill(0,0,95); textAlign(CENTER,CENTER); textSize(12); text(line1,0,-6);
  textSize(10); fill(0,0,80); text(line2,0,10);
  pop();
}
function drawGauge(cx, cy, value, vMax, label, units, r, labelSide){
  noFill(); stroke(0,0,95); strokeWeight(2.5); arc(cx,cy,r*2,r*2,PI,TWO_PI);
  strokeWeight(6); stroke(120,60,80); arc(cx,cy,r*2,r*2, PI,PI+0.33*PI);
  stroke(40,70,80); arc(cx,cy,r*2,r*2, PI+0.33*PI,PI+0.66*PI);
  stroke(0,80,80); arc(cx,cy,r*2,r*2, PI+0.66*PI,TWO_PI);
  const norm = clamp(value/Math.max(1e-9,vMax),0,1);
  const ang = PI + norm*PI;
  stroke(0,0,95); strokeWeight(2.5); line(cx,cy,cx+r*cos(ang),cy+r*sin(ang));
  noStroke(); fill(0,0,95); circle(cx,cy,7);
  fill(0,0,95); textSize(Math.max(12,Math.round(r*0.26)));
  const dec=(units==='ppg'?2:0); text(`${nf(value,0,dec)} ${units}`,cx,cy+(r*0.35));
  fill(0,0,80); textSize(Math.max(10,Math.round(r*0.18)));
  textAlign(labelSide==="left"?RIGHT:LEFT,CENTER);
  const lx=labelSide==="left"?(cx-r-14):(cx+r+14);
  text(label,lx,cy);
  textAlign(CENTER,CENTER);
}
function drawStar(x,y){ push(); noStroke(); fill(55, 80, 90); star(x, y, 4, 9, 5); pop(); }
function star(x,y,r1,r2,n){
  let a=TWO_PI/n, h=a/2; beginShape();
  for(let ang=0; ang<TWO_PI; ang+=a){
    vertex(x+cos(ang)*r2, y+sin(ang)*r2);
    vertex(x+cos(ang+h)*r1, y+sin(ang+h)*r1);
  } endShape(CLOSE);
}
// ============================== RHEOLOGY UI BUILDER =============================
function buildRheologyUI(x0, y0){
  const label = (txt, x, y) =>
    createDiv(txt).position(x,y).style("color","#E6E6E6").style("font-size","12px");
  const box = (val, x, y, w=80) => {
    const el = createInput(String(val), 'number'); el.position(x,y).size(w); return el;
  };
  const SEP_Y = 50; // vertical spacing
  const COL_W = 100;
  const COL_GAP = 16;
  const xs = i => x0 + i * (COL_W + COL_GAP);
  // --- Model selector (create first, then bind) ---
  label("Rheology Model", x0, y0);
  rheoPanel.modelSel = createSelect();
  rheoPanel.modelSel.position(x0, y0+14).size(130, 24);
  ["HB","PowerLaw","Bingham"].forEach(o => rheoPanel.modelSel.option(o));
  rheoPanel.modelSel.selected(ACTIVE_RHEO_MODEL || "HB");
  rheoPanel.modelSel.changed(() => {
    ACTIVE_RHEO_MODEL = rheoPanel.modelSel.value();
    doRheologyFit(); // ensure PV/YP-direct or R-points apply immediately
  });
  // --- Inputs ---
  let y = y0 + 58;
  label("Funnel (s/qt)", xs(0), y-18); rheoPanel.fv = box(rheoDefaults.fv, xs(0), y);
  label("Temp (°C)", xs(1), y-18); rheoPanel.T = box(rheoDefaults.T, xs(1), y);
  label("R600", xs(2), y-18); rheoPanel.R600 = box(rheoDefaults.R600, xs(2), y);
  label("R300", xs(3), y-18); rheoPanel.R300 = box(rheoDefaults.R300, xs(3), y);
  label("R200", xs(4), y-18); rheoPanel.R200 = box(rheoDefaults.R200, xs(4), y);
  label("R100", xs(5), y-18); rheoPanel.R100 = box(rheoDefaults.R100, xs(5), y);
  y += SEP_Y;
  label("R6", xs(0), y-18); rheoPanel.R6 = box(rheoDefaults.R6, xs(0), y);
  label("R3", xs(1), y-18); rheoPanel.R3 = box(rheoDefaults.R3, xs(1), y);
  label("R1", xs(2), y-18); rheoPanel.R1 = box(rheoDefaults.R1, xs(2), y);
  label("PV (cP)", xs(3), y-18); rheoPanel.PV = box(rheoDefaults.PV, xs(3), y);
  label("YP (lbf/100ft²)",xs(4), y-18);rheoPanel.YP = box(rheoDefaults.YP, xs(4), y, 110);
  // --- Actions & status ---
  y += SEP_Y;
  rheoPanel.fitBtn = createButton("Fit curves").position(x0, y).size(110, 26);
  rheoPanel.showFitBtn = createButton("Show fitted params").position(x0+120, y).size(170, 26);
  rheoPanel.fitBtn.mousePressed(() => doRheologyFit());
  rheoPanel.showFitBtn.mousePressed(() => showFittedParams());
  rheoPanel.statusDiv = createDiv("Awaiting fit.");
  rheoPanel.statusDiv.position(x0+300, y+2).style("color","#CCCCCC").style("font-size","12px");
  // Re-fit whenever any rheology input changes (incl. PV/YP)
  [
    rheoPanel.R600, rheoPanel.R300, rheoPanel.R200, rheoPanel.R100,
    rheoPanel.R6, rheoPanel.R3, rheoPanel.R1,
    rheoPanel.PV, rheoPanel.YP
  ].forEach(el => { if (el) el.input(() => doRheologyFit()); });
}
function buildEnhancedHydraulicsUI(x0, y0){
  const mk = (txt,x,y) => createDiv(txt).position(x, y).style("color", "#EEE").style("font-size", "12px");
  const cols = 2, rows = 2;
  const innerPad = 14;
  const cellW = (ehFrameW - innerPad*(cols+1)) / cols;
  const cellH = (ehFrameH - innerPad*(rows+1)) / rows;
  const cellXY = (c, r) => ({ x: ehFrameX + innerPad + c*(cellW + innerPad -70), y: ehFrameY + innerPad + r*(cellH + innerPad-70) });
  const spec = [
    { key:'ECC', label:'Eccentric annulus', hint:'ON/OFF + eccentricity multiplier (±)', col:0, row:0 },
    { key:'ROUGH', label:'Roughness (turb)', hint:'ON/OFF + roughness multiplier (±)', col:1, row:0 },
    { key:'KLOSS', label:'Local K-losses (SPP)', hint:'ON/OFF + extra losses (±)', col:0, row:1 },
    { key:'PCOR', label:'P-only corrections (ρ & μ)',hint:'β(P) for density, α(P) for viscosity', col:1, row:1 },
  ];
  ehPanel.toggles = {};
  ehPanel.sliders = {};
  const labelW = 200, sliderW = 180;
  spec.forEach(f => {
    const {x, y} = cellXY(f.col, f.row);
    stroke(0,0,60,120); noFill(); rect(x, y, cellW, cellH, 6);
    const bx = x + 12, by = y + 10;
    const btn = createButton(EH[f.key].on ? `${f.label}: ON` : `${f.label}: OFF`)
      .size(labelW, 26).position(bx, by)
      .mousePressed(() => { EH[f.key].on = !EH[f.key].on; btn.html(EH[f.key].on ? `${f.label}: ON` : `${f.label}: OFF`); });
    ehPanel.toggles[f.key] = btn;
    mk("Multiplier (−1 … 0 … +1)", bx, by + 34);
    const sld = createSlider(-1, 1, EH[f.key].s, 0.01).position(bx, by + 54).style('width', `${sliderW}px`);
    sld.input(() => EH[f.key].s = Number(sld.value()));
    ehPanel.sliders[f.key] = sld;
    mk(f.hint, bx, by + 84);
    if (f.key === 'PCOR'){
      mk("Fluid Type", bx + sliderW + 100, by -90);
      const fluidSel = createSelect().position(bx + sliderW + 60, by -75).size(120, 24);
      ["WBM","OBM","Diesel"].forEach(o => fluidSel.option(o));
      fluidSel.selected(EH.PCOR.fluid);
      fluidSel.changed(() => { EH.PCOR.fluid = fluidSel.value(); });
    }
  });
}
// =========================== STATE SETTERS ============================
function setDSMW(val){ if (isNaN(val)) return; MW_DS = clamp(Number(val), MW_MIN, MW_MAX); dsMWSlider.value(MW_DS); dsMWInput.value(nf(MW_DS,1,1)); }
function setDSQ(val){ if (isNaN(val)) return; Q_DS = clamp(Number(val), Q_MIN, Q_MAX); dsQSlider.value(Q_DS); dsQInput.value(nf(Q_DS,1,0)); }
function setBOMW(val){ if (isNaN(val)) return; MW_BO = clamp(Number(val), MW_MIN, MW_MAX); boMWSlider.value(MW_BO); boMWInput.value(nf(MW_BO,1,1)); }
function setBOQ(val){ if (isNaN(val)) return; Q_BO = clamp(Number(val), Q_MIN, Q_MAX); boQSlider.value(Q_BO); boQInput.value(nf(Q_BO,1,0)); }
function setK(val){ if (isNaN(val)) return; K_FAC = clamp(Number(val), 0.0, 0.0002); kSlider.value(K_FAC); kInput.value(nf(K_FAC,1,6)); }
function setRPM(val){ RPM = clamp(Number(val)||0, 0, 220); rpmSlider.value(RPM); rpmInput.value(nf(RPM,1,0)); }
// One frame worth of "simulation time" (keeps the fast-clock consistent)
function frameSeconds(){
  // BASE_M_PER_FRAME is tied to a reference velocity. Convert to a time step.
  const qRef_m3s = (Q_REF/15850.323);
  const vRef = qRef_m3s / Math.max(A_riser(), 1e-12); // m/s in riser
  const dx = BASE_M_PER_FRAME; // m advanced per frame at vRef
  return dx / Math.max(vRef, 1e-9); // seconds per frame
}
// ======================= CML physics & control =======================
function updateCMLLevelAndControl(){
  if (!CML_ON){
    CML_TOP_DEPTH = 0; // riser stays full when CML is off
    return;
  }
  const dt = frameSeconds();
  // Incoming flow to riser annulus (m³/s)
  const qIn = ((Q_DS||0) + (Q_BO||0)) / 15850.323;
 
    // Incoming flow to riser annulus (m³/s)
  //const qIn = ((Q_DS||0) + (Q_BO||0)) / 15850.323;
// --- U-tube natural backflow (annulus leg: surface -> CML pump depth) ---
  // Hydrostatic head available in the wet part of the riser leg
const dTop = CML_TOP_DEPTH; // m (0 at surface)
const dPump = Math.max(0, Math.min(CML_DEPTH, BOP_DEPTH));
const wetSpan = Math.max(0, dPump - dTop);
  let qU_m3s = 0;
if (wetSpan > 0){
 // static head from top to the pump pickup (no friction, no SBP)
  const ecd_leg_ppg = ecdAtDepth(Math.max(1, dPump)); // composition-based
   const dP_hyd_psi = PSI_COEF * ecd_leg_ppg * wetSpan; // psi
   const R_leg = riserLegResistancePsiPer_m3s(dTop, dPump);
   // sign: positive qU means *upwards* to surface (adds to q_out)
   qU_m3s = Math.max(0, dP_hyd_psi / R_leg);
 }
 // Cap the natural flow to a reasonable engineering limit
 qU_m3s = Math.min(qU_m3s, (0.5 * Q_MAX) / 15850.323);
 
  // --- Auto CML controller: pick Q_CML to meet target (simple P-controller) ---
if (AUTO_CML_ON && CML_AP_DEPTH > 0 && CML_AP_ECD > 0){
  const P_set = PSI_COEF * CML_AP_ECD * CML_AP_DEPTH; // psi
  const P_now = pressureAtDepth_noSBP_withCML(CML_AP_DEPTH); // psi
  const err = P_set - P_now; // psi
  // crude gain → gpm per psi; clamp to [0, CML_Q_MAX]
  const Kp = 0.25; 
  Q_CML = clamp((Q_CML || 0) + Kp * err, 0, CML_Q_MAX || Q_MAX);
  if (cmlQSlider) cmlQSlider.value(Q_CML);
  if (cmlQInput) cmlQInput.value(nf(Q_CML,1,0));
}

// --- Compute CML_Q_MAX as DS+Booster (headroom for controller) ---
CML_Q_MAX = clamp((Q_DS || 0) + (Q_BO || 0), 0, Q_MAX);

// --- Net outflow at surface: pump command + natural backflow ---
const qCmd = (Q_CML || 0) / 15850.323; // m³/s
const qOut = qCmd + qU_m3s;

// Update riser top (CML_TOP_DEPTH) via a simple volume balance in the riser leg
const Aann_riser = A_riser(); // m²
const dH = (qOut - qIn) / Math.max(Aann_riser, 1e-12) * dt; // m change
CML_TOP_DEPTH = clamp((CML_TOP_DEPTH || 0) + dH, 0, BOP_DEPTH);
}

  
  
  // Auto-CML controller: pick Q_CML to meet target ECD at anchor
  if (AUTO_CML_ON && CML_AP_DEPTH > 0 && CML_AP_ECD > 0){
    const P_set = PSI_COEF * CML_AP_ECD * CML_AP_DEPTH; // psi
    const P_now = pressureAtDepth_noSBP_withCML(CML_AP_DEPTH); // psi
    const errPsi = P_now - P_set; // +ve => lower level
    // Simple P controller: map psi error to gpm change
    const Kp = 0.8; // gpm per 100 psi
    const dQ = (Kp/100) * errPsi;
    Q_CML = clamp(Q_CML + dQ, Q_MIN, Q_MAX);
  }
  // --- DS→Annulus U-tube through the bit due to hydrostatic imbalance ---
const MW_ds_ppg   = dsAvgPPG();
const MW_abv_ppg  = average(annAboveGrid) || MW_ds_ppg;
const MW_blw_ppg  = average(annBelowGrid) || MW_ds_ppg;

// Annulus “wet” heights depend on current riser top
const top = riserTopDepth(); // 0..BOP_DEPTH
const H_abv = Math.max(BOP_DEPTH - top, 0);
const H_blw = Math.max(TD_DEPTH - BOP_DEPTH, 0);

// Hydrostatic at TD (psi), friction-free driver
const P_ds_TD_psi  = PSI_COEF * MW_ds_ppg  * TD_DEPTH;
const P_ann_TD_psi = PSI_COEF * (MW_abv_ppg * H_abv + MW_blw_ppg * H_blw);

// Positive ΔP ⇒ push from DS into annulus
const dP_imb_psi = Math.max(P_ds_TD_psi - P_ann_TD_psi, 0);

// Equivalent loop resistance = DS↓ + annulus↑ + (optional) bit/tools
const R_ds  = drillstringLegResistancePsiPer_m3s();
const R_ann = riserLegResistancePsiPer_m3s(top, BOP_DEPTH) // above-BOP riser
            + ((H_blw>0)
                ? ((dPperM_openholeAnnulus(Q_REF/15850.323) * H_blw) * PSI_PER_PASCAL)
                    / Math.max((Q_REF/15850.323), 1e-9)
                : 0);
const R_bit = (typeof R_BIT_NOZZLE !== 'undefined') ? R_BIT_NOZZLE : 0;

// DS→Ann imbalance flow (m³/s)
const qImb_m3s = dP_imb_psi / Math.max(R_ds + R_ann + R_bit, 1e-6);
  // --- Level dynamics (CML_TOP_DEPTH grows when qOut > qIn)
  const qOut_m3s = (Q_CML || 0) / 15850.323 + qU_m3s;
  const A = A_riser(); // m² (riser annulus)
  //let dTop = 0;
  if (A > 0){
   // dTop = (qOut_m3s - qIn) / A * dt; // m
  }
  CML_TOP_DEPTH = clamp(CML_TOP_DEPTH + dTop, 0, BOP_DEPTH);
  // Don’t let the wet top go deeper than the pump intake
  CML_TOP_DEPTH = Math.min(CML_TOP_DEPTH, Math.max(0, CML_DEPTH - 0.1));
  // Dynamic max (for info/logic): the net out cannot exceed what keeps top at the pump
  const margin_m = Math.max(0, CML_DEPTH - CML_TOP_DEPTH);
  const qMax_m3s = qIn + (margin_m * A) / Math.max(dt, 1e-6);
  CML_Q_MAX = clamp(qMax_m3s * 15850.323, 0, Q_MAX);
  // If AUTO pushes too hard, softly cap to avoid “dry pump”
  if (Q_CML > CML_Q_MAX){
    Q_CML = CML_Q_MAX;
  }
function syncCMLTopSlider(){ if (!AUTO_CML_ON) cmlQTop.value(Q_CML); }
// Linearized DS leg resistance (psi per m³/s) at ~Q_REF
function drillstringLegResistancePsiPer_m3s() {
  const L = TD_DEPTH;
  if (L <= 0) return 1e9;
  const qRef = (Q_REF/15850.323); // m³/s
  const dpdl_Pa = dPperM_drillstring(qRef);  // Pa/m at qRef
  const dp_Pa  = dpdl_Pa * L;                // Pa
  const dp_psi = dp_Pa * PSI_PER_PASCAL;     // psi
  return Math.max(dp_psi / Math.max(qRef, 1e-9), 1);
}
const R_BIT_NOZZLE = 800 / Math.max((Q_REF/15850.323), 1e-9); // ~800 psi at Q_REF

/* ========================= PATCH: UI + SETTERS + EH ========================= */

// Small safe formatter (p5's nf sometimes not loaded in headless lint)
function fmt(v, d=2){ return (isFinite(v)? Number(v).toFixed(d) : '—'); }

/** Keep DS MW consistent with slider/input + grid seed */
function setDSMW(v){
  MW_DS = clamp(Number(v)||0, MW_MIN, MW_MAX);
  dsMWSlider?.value(MW_DS); dsMWInput?.value(nf(MW_DS,1,1));
  // seed the DS grid with the new MW at the inlet
  if (dsGrid && dsGrid.length){ dsGrid[0] = MW_DS; }
}

/** Keep Booster MW consistent with slider/input + grid seed */
function setBOMW(v){
  MW_BO = clamp(Number(v)||0, MW_MIN, MW_MAX);
  boMWSlider?.value(MW_BO); boMWInput?.value(nf(MW_BO,1,1));
  if (boosterGrid && boosterGrid.length){ boosterGrid[0] = MW_BO; }
}

/** DS flow (gpm) */
function setDSQ(v){
  Q_DS = clamp(Number(v)||0, Q_MIN, Q_MAX);
  dsQSlider?.value(Q_DS); dsQInput?.value(nf(Q_DS,1,0));
}

/** Booster flow (gpm) */
function setBOQ(v){
  Q_BO = clamp(Number(v)||0, Q_MIN, Q_MAX);
  boQSlider?.value(Q_BO); boQInput?.value(nf(Q_BO,1,0));
}

/** Generic friction k (only used if FRICTION_MODE==='generic') */
function setK(v){
  K_FAC = clamp(Number(v)||0, 0.0, 0.0002);
  kSlider?.value(K_FAC); kInput?.value(nf(K_FAC,1,6));
}

/** Pipe rotation coupling */
function setRPM(v){
  RPM = clamp(Number(v)||0, 0, 220);
  rpmSlider?.value(RPM); rpmInput?.value(String(RPM));
}

/** Convenience: toggle friction mode from console if needed */
function setFrictionMode(mode){
  FRICTION_MODE = (mode==='generic') ? 'generic' : 'hydraulics';
}

/** Wire the AP boxes to Auto-CML when you click Auto CML ON */
if (typeof cmlAutoBtn !== 'undefined' && cmlAutoBtn){
  cmlAutoBtn.mousePressed(() => {
    AUTO_CML_ON = !AUTO_CML_ON;
    // Copy anchor boxes into the CML anchor only when turning ON
    if (AUTO_CML_ON){
      const d = num(apDepthInput?.value());
      const e = num(apEcdInput?.value());
      if (isFinite(d) && d>0) CML_AP_DEPTH = d;
      if (isFinite(e) && e>0) CML_AP_ECD   = e;
    }
    cmlAutoBtn.html(AUTO_CML_ON ? 'Auto CML: ON' : 'Auto CML: OFF');
  });
}

/* -------------------- Enhanced Hydraulics UI builder -------------------- */
function buildEnhancedHydraulicsUI(x0, y0){
  const mkLabel = (t,x,y)=> createDiv(t).position(x,y).style('color','#EEE').style('font-size','12px');
  const rowH = 26, gapY = 36, colW = 180, knobW = 160;

  // Header
  mkLabel('Enhanced Hydraulics (experimental)', x0, y0-4);

  // ECCENTRICITY
  let y = y0 + 22;
  EH.ECC.onToggle = createButton(EH.ECC.on?'ECC: ON':'ECC: OFF')
    .position(x0, y).size(90, rowH)
    .mousePressed(()=>{
      EH.ECC.on = !EH.ECC.on;
      EH.ECC.onToggle.html(EH.ECC.on?'ECC: ON':'ECC: OFF');
    });
  mkLabel('Eccentricity gain (−1 … +1)', x0+100, y+4);
  EH.ECC.slider = createSlider(-1, +1, EH.ECC.s, 0.01).position(x0+260, y+4).style('width', knobW+'px');
  EH.ECC.slider.input(()=>{ EH.ECC.s = Number(EH.ECC.slider.value()); });

  // ROUGHNESS
  y += gapY;
  EH.ROUGH.onToggle = createButton(EH.ROUGH.on?'ROUGH: ON':'ROUGH: OFF')
    .position(x0, y).size(90, rowH)
    .mousePressed(()=>{
      EH.ROUGH.on = !EH.ROUGH.on;
      EH.ROUGH.onToggle.html(EH.ROUGH.on?'ROUGH: ON':'ROUGH: OFF');
    });
  mkLabel('Roughness gain (−1 … +1)', x0+100, y+4);
  EH.ROUGH.slider = createSlider(-1, +1, EH.ROUGH.s, 0.01).position(x0+260, y+4).style('width', knobW+'px');
  EH.ROUGH.slider.input(()=>{ EH.ROUGH.s = Number(EH.ROUGH.slider.value()); });

  // LOCAL K-LOSSES (adds/subtracts to SPP)
  y += gapY;
  EH.KLOSS.onToggle = createButton(EH.KLOSS.on?'K-LOSS: ON':'K-LOSS: OFF')
    .position(x0, y).size(90, rowH)
    .mousePressed(()=>{
      EH.KLOSS.on = !EH.KLOSS.on;
      EH.KLOSS.onToggle.html(EH.KLOSS.on?'K-LOSS: ON':'K-LOSS: OFF');
    });
  mkLabel(`K-loss knob (−1 … +1) → ±${EH_TUNE.kloss_spp_base} psi`, x0+100, y+4);
  EH.KLOSS.slider = createSlider(-1, +1, EH.KLOSS.s, 0.01).position(x0+260, y+4).style('width', knobW+'px');
  EH.KLOSS.slider.input(()=>{ EH.KLOSS.s = Number(EH.KLOSS.slider.value()); });

  // P-only CORRECTIONS (ρ, μ vs. P)
  y += gapY;
  EH.PCOR.onToggle = createButton(EH.PCOR.on?'P-only: ON':'P-only: OFF')
    .position(x0, y).size(90, rowH)
    .mousePressed(()=>{
      EH.PCOR.on = !EH.PCOR.on;
      EH.PCOR.onToggle.html(EH.PCOR.on?'P-only: ON':'P-only: OFF');
    });
  mkLabel('Strength (−1 … +1)', x0+100, y+4);
  EH.PCOR.slider = createSlider(-1, +1, EH.PCOR.s, 0.01).position(x0+260, y+4).style('width', knobW+'px');
  EH.PCOR.slider.input(()=>{ EH.PCOR.s = Number(EH.PCOR.slider.value()); });

  // Fluid select for P-only correction
  mkLabel('Fluid', x0+430, y+4);
  EH.PCOR.sel = createSelect().position(x0+470, y).size(120, rowH);
  ['WBM','OBM','Diesel'].forEach(f=>EH.PCOR.sel.option(f));
  EH.PCOR.sel.selected(EH.PCOR.fluid||'WBM');
  EH.PCOR.sel.changed(()=>{ EH.PCOR.fluid = EH.PCOR.sel.value(); });

  // Friction mode quick switch (optional)
  y += gapY + 6;
  mkLabel('Friction mode:', x0, y+4);
  const fmSel = createSelect().position(x0+92, y).size(120, rowH);
  ['hydraulics','generic'].forEach(m=>fmSel.option(m));
  fmSel.selected(FRICTION_MODE);
  fmSel.changed(()=>{
    FRICTION_MODE = fmSel.value();
  });

  // Hydraulics model switch (API vs Refined)
  mkLabel('Hydraulics model:', x0+230, y+4);
  const hmSel = createSelect().position(x0+345, y).size(130, rowH);
  ['API','Refined'].forEach(m=>hmSel.option(m));
  hmSel.selected(HYDRAULICS_MODEL);
  hmSel.changed(()=>{ HYDRAULICS_MODEL = hmSel.value(); });

  // Rheology model shortcut (mirrors top of Rheology panel)
  mkLabel('Rheo:', x0+500, y+4);
  const rSel = createSelect().position(x0+540, y).size(110, rowH);
  ['HB','PowerLaw','Bingham'].forEach(m=>rSel.option(m));
  rSel.selected(ACTIVE_RHEO_MODEL);
  rSel.changed(()=>{
    ACTIVE_RHEO_MODEL = rSel.value();
    doRheologyFit();
  });
}

/* -------- Optional: expose a few helpers for console testing ---------- */
window._setFric = setFrictionMode;
window._setRPM  = setRPM;
window._EH      = EH;